{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/geometry.ts","webpack:///./node_modules/mainloop.js/build/mainloop.min.js","webpack:///./node_modules/codemirror/lib/codemirror.js","webpack:///./src/frames.ts","webpack:///./src/index.ts","webpack:///./node_modules/codemirror/lib/codemirror.css?c00e","webpack:///./node_modules/codemirror/lib/codemirror.css","webpack:///./node_modules/css-loader/dist/runtime/api.js","webpack:///./node_modules/style-loader/lib/addStyles.js","webpack:///./node_modules/style-loader/lib/urls.js","webpack:///./node_modules/codemirror/mode/javascript/javascript.js","webpack:///./src/interpreter.ts","webpack:///./node_modules/js-interpreter/lib/index.js","webpack:///./src/scene.ts","webpack:///./src/gui.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","deg2rad","degrees","Math","PI","rad2deg","radians","Vector2d","x","y","this","polar","angle","modulo","rotate","plus","that","minus","scale","k","th","cos","sin","segmentTo","point","Segment","segmentBy","translation","toString","coords2Vector2d","coords","ORIGIN","from","to","_length","delta","sqrt","draw","ctx","beginPath","moveTo","lineTo","stroke","lerp","ratio","Error","scaled","Path","fragments","map","fragment","fromTo","save","forEach","segment","restore","push","next","concat","totalLength","length","join","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","a","b","q","e","h","f","g","j","u","v","w","window","requestAnimationFrame","Date","now","max","setTimeout","cancelAnimationFrame","clearTimeout","MainLoop","getSimulationTimestep","setSimulationTimestep","getFPS","getMaxAllowedFPS","setMaxAllowedFPS","stop","resetFrameDelta","setBegin","setUpdate","setDraw","setEnd","start","isRunning","undefined","userAgent","navigator","platform","gecko","test","ie_upto10","ie_11up","exec","edge","ie","ie_version","document","documentMode","webkit","qtwebkit","chrome","presto","safari","vendor","mac_geMountainLion","phantom","ios","android","mobile","mac","chromeOS","windows","presto_version","match","Number","flipCtrlCmd","captureRightClick","classTest","cls","RegExp","range","rmClass","node","current","className","after","slice","index","removeChildren","count","childNodes","removeChild","firstChild","removeChildrenAndAdd","parent","appendChild","elt","tag","content","style","createElement","cssText","createTextNode","eltP","setAttribute","contains","child","nodeType","parentNode","host","activeElt","activeElement","body","shadowRoot","addClass","joinClasses","as","split","createRange","end","endNode","setStart","createTextRange","moveToElementText","collapse","moveEnd","moveStart","selectInput","select","args","Array","arguments","apply","copyObj","obj","target","overwrite","prop","countColumn","string","tabSize","startIndex","startValue","search","nextTab","indexOf","selectionStart","selectionEnd","_e","Delayed","id","array","set","ms","scrollerGap","Pass","sel_dontScroll","scroll","sel_mouse","origin","sel_move","findColumn","goal","pos","col","skipped","min","spaceStrs","spaceStr","lst","arr","out","nothing","createObj","base","props","inst","nonASCIISingleCaseWordChar","isWordCharBasic","ch","toUpperCase","toLowerCase","isWordChar","helper","source","isEmpty","extendingChars","isExtendingChar","charCodeAt","skipExtendingChars","str","dir","charAt","findFirst","pred","midF","mid","ceil","floor","Display","place","doc","input","scrollbarFiller","gutterFiller","lineDiv","selectionDiv","cursorDiv","measure","lineMeasure","lineSpace","lines","mover","sizer","sizerWidth","heightForcer","gutters","lineGutter","scroller","wrapper","zIndex","paddingRight","draggable","viewFrom","viewTo","first","reportedViewFrom","reportedViewTo","view","renderedView","externalMeasured","viewOffset","lastWrapHeight","lastWrapWidth","updateLineNumbers","nativeBarWidth","barHeight","barWidth","scrollbarsClipped","lineNumWidth","lineNumInnerWidth","lineNumChars","alignWidgets","cachedCharWidth","cachedTextHeight","cachedPaddingH","maxLine","maxLineLength","maxLineChanged","wheelDX","wheelDY","wheelStartX","wheelStartY","shift","selForContextMenu","activeTouch","init","getLine","size","chunk","children","sz","chunkSize","getBetween","line","iter","text","getLines","updateLineHeight","height","diff","lineNo","cur","no","lineAtHeight","outer","i$1","lh","isLine","lineNumberFor","options","String","lineNumberFormatter","firstLineNumber","Pos","sticky","cmp","equalCursorPos","copyPos","maxPos","minPos","clipLine","clipPos","last","linelen","clipToLen","clipPosArray","sawReadOnlySpans","sawCollapsedSpans","MarkedSpan","marker","getMarkedSpanFor","spans","span","removeMarkedSpan","stretchSpansOverChange","change","full","oldFirst","markedSpans","oldLast","startCh","endCh","isInsert","old","nw","startsBefore","inclusiveLeft","type","insertLeft","endsAfter","inclusiveRight","markedSpansBefore","markedSpansAfter","sameLine","offset","found","span$1","found$1","clearEmptySpans","newMarkers","gapMarkers","gap","i$2","i$3","clearWhenEmpty","splice","detachMarkedSpans","detachLine","attachMarkedSpans","attachLine","extraLeft","extraRight","compareCollapsedMarkers","lenDiff","aPos","find","bPos","fromCmp","toCmp","collapsedSpanAtSide","sps","sp","collapsed","collapsedSpanAtStart","collapsedSpanAtEnd","collapsedSpanAround","conflictingCollapsedRange","lineNo$$1","visualLine","merged","visualLineNo","lineN","vis","visualLineEndNo","lastLine","lineIsHidden","widgetNode","lineIsHiddenInner","heightAtLine","lineObj","lineLength","len","findMaxLine","cm","display","bidiOther","getBidiPartAt","order","bidiOrdering","lowTypes","arabicTypes","bidiRE","isNeutral","isStrong","countsAsLeft","countsAsNum","BidiSpan","level","direction","code","outerType","types","prev","type$1","prev$1","type$2","i$4","type$3","replace","i$5","cur$1","type$4","i$6","end$1","before","replace$1","j$1","i$7","at","j$2","nstart","unshift","reverse","getOrder","noHandlers","on","emitter","addEventListener","attachEvent","map$$1","_handlers","getHandlers","off","removeEventListener","detachEvent","signal","handlers","signalDOMEvent","override","preventDefault","defaultPrevented","e_defaultPrevented","codemirrorIgnore","signalCursorActivity","cursorActivity","curOp","cursorActivityHandlers","hasHandler","eventMixin","ctor","e_preventDefault","returnValue","e_stopPropagation","stopPropagation","cancelBubble","e_stop","e_target","srcElement","e_button","which","button","ctrlKey","zwspSupported","badBidiRects","dragAndDrop","div","zeroWidthElement","offsetHeight","offsetWidth","hasBadBidiRects","txt","r0","getBoundingClientRect","r1","left","right","splitLinesAuto","result","nl","rt","hasSelection","getSelection","te","range$$1","ownerDocument","selection","parentElement","compareEndPoints","hasCopyEvent","oncopy","badZoomedRects","modes","mimeModes","resolveMode","spec","getMode","mfactory","modeObj","modeExtensions","exts","helperType","modeProps","prop$1","extendMode","properties","copyState","state","nstate","val","innerMode","info","startState","a1","a2","StringStream","lineOracle","lastColumnPos","lastColumnValue","lineStart","eol","sol","peek","eat","eatWhile","eatSpace","skipToEnd","skipTo","backUp","column","indentation","pattern","consume","caseInsensitive","cased","substr","hideFirstChars","inner","lookAhead","oracle","baseToken","SavedContext","Context","maxLookAhead","baseTokens","baseTokenPos","highlightLine","context","forceToEnd","st","modeGen","lineClasses","runMode","loop","overlay","overlays","i_end","opaque","styles","classes","bgClass","textClass","getLineStyles","updateFrontier","getContextBefore","resetState","maxHighlightLength","stateAfter","styleClasses","highlightFrontier","modeFrontier","precise","minindent","minline","lim","indented","findStartLine","saved","fromSaved","processLine","nextLine","startAt","stream","callBlankLine","readToken","blankLine","token","copy","Token","takeToken","asArray","tokens","extractLineClasses","output","lineClass","flattenSpans","curStart","curStyle","addModeClass","mName","Line","estimateHeight","cleanUpLine","styleToClassCache","styleToClassCacheWithMode","interpretTokenStyle","cache","buildLineContent","lineView","builder","pre","trailingSpace","splitSpaces","getOption","rest","addToken","buildToken","buildTokenBadBidi","allowFrontierUpdate","insertLineContent","maps","caches","lastChild","querySelector","defaultSpecialCharPlaceholder","title","startStyle","endStyle","css","attributes","displayText","trailingBefore","spaceBefore","special","specialChars","mustWrap","createDocumentFragment","lastIndex","txt$1","tabWidth","specialCharPlaceholder","fullStyle","attr","part","buildCollapsedSpan","ignoreWidget","widget","needsContentAttribute","setUneditable","allText","spanStyle","spanEndStyle","spanStartStyle","nextChange","Infinity","foundBookmarks","endStyles","upto","tokenText","LineView","visualLineContinued","hidden","buildViewArray","nextPos","operationGroup","orphanDelayedCallbacks","signalLater","list","delayedCallbacks","fireOrphanDelayed","delayed","updateLineForChanges","dims","changes","updateLineText","updateLineGutter","updateLineClasses","updateLineWidgets","ensureLineWrapped","replaceChild","getLineContent","ext","built","background","wrap","insertBefore","updateLineBackground","wrapClass","gutter","gutterBackground","gutterClass","fixedGutter","fixedPos","gutterTotalWidth","markers","gutterMarkers","lineNumbers","wrap$1","gutterWrap","lineNumber","gutterLeft","gutterWidth","alignable","nextSibling","insertLineWidgets","buildLineElement","insertLineWidgetsFor","allowAbove","widgets","ws","handleMouseEvents","positionLineWidget","above","noHScroll","width","wrapperWidth","coverGutter","paddingLeft","position","marginLeft","widgetHeight","parentStyle","clientWidth","eventInWidget","getAttribute","paddingTop","offsetTop","paddingVert","paddingH","getComputedStyle","currentStyle","data","parseInt","isNaN","scrollGap","displayWidth","displayHeight","clientHeight","mapFromLineView","measureChar","bias","measureCharPrepared","prepareMeasureForLine","findViewForLine","findViewIndex","getDimensions","forceUpdate","updateExternalMeasurement","rect","hasHeights","prepared","varHeight","wrapping","lineWrapping","curWidth","heights","rects","getClientRects","abs","bottom","top","ensureLineHeights","nodeAndOffsetInLineMap","coverStart","coverEnd","getUsefulRect","screen","logicalXDPI","deviceXDPI","normal","fromRange","hasBadZoomedRects","scaleX","scaleY","logicalYDPI","deviceYDPI","maybeUpdateRectForZooming","rSpan","charWidth","nullRect","rtop","rbot","bot","bogus","singleCursorHeightPerLine","rbottom","measureCharInner","measureText","mStart","mEnd","clearLineMeasurementCacheFor","clearLineMeasurementCache","externalMeasure","clearCaches","pageScrollX","pageXOffset","documentElement","scrollLeft","pageScrollY","marginTop","pageYOffset","scrollTop","widgetTopHeight","intoCoordSystem","includeWidgets","yOff","lOff","xOff","fromCoordSystem","localBox","lineSpaceBox","charCoords","cursorCoords","preparedMeasure","getBidi","partPos","invert","other","estimateCoords","PosWithInfo","outside","xRel","coordsChar","coordsCharInner","rangeEnd","wrappedLineExtent","begin","wrappedLineExtentChar","targetTop","boxIsAfter","box","widgetHeight$$1","ltr","_lineNo","ref","closestDist","endX","dist","baseX","chAround","boxAround","atLeft","atStart","textHeight","anchor","clientLeft","offsetLeft","compensateForHScroll","perLine","widgetsHeight","estimateLineHeights","est","estHeight","posFromMouse","liberal","forRect","space","clientX","clientY","colDiff","round","updateSelection","showSelection","prepareSelection","primary","curFragment","cursors","selFragment","sel","ranges","primIndex","empty","showCursorWhenSelecting","drawSelectionCursor","head","drawSelectionRange","cursor","cursorHeight","otherCursor","cmpCoords","padding","leftSide","rightSide","docLTR","add","drawForLine","fromArg","toArg","lineLen","wrapX","side","extent","iterateBidiSections","fromPos","toPos","openStart","openEnd","openLeft","openRight","topLeft","topRight","botLeft","botRight","sFrom","sTo","fromLine","toLine","singleVLine","leftEnd","rightStart","restartBlink","focused","clearInterval","blinker","visibility","cursorBlinkRate","setInterval","ensureFocus","focus","onFocus","delayBlurEvent","delayingBlurEvent","onBlur","readOnly","reset","receivedFocus","updateHeightsInViewport","prevBottom","updateWidgetHeight","chWidth","visibleLines","viewport","ensure","ensureFrom","ensureTo","alignHorizontally","comp","gutterW","align","maybeUpdateLineNumberWidth","innerW","updateGutterSpace","calculateScrollPos","snapMargin","screentop","docBottom","atTop","atBottom","newTop","screenleft","screenw","tooWide","addToScrollTop","resolveScrollToPos","ensureCursorVisible","getCursor","scrollToPos","margin","cursorScrollMargin","scrollToCoords","scrollToCoordsRange","sPos","updateScrollTop","updateDisplaySimple","setScrollTop","startWorker","forceScroll","scrollHeight","scrollbars","setScrollLeft","isScroller","scrollWidth","measureForScrollbars","docH","viewHeight","viewWidth","barLeft","docHeight","NativeScrollbars","vert","horiz","tabIndex","checkedZeroWidth","minHeight","minWidth","update","needsH","needsV","sWidth","totalHeight","totalWidth","zeroWidthHack","disableHoriz","enableZeroWidthBar","disableVert","pointerEvents","bar","delay","maybeDisable","elt$$1","elementFromPoint","clear","NullScrollbars","updateScrollbars","startWidth","startHeight","updateScrollbarsInner","sizes","paddingBottom","borderBottom","coverGutterNextToScrollbar","scrollbarModel","native","null","initScrollbars","scrollbarStyle","axis","nextOpId","startOperation","op","viewChanged","updateInput","typing","changeObjs","cursorActivityCalled","selectionChanged","updateMaxLine","ops","ownsGroup","endOperation","endCb","group","callbacks","fireCallbacksForOps","finishOperation","endOperation_R1","updatedDisplay","mustUpdate","updateDisplayIfNeeded","endOperation_R2","endOperation_W2","endOperation_finish","endOperations","marginBottom","borderRightWidth","maybeClipScrollbars","DisplayUpdate","barMeasure","adjustWidthTo","maxScrollLeft","preparedSelection","takeFocus","setDocumentHeight","postUpdateDisplay","limit","changed","endCoords","scrollPos","startTop","startLeft","scrollPosIntoView","doScroll","innerHeight","scrollNode","scrollIntoView","maybeScrollWindow","maybeHiddenMarkers","unhidden","maybeUnhiddenMarkers","finish","runInOp","operation","methodOp","docMethodOp","regChange","lendiff","resetView","cut","viewCuttingPoint","cut$1","cutTop","cutBot","regLineChange","oldN","newN","countDirtyView","dirty","time","highlight","highlightWorker","workTime","changedLines","oldStyles","highlighted","oldCls","newCls","ischange","workDelay","force","visible","editorIsHidden","wrapperHeight","oldDisplayWidth","events","viewportMargin","different","adjustView","toUpdate","selSnapshot","hasFocus","active","anchorNode","extend","anchorOffset","focusNode","focusOffset","selectionSnapshot","updateNumbersFrom","container","rm","currentWheelTarget","updateNumber","patchDisplay","snapshot","removeAllRanges","addRange","restoreSelection","updateGutters","specs","gElt","setGuttersForLineNumbers","wheelSamples","wheelPixelsPerUnit","wheelEventDelta","dx","wheelDeltaX","dy","wheelDeltaY","detail","HORIZONTAL_AXIS","VERTICAL_AXIS","wheelDelta","wheelEventPixels","onScrollWheel","canScrollX","canScrollY","pixels","movedX","movedY","sample","Selection","equals","here","there","deepCopy","Range","somethingSelected","normalizeSelection","mayTouch","selectionsMayTouch","prim","sort","inv","simpleSelection","changeEnd","adjustForChange","computeSelAfterChange","offsetPos","loadMode","modeOption","resetModeState","isWholeLineUpdate","wholeLineUpdateBefore","updateDoc","estimateHeight$$1","spansFor","updateLine","linesFor","firstLine","lastText","lastSpans","nlines","insert","remove","added","added$1","added$2","linkedDocs","sharedHistOnly","propagate","skip","sharedHist","linked","rel","shared","attachDoc","setDirectionClass","History","startGen","done","undone","undoDepth","lastModTime","lastSelTime","lastOp","lastSelOp","lastOrigin","lastSelOrigin","generation","maxGeneration","historyChangeFromChange","histChange","attachLocalSpans","clearSelectionEvents","pop","addChangeToHistory","selAfter","opId","hist","history","historyEventDelay","lastChangeEvent","pushSelectionToHistory","addSelectionToHistory","selectionEventCanBeMerged","clearRedo","dest","existing","removeClearedSpans","explicitlyCleared","mergeOldSpans","getOldSpans","stretched","oldCur","stretchCur","copyHistoryArray","newGroup","instantiateSel","event","newChanges","extendRange","posBefore","extendSelection","setSelection","extendSelections","heads","newSel","replaceOneSelection","setSimpleSelection","setSelectionReplaceHistory","setSelectionNoUndo","NaN","filterSelectionChange","setSelectionInner","skipAtomicInSelection","reCheckSelection","mayClear","newAnchor","skipAtomic","newHead","skipAtomicInner","oldPos","atomic","near","movePos","far","cantEdit","selectAll","filterChange","canceled","cancel","makeChange","ignoreReadOnly","suppressEdits","mark","parts","mk","newParts","dfrom","dto","removeReadOnlyRanges","makeChangeInner","makeChangeSingleDoc","rebased","rebaseHist","makeChangeFromHistory","allowSelectionOnly","suppress","antiChanges","filter","returned","shiftDoc","distance","removed","recomputeMaxLength","checkWidthStart","retreatFrontier","changesHandler","changeHandler","makeChangeSingleDocInEditor","replaceRange","assign","splitLines","rebaseHistSelSingle","rebaseHistArray","sub","ok","copied","changeLine","handle","changeType","LeafChunk","BranchChunk","removeInner","insertInner","iterN","oldHeight","remaining","leaf","maybeSpill","me","spilled","sibling","myIndex","used","LineWidget","opt","adjustScrollWhenAboveVisible","this$1","oldH","nextMarkerId","TextMarker","markText","cloneNode","isParent","SharedTextMarker","markTextShared","replacedWith","addToHistory","curLine","addMarkedSpan","clearOnEnter","clearHistory","withOp","visual","dHeight","findSharedMarkers","findMarks","detachSharedMarkers","subMarker","nextDocId","Doc","lineSep","cleanGeneration","constructor","getValue","lineSeparator","setValue","getRange","getLineHandle","getLineNumber","getLineHandleVisualStart","lineCount","listSelections","setCursor","extendSelectionsBy","setSelections","addSelection","getSelections","replaceSelection","dup","replaceSelections","hint","oldPrev","newPrev","computeReplacedSel","undo","redo","undoSelection","redoSelection","setExtending","getExtending","historySize","markClean","changeGeneration","forceSplit","isClean","gen","getHistory","setHistory","histData","setGutterMarker","gutterID","clearGutter","lineInfo","addLineClass","where","removeLineClass","addLineWidget","insertAt","aboveVisible","removeLineWidget","setBookmark","realOpts","findMarksAt","getAllMarks","posFromIndex","sepSize","indexFromPos","copyHistory","linkedDoc","mFrom","mTo","subMark","copySharedMarkers","unlinkDoc","CodeMirror","link","splitIds","iterLinkedDocs","getEditor","setDirection","eachLine","lastDrop","onDrop","clearDragCursor","files","dataTransfer","isReadOnly","FileReader","File","read","loadFile","file","allowDropFileTypes","reader","onload","readAsText","draggingText","text$1","getData","selected","dragCursor","forEachCodeMirror","getElementsByClassName","byClass","editors","globalsRegistered","ensureGlobalHandlers","resizeTimer","onResize","setSize","keyNames","3","8","9","13","16","17","18","19","20","27","32","33","34","35","36","37","38","39","40","44","45","46","59","61","91","92","93","106","107","109","110","111","127","145","173","186","187","188","189","190","191","192","219","220","221","222","63232","63233","63234","63235","63272","63273","63275","63276","63277","63302","fromCharCode","keyMap","normalizeKeyName","alt","ctrl","cmd","mod","normalizeKeyMap","keymap","keyname","keys","lookupKey","getKeyMap","fallthrough","isModifierKey","keyCode","addModifierNames","noShift","altKey","metaKey","shiftKey","keyName","altGraphKey","deleteNearSelection","compute","kill","toKill","replaced","moveCharLogically","moveLogically","endOfLine","visually","moveInStorageOrder","prep","basic","Left","Right","Up","Down","End","Home","PageUp","PageDown","Delete","Backspace","Shift-Backspace","Tab","Shift-Tab","Enter","Insert","Esc","pcDefault","Ctrl-A","Ctrl-D","Ctrl-Z","Shift-Ctrl-Z","Ctrl-Y","Ctrl-Home","Ctrl-End","Ctrl-Up","Ctrl-Down","Ctrl-Left","Ctrl-Right","Alt-Left","Alt-Right","Ctrl-Backspace","Ctrl-Delete","Ctrl-S","Ctrl-F","Ctrl-G","Shift-Ctrl-G","Shift-Ctrl-F","Shift-Ctrl-R","Ctrl-[","Ctrl-]","Ctrl-U","Shift-Ctrl-U","Alt-U","emacsy","Ctrl-B","Ctrl-P","Ctrl-N","Alt-F","Alt-B","Ctrl-E","Ctrl-V","Shift-Ctrl-V","Ctrl-H","Alt-D","Alt-Backspace","Ctrl-K","Ctrl-T","Ctrl-O","macDefault","Cmd-A","Cmd-D","Cmd-Z","Shift-Cmd-Z","Cmd-Y","Cmd-Home","Cmd-Up","Cmd-End","Cmd-Down","Cmd-Left","Cmd-Right","Ctrl-Alt-Backspace","Alt-Delete","Cmd-S","Cmd-F","Cmd-G","Shift-Cmd-G","Cmd-Alt-F","Shift-Cmd-Alt-F","Cmd-[","Cmd-]","Cmd-Backspace","Cmd-Delete","Cmd-U","Shift-Cmd-U","commands","singleSelection","killLine","deleteLine","delLineLeft","delWrappedLineLeft","leftPos","delWrappedLineRight","rightPos","goDocStart","goDocEnd","goLineStart","goLineStartSmart","lineStartSmart","goLineEnd","visualLineEnd","lineEnd","goLineRight","goLineLeft","goLineLeftSmart","goLineUp","moveV","goLineDown","goPageUp","goPageDown","goCharLeft","moveH","goCharRight","goColumnLeft","goColumnRight","goWordLeft","goGroupRight","goGroupLeft","goWordRight","delCharBefore","deleteH","delCharAfter","delWordBefore","delWordAfter","delGroupBefore","delGroupAfter","indentAuto","indentSelection","indentMore","indentLess","insertTab","insertSoftTab","spaces","defaultTab","execCommand","transposeChars","newlineAndIndent","sels","indentLine","openLine","toggleOverwrite","firstNonWS","inWS","doHandleBinding","bound","dropShift","ensurePolled","prevShift","stopSeq","dispatchKey","seq","keySeq","dispatchKeyInner","keyMaps","extraKeys","lookupKeyForEditor","handleKeyBinding","motion","lastStoppedKey","onKeyDown","handled","up","showCrossHair","onKeyUp","onKeyPress","charCode","handleCharBinding","lastClick","lastDoubleClick","PastClick","onMouseDown","supportsTouch","clickInGutter","repeat","compare","clickRepeat","selectingText","handleMappedButton","contained","behavior","option","unit","addNew","moveOnDrag","configureMouse","dragDrop","moved","dragEnd","mouseMove","dragStart","e2","leftButtonStartDrag","ourRange","ourIndex","startSel","rangeForUnit","lastPos","extendTo","startCol","posCol","oldRange","ranges$1","anchorLine","boundary","headIndex","usePart","bidiSimplify","editorSize","counter","move","buttons","curCount","leftButtonSelect","leftButtonDown","onContextMenu","findWordAt","gutterEvent","prevent","mX","mY","touches","lineBox","contextMenuInGutter","themeChanged","theme","Init","defaults","optionHandlers","guttersChanged","dragDropChanged","wasOn","funcs","dragFunctions","toggle","enter","over","leave","drop","wrappingChanged","inputStyles","inputStyle","pasteIncoming","cutIncoming","autofocus","word","touchFinished","prevTouch","finishTouch","farAway","touch","radiusX","radiusY","isMouseLikeTouchEvent","pageX","pageY","frag","onDragOver","setData","effectAllowed","setDragImage","img","src","_top","onDragStart","inp","getField","registerEventHandlers","finishInit","initHooks","textRendering","how","aggressive","indent","curSpace","curSpaceString","indentUnit","indentString","indentWithTabs","pos$1","defineInitHook","lastCopied","setLastCopied","newLastCopied","applyTextInput","inserted","deleted","recent","paste","textLines","multiPaste","pasteLinesPerSelection","lineWise","changeEvent","triggerElectric","handlePaste","pasted","clipboardData","disableInput","electricChars","smartIndent","getModeAt","electricInput","copyableRanges","lineRange","disableBrowserMagic","field","spellcheck","autocorrect","autocapitalize","hiddenTextarea","border","findPosH","origDir","moveOnce","boundToLine","bidi","mv","getWrappedLineExtent","searchInVisualLine","getRes","res","nextCh","moveVisually","sawType","getHelper","hitSide","findPosV","pageSize","moveAmount","ContentEditableInput","lastAnchorNode","lastAnchorOffset","lastFocusNode","lastFocusOffset","polling","composing","gracePeriod","readDOMTimeout","posToDOM","badPos","bad","domToPos","lineNode","locateNodeInLineView","textNode","topNode","nodeValue","curNode","textContent","previousSibling","dist$1","onCopyCut","lineWiseCopyCut","clearData","kludge","hadFocus","showPrimarySelection","updateFromDOM","readFromDOMSoon","forceCompositionEnd","showMultipleSelections","curAnchor","curFocus","rng","rangeCount","getRangeAt","startGracePeriod","rememberSelection","selectionInEditor","commonAncestorContainer","blur","pollSelection","pollInterval","poll","scan","isInGutter","triggerOnKeyDown","pollContent","fromIndex","fromNode","toNode","toIndex","newText","closing","extraLinebreak","close","addText","walk","cmText","markerID","isBlock","nodeName","domTextBetween","oldText","cutFront","cutEnd","oldTop","maxCutFront","newBot","oldBot","maxCutEnd","chFrom","chTo","contentEditable","readOnlyChanged","resetPosition","TextareaInput","prevInput","pollingFast","createField","textarea","prepareCopyCut","fastPoll","dispatchEvent","Event","_display","moveInputWithCursor","headPos","wrapOff","lineOff","teTop","teLeft","drawn","contextMenuPending","slowPoll","missed","same","resetSelectionOnContextMenu","oldScrollY","oldCSS","oldWrapperCSS","wrapperBox","offsetParent","scrollY","scrollTo","rehide","detectingSelectAll","prepareSelectAllHack","mouseup","extval","disabled","deflt","notOnInit","defineOption","newBreaks","refresh","getInputField","detach","attach","integer","defineOptions","helpers","setOption","getDoc","addKeyMap","removeKeyMap","addOverlay","score","priority","insertSorted","modeSpec","removeOverlay","newRanges","getTokenAt","getLineTokens","getTokenTypeAt","getHelpers","help","_global","getStateAfter","defaultTextHeight","defaultCharWidth","getViewport","addWidget","vspace","hspace","triggerOnKeyPress","triggerOnKeyUp","triggerOnMouseDown","amount","rtlMoveVisually","goalColumn","goals","startChar","check","getScrollInfo","scrollToRange","interpret","swapDoc","phrase","phraseText","phrases","getWrapperElement","getScrollerElement","getGutterElement","registerHelper","registerGlobalHelper","predicate","addEditorMethods","dontDelegate","method","contenteditable","defineMode","dependencies","defineMIME","mime","defineExtension","func","defineDocExtension","fromTextArea","tabindex","placeholder","realSubmit","form","leaveSubmitMethodAlone","submit","wrappedSubmit","getTextArea","toTextArea","cmpPos","addLegacyProps","version","factory","geometry_1","Frame","facing","opacity","strokes","foreground","new","with","newStrokes","Animation","duration","elapsed","keyFrame","withKeyFrame","frames_1","interpreter_1","gui_1","PainterStudio","_this","isFreezing","animation","frame","painter","Painter","animate","freeze","setAnimation","lastFrame","getNextAnimation","speed","currentFrame","drawPaper","defaultColor","WIDTH","canvas","HEIGHT","X","Y","fillStyle","fillRect","strokeStyle","STEP","lineWidth","canvasHolder","getElementById","getContext","studio","setCanvasSize","translate","lineCap","lineJoin","txtCode","editor","Ctrl-Alt-Enter","setState","Ctrl-Enter","Shift-Ctrl-Enter","txtOut","btnPause","btnSfwd","btnPlay","btnFfwd","btnStop","chkTrace","clearEditorMarks","interpreter","MAX_LOOP_COUNT","loopCount","instruction","stepToNextInstruction","checked","_","markError","innerHTML","err","message","startPos","endPos","nextState","hide","show","disable","ensureRunning","Interpreter","elements","_i","element","classList","hmr","transform","insertInto","locals","useSourceMap","item","cssMapping","btoa","sourceMapping","sourceMap","unescape","encodeURIComponent","JSON","stringify","sourceURLs","sources","sourceRoot","cssWithMappingToString","mediaQuery","alreadyImportedModules","fn","memo","stylesInDom","isOldIE","all","atob","getElement","styleTarget","HTMLIFrameElement","contentDocument","singleton","singletonCounter","stylesInsertedAtTop","fixUrls","addStylesToDom","domStyle","refs","addStyle","listToStyles","newStyles","media","insertStyleElement","lastStyleElementInsertedAtTop","removeStyleElement","idx","createStyleElement","attrs","nonce","nc","getNonce","addAttrs","el","default","styleIndex","applyToSingletonTag","URL","createObjectURL","revokeObjectURL","Blob","createLinkElement","autoFixUrls","convertToAbsoluteUrls","blob","oldSrc","href","styleSheet","newObj","DEBUG","newList","mayRemove","textStore","replaceText","replacement","Boolean","cssNode","location","baseUrl","protocol","currentDir","pathname","fullMatch","origUrl","newUrl","unquotedOrigUrl","trim","$1","config","parserConfig","statementIndent","jsonldMode","jsonld","jsonMode","json","isTS","typescript","wordRE","wordCharacters","keywords","kw","A","B","C","D","operator","atom","if","while","else","do","try","finally","return","break","continue","delete","void","throw","debugger","var","const","let","function","catch","for","switch","case","in","typeof","instanceof","true","false","class","super","yield","export","import","extends","await","isOperatorChar","isJsonldKeyword","ret","tp","cont","tokenBase","quote","tokenize","escaped","tokenComment","expressionAllowed","inSet","readRegexp","tokenQuasi","lexical","lastType","propertyIsEnumerable","maybeEnd","brackets","findFatArrow","fatArrowAt","arrow","depth","sawSomething","bracket","atomicTypes","number","variable","regexp","jsonld-keyword","JSLexical","inScope","varname","localVars","cx","vars","marked","cc","pass","inList","register","block","newContext","registerVarScoped","Var","globalVars","isModifier","defaultVars","pushcontext","pushblockcontext","popcontext","pushlex","lex","poplex","expect","wanted","exp","statement","vardef","parenExpr","maybeexpression","maybeelse","functiondef","forspec","enumdef","typename","typeexpr","expression","maybelabel","maybeCatchBinding","afterExport","afterImport","funarg","expressionInner","expressionNoComma","noComma","arrowBodyNoComma","arrowBody","commasep","maybeop","maybeoperatorNoComma","maybeoperatorComma","classExpression","arrayLiteral","contCommasep","objprop","quasi","targetNoComma","maybeTypeArgs","maybeTarget","expr","continueQuasi","getterSetter","afterprop","maybetype","what","sep","proceed","mayberettype","isKW","afterType","typeprop","typearg","maybeReturnType","functiondecl","typeparam","maybeTypeDefault","maybeAssign","vardefCont","eltpattern","proppattern","_type","forspec1","forspec2","classNameAfter","classBody","classfield","isInterface","maybeFrom","exportField","importSpec","maybeMoreImports","maybeAs","enummember","basecolumn","combinator","parseJS","textAfter","firstChar","isContinuedStatement","doubleIndentSwitch","blockCommentStart","blockCommentEnd","blockCommentContinue","lineComment","fold","closeBrackets","skipExpression","JSInterpreter","scene_1","Instruction","currentState","mode_","isLoop","switchValue_","cases","index_","test_","discriminant","throwValue","handler","param","consequent","alternate","n_","expressions","doneArgs_","MOVE_DURATION","ROTATE_DURATION","RISE_DURATION","FALL_DURATION","FADE_DURATION","instructionStack","scope","color","facingRadians","Stroke","fg","checkRange","fnWrapper","setProperty","createNativeFunction","desc","bg","question","prompt","createPrimitive","words","seconds","random","ast","step","recoverState","stateStack","seek","currentNode","doneVariable_","isSwitch","doneBlock_","doneExec_","doneCallee_","currentInstruction","configurable","_typeof","iterator","acorn","clone","opt_initFunc","parse","PARSE_OPTIONS","initFunc_","paused_","polyfills_","UNDEFINED","Primitive","NULL","NAN","TRUE","FALSE","NUMBER_ZERO","NUMBER_ONE","STRING_EMPTY","global","createScope","NUMBER","BOOLEAN","STRING","stripLocations_","thisExpression","run","ecmaVersion","READONLY_DESCRIPTOR","writable","NONENUMERABLE_DESCRIPTOR","READONLY_NONENUMERABLE_DESCRIPTOR","appendCode","populateScope_","initGlobalScope","initFunction","initObject","OBJECT","initArray","initNumber","initString","initBoolean","initDate","initMath","initRegExp","initJSON","initError","thisInterpreter","num","toNumber","isFinite","getProperty","createObject","FUNCTION","eval","strFunctions","escape","decodeURI","decodeURIComponent","encodeURI","nativeFunc","throwException","URI_ERROR","identifierRegexp","var_args","newFunc","SYNTAX_ERROR","parentScope","boxThis","isPrimitive","getScope","strict","thisArg","func_","funcThis_","arguments_","isa","ARRAY","TYPE_ERROR","setNativeFunctionPrototype","valueOf","pseudoList","notEnumerable","descriptor","preventExtensions","nativeDescriptor","pseudoToNative","notConfigurable","notWritable","setter","getInt","def","strictComp","newArray","arrayIndex","RANGE_ERROR","tmp","howmany","opt_begin","opt_end","opt_separator","searchElement","opt_fromIndex","numConsts","parseFloat","radix","fractionDigits","toExponential","digits","toFixed","precision","toPrecision","locales","toLocaleString","functions","searchValue","lastIndexOf","compareString","localeCompare","separator","REGEXP","jsList","newSubStr","toBoolean","DATE","newDate","Function","getTime","dateString","UTC","myMath","mathConsts","numFunctions","flags","rgx","populateRegExp_","myJSON","nativeObj","nativeToPseudo","ERROR","opt_message","newError","createErrorSubclass","EVAL_ERROR","REFERENCE_ERROR","aValue","bValue","pow","strs","pseudoRegexp","nativeRegexp","ignoreCase","multiline","createFunction","params","createAsyncFunction","asyncFunc","pseudoObj","isGetter","hasProperty","TypeError","opt_descriptor","newLength","deleteProperty","firstNode","createSpecialScope","opt_scope","getValueFromScope","nameStr","prevNode","setValueToScope","declarations","nodeClass","errorClass","error","executeException","realError","errorTable","EvalError","RangeError","ReferenceError","SyntaxError","URIError","pushGetter_","funcThis","pushSetter_","takeStateSnapshot","newStateStack","restoreStateSnapshot","array_","doneLeft_","components","doneRight_","leftSide_","doneGetter_","leftValue_","doneSetter_","rightValue","leftNumber","rightNumber","leftValue","label","callee","isConstructor_","paramName","paramValue","argsList","funcState","argsWithCallback","done_","doneObject_","variable_","iterator_","object_","doneProperty_","computed","valueToggle","valueToggle_","key_","kind_","kind","kinds","argument","checked_","switchCase","doneHandler_","doneFinalizer_","finalizer","changeValue","prefix","declarationNode","doneBody_","reservedWords","5","6","strictBind","ecma5AndLessKeywords","nonASCIIidentifierStartChars","nonASCIIidentifierChars","nonASCIIidentifierStart","nonASCIIidentifier","astralIdentifierStartCodes","astralIdentifierCodes","isInAstralSet","isIdentifierStart","astral","isIdentifierChar","TokenType","conf","keyword","beforeExpr","startsExpr","isAssign","postfix","binop","updateContext","prec","keywordTypes","tt","eof","bracketL","bracketR","braceL","braceR","parenL","parenR","comma","semi","colon","dot","template","ellipsis","backQuote","dollarBraceL","eq","incDec","logicalOR","logicalAND","bitwiseOR","bitwiseXOR","bitwiseAND","equality","relational","bitShift","plusMin","star","slash","starstar","_break","_case","_catch","_continue","_debugger","_default","_do","_else","_finally","_for","_function","_if","_return","_switch","_throw","_try","_var","_const","_while","_with","_new","_super","_class","_extends","_export","_import","_null","_true","_false","_in","_instanceof","_void","_delete","lineBreak","lineBreakG","isNewLine","nonASCIIwhitespace","skipWhiteSpace","isArray","has","propName","Position","SourceLocation","sourceFile","getLineInfo","defaultOptions","sourceType","onInsertedSemicolon","onTrailingComma","allowReserved","allowReturnOutsideFunction","allowImportExportEverywhere","allowHashBang","locations","onToken","onComment","program","directSourceFile","preserveParens","plugins","getOptions","opts","startLoc","endLoc","comment","loc","pushComment","keywordRegexp","Parser","reserved","reservedStrict","reservedWordsStrict","reservedWordsStrictBind","containsEsc","loadPlugins","curPosition","lastTokEndLoc","lastTokStartLoc","lastTokStart","lastTokEnd","initialContext","exprAllowed","inModule","strictDirective","potentialArrowAt","inFunction","inGenerator","inAsync","yieldPos","awaitPos","labels","skipLineComment","isKeyword","isReservedWord","pluginConfigs","plugin","startNode","nextToken","parseTopLevel","pp","literal","isContextual","eatContextual","expectContextual","unexpected","canInsertSemicolon","insertSemicolon","semicolon","afterTrailingComma","tokType","notNext","raise","DestructuringErrors","shorthandAssign","trailingComma","parenthesizedAssign","parenthesizedBind","checkPatternErrors","refDestructuringErrors","raiseRecoverable","parens","checkExpressionErrors","andThrow","checkYieldAwaitInDefaultParams","isSimpleAssignTarget","pp$1","stmt","parseStatement","finishNode","loopLabel","switchLabel","isLet","ident","isAsyncFunction","declaration","topLevel","starttype","parseBreakContinueStatement","parseDebuggerStatement","parseDoStatement","parseForStatement","parseFunctionStatement","parseClass","parseIfStatement","parseReturnStatement","parseSwitchStatement","parseThrowStatement","parseTryStatement","parseVarStatement","parseWhileStatement","parseWithStatement","parseBlock","parseEmptyStatement","parseImport","parseExport","maybeName","parseExpression","parseLabeledStatement","parseExpressionStatement","isBreak","parseIdent","lab","parseParenExpression","parseFor","init$1","parseVar","parseForIn","toAssignable","checkLVal","isAsync","parseFunction","isFunction","sawDefault","isCase","clause","parseBindingAtom","statementStart","generator","isFor","decl","parseVarId","parseMaybeAssign","isStatement","allowExpressionBody","async","oldInGen","oldInAsync","oldYieldPos","oldAwaitPos","oldInFunc","parseFunctionParams","parseFunctionBody","parseBindingList","parseClassId","parseClassSuper","hadConstructor","isGenerator","isMaybeStatic","parsePropertyName","static","isGetSet","parseClassMethod","paramCount","parseMethod","superClass","parseExprSubscripts","parseExprAtom","checkExport","fNode","cNode","shouldParseExportStatement","checkVariableExport","specifiers","parseExportSpecifiers","local","checkPatternExport","pat","decls","nodes","exported","parseImportSpecifiers","node$1","node$2","imported","pp$2","isBinding","toAssignableList","exprList","arg","parseSpread","parseRest","allowNonIdent","parseObj","allowEmpty","allowTrailingComma","elts","parseBindingListItem","elem","parseMaybeDefault","startNodeAt","checkClashes","pp$3","checkPropClash","propHash","shorthand","proto","noIn","afterLeftParse","parseYield","ownDestructuringErrors","oldParenAssign","parseMaybeConditional","parseExprOps","parseMaybeUnary","parseExprOp","leftStartPos","leftStartLoc","minPrec","logical","buildBinary","sawUnary","parseAwait","skipArrowSubscripts","parseSubscripts","noCalls","maybeAsyncArrow","parseExprList","parseArrowExpression","parseTemplate","canBeArrow","parseLiteral","regex","raw","parseParenAndDistinguishExpression","parseNew","spreadStart","innerParenStart","innerStartPos","innerStartLoc","lastIsComma","parseParenItem","innerEndPos","innerEndLoc","parseParenArrowList","finishNodeAt","par","empty$1","meta","parseTemplateElement","cooked","tail","curElt","quasis","isPattern","parsePropertyValue","isArrowFunction","isExpression","oldStrict","useStrict","nonSimple","isSimpleParamList","oldLabels","checkParams","nameHash","delegate","pp$4","raisedAt","Node","parser","pp$5","TokContext","isExpr","preserveSpace","b_stat","b_expr","b_tmpl","p_stat","p_expr","q_tmpl","readTmplToken","f_expr","pp$6","braceIsBlock","prevType","curContext","statementParens","pp$7","isRhino","Packages","tryCreateRegexp","throwErrorAt","getToken","self","skipSpace","finishToken","fullCharCodeAtPos","readWord","getTokenFromCode","skipBlockComment","startSkip","readToken_dot","readNumber","next2","readToken_slash","finishOp","readToken_mult_modulo_exp","tokentype","readToken_pipe_amp","readToken_caret","readToken_plus_min","readToken_lt_gt","readToken_eq_excl","readRadixNumber","readString","codePointToString","regexpUnicodeSupport","inClass","mods","readWord1","tmpFlags","validFlags","_match","readInt","total","startsWithDot","isFloat","octal","readCodePoint","codePos","readHexChar","chunkStart","readEscapedChar","inTemplate","octalStr","escStart","esc","parseExpressionAt","tokenizer","addLooseExports","parse_dammit","LooseParser","pluginsLoose","tokTypes","tokContexts","byteLength","b64","placeHoldersCount","toByteArray","placeHolders","Arr","L","revLookup","fromByteArray","uint8","extraBytes","len2","encodeChunk","lookup","Uint8Array","base64","ieee754","kMaxLength","Buffer","TYPED_ARRAY_SUPPORT","createBuffer","__proto__","encodingOrOffset","allocUnsafe","ArrayBuffer","byteOffset","fromArrayLike","fromArrayBuffer","encoding","isEncoding","actual","write","fromString","isBuffer","buffer","fromObject","assertSize","isView","loweredCase","utf8ToBytes","base64ToBytes","swap","bidirectionalIndexOf","arrayIndexOf","indexSize","arrLength","valLength","buf","readUInt16BE","foundIndex","hexWrite","strLen","parsed","utf8Write","blitBuffer","asciiWrite","byteArray","asciiToBytes","latin1Write","base64Write","ucs2Write","units","hi","lo","utf16leToBytes","base64Slice","utf8Slice","secondByte","thirdByte","fourthByte","tempCodePoint","firstByte","codePoint","bytesPerSequence","codePoints","MAX_ARGUMENTS_LENGTH","decodeCodePointsArray","SlowBuffer","alloc","INSPECT_MAX_BYTES","foo","subarray","typedArraySupport","poolSize","_augment","species","fill","allocUnsafeSlow","_isBuffer","swap16","swap32","swap64","hexSlice","asciiSlice","latin1Slice","utf16leSlice","inspect","thisStart","thisEnd","thisCopy","targetCopy","includes","toJSON","_arr","toHex","bytes","checkOffset","checkInt","objectWriteUInt16","littleEndian","objectWriteUInt32","checkIEEE754","writeFloat","noAssert","writeDouble","newBuf","sliceLen","readUIntLE","mul","readUIntBE","readUInt8","readUInt16LE","readUInt32LE","readUInt32BE","readIntLE","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUIntLE","writeUIntBE","writeUInt8","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeIntLE","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","INVALID_BASE64_RE","leadSurrogate","stringtrim","base64clean","dst","nativeMap","nativeSet","nativePromise","Map","Set","Promise","circular","includeNonEnumerable","allParents","allChildren","useBuffer","_clone","resolve","reject","then","__isArray","__isRegExp","__getRegExpFlags","__isDate","getPrototypeOf","keyChild","valueChild","entryChild","getOwnPropertyDescriptor","getOwnPropertySymbols","symbols","symbol","allPropertyNames","getOwnPropertyNames","propertyName","__objToStr","re","clonePrototype","isLE","mLen","nBytes","eLen","eMax","eBias","nBits","log","LN2","SceneState","drawing","scene","PainterState","_a","_b","_c","_d","_f","ZOOM_DOWN","ZOOM_UP","z","zoom","brushColor","cy","_5","_3","zRatio","globalAlpha","red","green","blue"],"mappings":"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","file":"app.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 4);\n","export type Radians = number;\nexport type Degrees = number;\n\nexport function deg2rad(degrees: Degrees): Radians {\n    return degrees / 180 * Math.PI;\n}\nexport function rad2deg(radians: Radians): Degrees {\n    return radians * 180 / Math.PI;\n}\n\nexport class Vector2d {\n    readonly x: number;\n    readonly y: number;\n\n    static x(x: number): Vector2d {\n        return new Vector2d(x, 0);\n    }\n    static y(y: number): Vector2d {\n        return new Vector2d(0, y);\n    }\n    static polar(angle: Radians, modulo: number) {\n        return Vector2d.y(modulo).rotate(angle);\n    }\n\n    constructor(x: number = 0, y: number = 0) {\n        this.x = x;\n        this.y = y;\n    }\n\n    plus(that: Vector2d): Vector2d {\n        return new Vector2d(this.x + that.x, this.y + that.y);\n    }\n\n    minus(that: Vector2d): Vector2d {\n        return new Vector2d(this.x - that.x, this.y - that.y);\n    }\n\n    scale(k: number): Vector2d {\n        return new Vector2d(k * this.x, k * this.y);\n    }\n\n    rotate(th: Radians): Vector2d {\n        let x = this.x * Math.cos(th) - this.y * Math.sin(th);\n        let y = this.x * Math.sin(th) + this.y * Math.cos(th);\n        return new Vector2d(x, y);\n    }\n\n    segmentTo(point: Vector2d): Segment {\n        return new Segment(this, point);\n    }\n    segmentBy(translation: Vector2d): Segment {\n        return new Segment(this, this.plus(translation));\n    }\n\n    toString(): string {\n        return `(${this.x},${this.y})`;\n    }\n};\nexport namespace Vector2d {\n    export const ORIGIN = new Vector2d;\n}\n\nexport type Coords = [number, number];\n\nexport function coords2Vector2d(coords: Coords) {\n    return new Vector2d(coords[0], coords[1]);\n}\n\nexport class Segment {\n    private from: Vector2d;\n    private to: Vector2d;\n\n    constructor(from: Vector2d | Coords, to: Vector2d | Coords) {\n        this.from = (from instanceof Vector2d) ? from : coords2Vector2d(from);\n        this.to = (to instanceof Vector2d) ? to : coords2Vector2d(to);\n    }\n\n    private _length: number;\n    get length(): number {\n        if (typeof this._length === \"undefined\") {\n            let delta = this.to.minus(this.from);\n            this._length = Math.sqrt(delta.x * delta.x + delta.y * delta.y);\n        }\n        return this._length;\n    }\n\n    draw(ctx: CanvasRenderingContext2D) {\n        ctx.beginPath();\n        ctx.moveTo(this.from.x, this.from.y);\n        ctx.lineTo(this.to.x, this.to.y);\n        ctx.stroke();\n    }\n\n    lerp(ratio: number): Segment {\n        if (ratio < 0 || ratio > 1) {\n            throw new Error(\"Cannot generate line with ratio=\" + ratio);\n        }\n\n        let delta = this.to.minus(this.from).scale(ratio);\n        return new Segment(this.from, this.from.plus(delta));\n    }\n\n    scaled(k: number): Segment {\n        return new Segment(this.from.scale(k), this.to.scale(k));\n    }\n\n    toString(): string {\n        return `${this.from}->${this.to}`;\n    }\n}\n\ntype FromTo = [Coords, Coords];\n\nfunction fromTo2Segment(fromTo: FromTo) {\n    return new Segment(fromTo[0], fromTo[1]);\n}\n\nexport class Path {\n    private fragments: Segment[];\n    constructor(fragments: Array<Segment | FromTo> = []) {\n        this.fragments = fragments.map(fragment =>\n            (fragment instanceof Segment) ? fragment : fromTo2Segment(fragment));\n    }\n\n    draw(ctx: CanvasRenderingContext2D) {\n        ctx.save();\n        this.fragments.forEach(segment => segment.draw(ctx));\n        ctx.restore();\n    }\n\n    push(next: Segment): Path {\n        return new Path(this.fragments.concat(next));\n    }\n\n    get totalLength(): number {\n        let totalLength = 0, timeLength;\n        for (let i = 0; i < this.fragments.length; i++) {\n            let fragment = this.fragments[i];\n            totalLength += fragment.length;\n        }\n\n        return totalLength;\n    }\n\n    scaled(k: number) {\n        return new Path(this.fragments.map(segment => segment.scaled(k)));\n    }\n\n    toString(): string {\n        return this.fragments.join(\", \");\n    }\n}\n","/**\n * mainloop.js 1.0.3-20170529\n *\n * @author Isaac Sukin (http://www.isaacsukin.com/)\n * @license MIT\n */\n\n!function(a){function b(a){if(x=q(b),!(a<e+l)){for(d+=a-e,e=a,t(a,d),a>i+h&&(f=g*j*1e3/(a-i)+(1-g)*f,i=a,j=0),j++,k=0;d>=c;)if(u(c),d-=c,++k>=240){o=!0;break}v(d/c),w(f,o),o=!1}}var c=1e3/60,d=0,e=0,f=60,g=.9,h=1e3,i=0,j=0,k=0,l=0,m=!1,n=!1,o=!1,p=\"object\"==typeof window?window:a,q=p.requestAnimationFrame||function(){var a=Date.now(),b,d;return function(e){return b=Date.now(),d=Math.max(0,c-(b-a)),a=b+d,setTimeout(function(){e(b+d)},d)}}(),r=p.cancelAnimationFrame||clearTimeout,s=function(){},t=s,u=s,v=s,w=s,x;a.MainLoop={getSimulationTimestep:function(){return c},setSimulationTimestep:function(a){return c=a,this},getFPS:function(){return f},getMaxAllowedFPS:function(){return 1e3/l},setMaxAllowedFPS:function(a){return\"undefined\"==typeof a&&(a=1/0),0===a?this.stop():l=1e3/a,this},resetFrameDelta:function(){var a=d;return d=0,a},setBegin:function(a){return t=a||t,this},setUpdate:function(a){return u=a||u,this},setDraw:function(a){return v=a||v,this},setEnd:function(a){return w=a||w,this},start:function(){return n||(n=!0,x=q(function(a){v(1),m=!0,e=a,i=a,j=0,x=q(b)})),this},stop:function(){return m=!1,n=!1,r(x),this},isRunning:function(){return m}},\"function\"==typeof define&&define.amd?define(a.MainLoop):\"object\"==typeof module&&null!==module&&\"object\"==typeof module.exports&&(module.exports=a.MainLoop)}(this);\n//# sourceMappingURL=mainloop.min.js.map","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n// This is CodeMirror (https://codemirror.net), a code editor\n// implemented in JavaScript on top of the browser's DOM.\n//\n// You can find some technical background for some of the code below\n// at http://marijnhaverbeke.nl/blog/#cm-internals .\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global.CodeMirror = factory());\n}(this, (function () { 'use strict';\n\n  // Kludges for bugs and behavior differences that can't be feature\n  // detected are enabled based on userAgent etc sniffing.\n  var userAgent = navigator.userAgent;\n  var platform = navigator.platform;\n\n  var gecko = /gecko\\/\\d/i.test(userAgent);\n  var ie_upto10 = /MSIE \\d/.test(userAgent);\n  var ie_11up = /Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(userAgent);\n  var edge = /Edge\\/(\\d+)/.exec(userAgent);\n  var ie = ie_upto10 || ie_11up || edge;\n  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);\n  var webkit = !edge && /WebKit\\//.test(userAgent);\n  var qtwebkit = webkit && /Qt\\/\\d+\\.\\d+/.test(userAgent);\n  var chrome = !edge && /Chrome\\//.test(userAgent);\n  var presto = /Opera\\//.test(userAgent);\n  var safari = /Apple Computer/.test(navigator.vendor);\n  var mac_geMountainLion = /Mac OS X 1\\d\\D([8-9]|\\d\\d)\\D/.test(userAgent);\n  var phantom = /PhantomJS/.test(userAgent);\n\n  var ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\\/\\w+/.test(userAgent);\n  var android = /Android/.test(userAgent);\n  // This is woefully incomplete. Suggestions for alternative methods welcome.\n  var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);\n  var mac = ios || /Mac/.test(platform);\n  var chromeOS = /\\bCrOS\\b/.test(userAgent);\n  var windows = /win/i.test(platform);\n\n  var presto_version = presto && userAgent.match(/Version\\/(\\d*\\.\\d*)/);\n  if (presto_version) { presto_version = Number(presto_version[1]); }\n  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }\n  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X\n  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));\n  var captureRightClick = gecko || (ie && ie_version >= 9);\n\n  function classTest(cls) { return new RegExp(\"(^|\\\\s)\" + cls + \"(?:$|\\\\s)\\\\s*\") }\n\n  var rmClass = function(node, cls) {\n    var current = node.className;\n    var match = classTest(cls).exec(current);\n    if (match) {\n      var after = current.slice(match.index + match[0].length);\n      node.className = current.slice(0, match.index) + (after ? match[1] + after : \"\");\n    }\n  };\n\n  function removeChildren(e) {\n    for (var count = e.childNodes.length; count > 0; --count)\n      { e.removeChild(e.firstChild); }\n    return e\n  }\n\n  function removeChildrenAndAdd(parent, e) {\n    return removeChildren(parent).appendChild(e)\n  }\n\n  function elt(tag, content, className, style) {\n    var e = document.createElement(tag);\n    if (className) { e.className = className; }\n    if (style) { e.style.cssText = style; }\n    if (typeof content == \"string\") { e.appendChild(document.createTextNode(content)); }\n    else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]); } }\n    return e\n  }\n  // wrapper for elt, which removes the elt from the accessibility tree\n  function eltP(tag, content, className, style) {\n    var e = elt(tag, content, className, style);\n    e.setAttribute(\"role\", \"presentation\");\n    return e\n  }\n\n  var range;\n  if (document.createRange) { range = function(node, start, end, endNode) {\n    var r = document.createRange();\n    r.setEnd(endNode || node, end);\n    r.setStart(node, start);\n    return r\n  }; }\n  else { range = function(node, start, end) {\n    var r = document.body.createTextRange();\n    try { r.moveToElementText(node.parentNode); }\n    catch(e) { return r }\n    r.collapse(true);\n    r.moveEnd(\"character\", end);\n    r.moveStart(\"character\", start);\n    return r\n  }; }\n\n  function contains(parent, child) {\n    if (child.nodeType == 3) // Android browser always returns false when child is a textnode\n      { child = child.parentNode; }\n    if (parent.contains)\n      { return parent.contains(child) }\n    do {\n      if (child.nodeType == 11) { child = child.host; }\n      if (child == parent) { return true }\n    } while (child = child.parentNode)\n  }\n\n  function activeElt() {\n    // IE and Edge may throw an \"Unspecified Error\" when accessing document.activeElement.\n    // IE < 10 will throw when accessed while the page is loading or in an iframe.\n    // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.\n    var activeElement;\n    try {\n      activeElement = document.activeElement;\n    } catch(e) {\n      activeElement = document.body || null;\n    }\n    while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)\n      { activeElement = activeElement.shadowRoot.activeElement; }\n    return activeElement\n  }\n\n  function addClass(node, cls) {\n    var current = node.className;\n    if (!classTest(cls).test(current)) { node.className += (current ? \" \" : \"\") + cls; }\n  }\n  function joinClasses(a, b) {\n    var as = a.split(\" \");\n    for (var i = 0; i < as.length; i++)\n      { if (as[i] && !classTest(as[i]).test(b)) { b += \" \" + as[i]; } }\n    return b\n  }\n\n  var selectInput = function(node) { node.select(); };\n  if (ios) // Mobile Safari apparently has a bug where select() is broken.\n    { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }\n  else if (ie) // Suppress mysterious IE10 errors\n    { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }\n\n  function bind(f) {\n    var args = Array.prototype.slice.call(arguments, 1);\n    return function(){return f.apply(null, args)}\n  }\n\n  function copyObj(obj, target, overwrite) {\n    if (!target) { target = {}; }\n    for (var prop in obj)\n      { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))\n        { target[prop] = obj[prop]; } }\n    return target\n  }\n\n  // Counts the column offset in a string, taking tabs into account.\n  // Used mostly to find indentation.\n  function countColumn(string, end, tabSize, startIndex, startValue) {\n    if (end == null) {\n      end = string.search(/[^\\s\\u00a0]/);\n      if (end == -1) { end = string.length; }\n    }\n    for (var i = startIndex || 0, n = startValue || 0;;) {\n      var nextTab = string.indexOf(\"\\t\", i);\n      if (nextTab < 0 || nextTab >= end)\n        { return n + (end - i) }\n      n += nextTab - i;\n      n += tabSize - (n % tabSize);\n      i = nextTab + 1;\n    }\n  }\n\n  var Delayed = function() {this.id = null;};\n  Delayed.prototype.set = function (ms, f) {\n    clearTimeout(this.id);\n    this.id = setTimeout(f, ms);\n  };\n\n  function indexOf(array, elt) {\n    for (var i = 0; i < array.length; ++i)\n      { if (array[i] == elt) { return i } }\n    return -1\n  }\n\n  // Number of pixels added to scroller and sizer to hide scrollbar\n  var scrollerGap = 30;\n\n  // Returned or thrown by various protocols to signal 'I'm not\n  // handling this'.\n  var Pass = {toString: function(){return \"CodeMirror.Pass\"}};\n\n  // Reused option objects for setSelection & friends\n  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: \"*mouse\"}, sel_move = {origin: \"+move\"};\n\n  // The inverse of countColumn -- find the offset that corresponds to\n  // a particular column.\n  function findColumn(string, goal, tabSize) {\n    for (var pos = 0, col = 0;;) {\n      var nextTab = string.indexOf(\"\\t\", pos);\n      if (nextTab == -1) { nextTab = string.length; }\n      var skipped = nextTab - pos;\n      if (nextTab == string.length || col + skipped >= goal)\n        { return pos + Math.min(skipped, goal - col) }\n      col += nextTab - pos;\n      col += tabSize - (col % tabSize);\n      pos = nextTab + 1;\n      if (col >= goal) { return pos }\n    }\n  }\n\n  var spaceStrs = [\"\"];\n  function spaceStr(n) {\n    while (spaceStrs.length <= n)\n      { spaceStrs.push(lst(spaceStrs) + \" \"); }\n    return spaceStrs[n]\n  }\n\n  function lst(arr) { return arr[arr.length-1] }\n\n  function map(array, f) {\n    var out = [];\n    for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i); }\n    return out\n  }\n\n  function insertSorted(array, value, score) {\n    var pos = 0, priority = score(value);\n    while (pos < array.length && score(array[pos]) <= priority) { pos++; }\n    array.splice(pos, 0, value);\n  }\n\n  function nothing() {}\n\n  function createObj(base, props) {\n    var inst;\n    if (Object.create) {\n      inst = Object.create(base);\n    } else {\n      nothing.prototype = base;\n      inst = new nothing();\n    }\n    if (props) { copyObj(props, inst); }\n    return inst\n  }\n\n  var nonASCIISingleCaseWordChar = /[\\u00df\\u0587\\u0590-\\u05f4\\u0600-\\u06ff\\u3040-\\u309f\\u30a0-\\u30ff\\u3400-\\u4db5\\u4e00-\\u9fcc\\uac00-\\ud7af]/;\n  function isWordCharBasic(ch) {\n    return /\\w/.test(ch) || ch > \"\\x80\" &&\n      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))\n  }\n  function isWordChar(ch, helper) {\n    if (!helper) { return isWordCharBasic(ch) }\n    if (helper.source.indexOf(\"\\\\w\") > -1 && isWordCharBasic(ch)) { return true }\n    return helper.test(ch)\n  }\n\n  function isEmpty(obj) {\n    for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }\n    return true\n  }\n\n  // Extending unicode characters. A series of a non-extending char +\n  // any number of extending chars is treated as a single unit as far\n  // as editing and measuring is concerned. This is not fully correct,\n  // since some scripts/fonts/browsers also treat other configurations\n  // of code points as a group.\n  var extendingChars = /[\\u0300-\\u036f\\u0483-\\u0489\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u065e\\u0670\\u06d6-\\u06dc\\u06de-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0900-\\u0902\\u093c\\u0941-\\u0948\\u094d\\u0951-\\u0955\\u0962\\u0963\\u0981\\u09bc\\u09be\\u09c1-\\u09c4\\u09cd\\u09d7\\u09e2\\u09e3\\u0a01\\u0a02\\u0a3c\\u0a41\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a70\\u0a71\\u0a75\\u0a81\\u0a82\\u0abc\\u0ac1-\\u0ac5\\u0ac7\\u0ac8\\u0acd\\u0ae2\\u0ae3\\u0b01\\u0b3c\\u0b3e\\u0b3f\\u0b41-\\u0b44\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b82\\u0bbe\\u0bc0\\u0bcd\\u0bd7\\u0c3e-\\u0c40\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0cbc\\u0cbf\\u0cc2\\u0cc6\\u0ccc\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0d3e\\u0d41-\\u0d44\\u0d4d\\u0d57\\u0d62\\u0d63\\u0dca\\u0dcf\\u0dd2-\\u0dd4\\u0dd6\\u0ddf\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0f18\\u0f19\\u0f35\\u0f37\\u0f39\\u0f71-\\u0f7e\\u0f80-\\u0f84\\u0f86\\u0f87\\u0f90-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102d-\\u1030\\u1032-\\u1037\\u1039\\u103a\\u103d\\u103e\\u1058\\u1059\\u105e-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108d\\u109d\\u135f\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b7-\\u17bd\\u17c6\\u17c9-\\u17d3\\u17dd\\u180b-\\u180d\\u18a9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193b\\u1a17\\u1a18\\u1a56\\u1a58-\\u1a5e\\u1a60\\u1a62\\u1a65-\\u1a6c\\u1a73-\\u1a7c\\u1a7f\\u1b00-\\u1b03\\u1b34\\u1b36-\\u1b3a\\u1b3c\\u1b42\\u1b6b-\\u1b73\\u1b80\\u1b81\\u1ba2-\\u1ba5\\u1ba8\\u1ba9\\u1c2c-\\u1c33\\u1c36\\u1c37\\u1cd0-\\u1cd2\\u1cd4-\\u1ce0\\u1ce2-\\u1ce8\\u1ced\\u1dc0-\\u1de6\\u1dfd-\\u1dff\\u200c\\u200d\\u20d0-\\u20f0\\u2cef-\\u2cf1\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua66f-\\ua672\\ua67c\\ua67d\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua825\\ua826\\ua8c4\\ua8e0-\\ua8f1\\ua926-\\ua92d\\ua947-\\ua951\\ua980-\\ua982\\ua9b3\\ua9b6-\\ua9b9\\ua9bc\\uaa29-\\uaa2e\\uaa31\\uaa32\\uaa35\\uaa36\\uaa43\\uaa4c\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uabe5\\uabe8\\uabed\\udc00-\\udfff\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe26\\uff9e\\uff9f]/;\n  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }\n\n  // Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.\n  function skipExtendingChars(str, pos, dir) {\n    while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }\n    return pos\n  }\n\n  // Returns the value from the range [`from`; `to`] that satisfies\n  // `pred` and is closest to `from`. Assumes that at least `to`\n  // satisfies `pred`. Supports `from` being greater than `to`.\n  function findFirst(pred, from, to) {\n    // At any point we are certain `to` satisfies `pred`, don't know\n    // whether `from` does.\n    var dir = from > to ? -1 : 1;\n    for (;;) {\n      if (from == to) { return from }\n      var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);\n      if (mid == from) { return pred(mid) ? from : to }\n      if (pred(mid)) { to = mid; }\n      else { from = mid + dir; }\n    }\n  }\n\n  // The display handles the DOM integration, both for input reading\n  // and content drawing. It holds references to DOM nodes and\n  // display-related state.\n\n  function Display(place, doc, input) {\n    var d = this;\n    this.input = input;\n\n    // Covers bottom-right square when both scrollbars are present.\n    d.scrollbarFiller = elt(\"div\", null, \"CodeMirror-scrollbar-filler\");\n    d.scrollbarFiller.setAttribute(\"cm-not-content\", \"true\");\n    // Covers bottom of gutter when coverGutterNextToScrollbar is on\n    // and h scrollbar is present.\n    d.gutterFiller = elt(\"div\", null, \"CodeMirror-gutter-filler\");\n    d.gutterFiller.setAttribute(\"cm-not-content\", \"true\");\n    // Will contain the actual code, positioned to cover the viewport.\n    d.lineDiv = eltP(\"div\", null, \"CodeMirror-code\");\n    // Elements are added to these to represent selection and cursors.\n    d.selectionDiv = elt(\"div\", null, null, \"position: relative; z-index: 1\");\n    d.cursorDiv = elt(\"div\", null, \"CodeMirror-cursors\");\n    // A visibility: hidden element used to find the size of things.\n    d.measure = elt(\"div\", null, \"CodeMirror-measure\");\n    // When lines outside of the viewport are measured, they are drawn in this.\n    d.lineMeasure = elt(\"div\", null, \"CodeMirror-measure\");\n    // Wraps everything that needs to exist inside the vertically-padded coordinate system\n    d.lineSpace = eltP(\"div\", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],\n                      null, \"position: relative; outline: none\");\n    var lines = eltP(\"div\", [d.lineSpace], \"CodeMirror-lines\");\n    // Moved around its parent to cover visible view.\n    d.mover = elt(\"div\", [lines], null, \"position: relative\");\n    // Set to the height of the document, allowing scrolling.\n    d.sizer = elt(\"div\", [d.mover], \"CodeMirror-sizer\");\n    d.sizerWidth = null;\n    // Behavior of elts with overflow: auto and padding is\n    // inconsistent across browsers. This is used to ensure the\n    // scrollable area is big enough.\n    d.heightForcer = elt(\"div\", null, null, \"position: absolute; height: \" + scrollerGap + \"px; width: 1px;\");\n    // Will contain the gutters, if any.\n    d.gutters = elt(\"div\", null, \"CodeMirror-gutters\");\n    d.lineGutter = null;\n    // Actual scrollable element.\n    d.scroller = elt(\"div\", [d.sizer, d.heightForcer, d.gutters], \"CodeMirror-scroll\");\n    d.scroller.setAttribute(\"tabIndex\", \"-1\");\n    // The element in which the editor lives.\n    d.wrapper = elt(\"div\", [d.scrollbarFiller, d.gutterFiller, d.scroller], \"CodeMirror\");\n\n    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)\n    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }\n    if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }\n\n    if (place) {\n      if (place.appendChild) { place.appendChild(d.wrapper); }\n      else { place(d.wrapper); }\n    }\n\n    // Current rendered range (may be bigger than the view window).\n    d.viewFrom = d.viewTo = doc.first;\n    d.reportedViewFrom = d.reportedViewTo = doc.first;\n    // Information about the rendered lines.\n    d.view = [];\n    d.renderedView = null;\n    // Holds info about a single rendered line when it was rendered\n    // for measurement, while not in view.\n    d.externalMeasured = null;\n    // Empty space (in pixels) above the view\n    d.viewOffset = 0;\n    d.lastWrapHeight = d.lastWrapWidth = 0;\n    d.updateLineNumbers = null;\n\n    d.nativeBarWidth = d.barHeight = d.barWidth = 0;\n    d.scrollbarsClipped = false;\n\n    // Used to only resize the line number gutter when necessary (when\n    // the amount of lines crosses a boundary that makes its width change)\n    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;\n    // Set to true when a non-horizontal-scrolling line widget is\n    // added. As an optimization, line widget aligning is skipped when\n    // this is false.\n    d.alignWidgets = false;\n\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n\n    // Tracks the maximum line length so that the horizontal scrollbar\n    // can be kept static when scrolling.\n    d.maxLine = null;\n    d.maxLineLength = 0;\n    d.maxLineChanged = false;\n\n    // Used for measuring wheel scrolling granularity\n    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;\n\n    // True when shift is held down.\n    d.shift = false;\n\n    // Used to track whether anything happened since the context menu\n    // was opened.\n    d.selForContextMenu = null;\n\n    d.activeTouch = null;\n\n    input.init(d);\n  }\n\n  // Find the line object corresponding to the given line number.\n  function getLine(doc, n) {\n    n -= doc.first;\n    if (n < 0 || n >= doc.size) { throw new Error(\"There is no line \" + (n + doc.first) + \" in the document.\") }\n    var chunk = doc;\n    while (!chunk.lines) {\n      for (var i = 0;; ++i) {\n        var child = chunk.children[i], sz = child.chunkSize();\n        if (n < sz) { chunk = child; break }\n        n -= sz;\n      }\n    }\n    return chunk.lines[n]\n  }\n\n  // Get the part of a document between two positions, as an array of\n  // strings.\n  function getBetween(doc, start, end) {\n    var out = [], n = start.line;\n    doc.iter(start.line, end.line + 1, function (line) {\n      var text = line.text;\n      if (n == end.line) { text = text.slice(0, end.ch); }\n      if (n == start.line) { text = text.slice(start.ch); }\n      out.push(text);\n      ++n;\n    });\n    return out\n  }\n  // Get the lines between from and to, as array of strings.\n  function getLines(doc, from, to) {\n    var out = [];\n    doc.iter(from, to, function (line) { out.push(line.text); }); // iter aborts when callback returns truthy value\n    return out\n  }\n\n  // Update the height of a line, propagating the height change\n  // upwards to parent nodes.\n  function updateLineHeight(line, height) {\n    var diff = height - line.height;\n    if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }\n  }\n\n  // Given a line object, find its line number by walking up through\n  // its parent links.\n  function lineNo(line) {\n    if (line.parent == null) { return null }\n    var cur = line.parent, no = indexOf(cur.lines, line);\n    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {\n      for (var i = 0;; ++i) {\n        if (chunk.children[i] == cur) { break }\n        no += chunk.children[i].chunkSize();\n      }\n    }\n    return no + cur.first\n  }\n\n  // Find the line at the given vertical position, using the height\n  // information in the document tree.\n  function lineAtHeight(chunk, h) {\n    var n = chunk.first;\n    outer: do {\n      for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {\n        var child = chunk.children[i$1], ch = child.height;\n        if (h < ch) { chunk = child; continue outer }\n        h -= ch;\n        n += child.chunkSize();\n      }\n      return n\n    } while (!chunk.lines)\n    var i = 0;\n    for (; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i], lh = line.height;\n      if (h < lh) { break }\n      h -= lh;\n    }\n    return n + i\n  }\n\n  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}\n\n  function lineNumberFor(options, i) {\n    return String(options.lineNumberFormatter(i + options.firstLineNumber))\n  }\n\n  // A Pos instance represents a position within the text.\n  function Pos(line, ch, sticky) {\n    if ( sticky === void 0 ) sticky = null;\n\n    if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }\n    this.line = line;\n    this.ch = ch;\n    this.sticky = sticky;\n  }\n\n  // Compare two positions, return 0 if they are the same, a negative\n  // number when a is less, and a positive number otherwise.\n  function cmp(a, b) { return a.line - b.line || a.ch - b.ch }\n\n  function equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }\n\n  function copyPos(x) {return Pos(x.line, x.ch)}\n  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a }\n  function minPos(a, b) { return cmp(a, b) < 0 ? a : b }\n\n  // Most of the external API clips given positions to make sure they\n  // actually exist within the document.\n  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}\n  function clipPos(doc, pos) {\n    if (pos.line < doc.first) { return Pos(doc.first, 0) }\n    var last = doc.first + doc.size - 1;\n    if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }\n    return clipToLen(pos, getLine(doc, pos.line).text.length)\n  }\n  function clipToLen(pos, linelen) {\n    var ch = pos.ch;\n    if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }\n    else if (ch < 0) { return Pos(pos.line, 0) }\n    else { return pos }\n  }\n  function clipPosArray(doc, array) {\n    var out = [];\n    for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]); }\n    return out\n  }\n\n  // Optimize some code when these features are not used.\n  var sawReadOnlySpans = false, sawCollapsedSpans = false;\n\n  function seeReadOnlySpans() {\n    sawReadOnlySpans = true;\n  }\n\n  function seeCollapsedSpans() {\n    sawCollapsedSpans = true;\n  }\n\n  // TEXTMARKER SPANS\n\n  function MarkedSpan(marker, from, to) {\n    this.marker = marker;\n    this.from = from; this.to = to;\n  }\n\n  // Search an array of spans for a span matching the given marker.\n  function getMarkedSpanFor(spans, marker) {\n    if (spans) { for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.marker == marker) { return span }\n    } }\n  }\n  // Remove a span from an array, returning undefined if no spans are\n  // left (we don't store arrays for lines without spans).\n  function removeMarkedSpan(spans, span) {\n    var r;\n    for (var i = 0; i < spans.length; ++i)\n      { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }\n    return r\n  }\n  // Add a span to a line.\n  function addMarkedSpan(line, span) {\n    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];\n    span.marker.attachLine(line);\n  }\n\n  // Used for the algorithm that adjusts markers for a change in the\n  // document. These functions cut an array of spans at a given\n  // character position, returning an array of remaining chunks (or\n  // undefined if nothing remains).\n  function markedSpansBefore(old, startCh, isInsert) {\n    var nw;\n    if (old) { for (var i = 0; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);\n      if (startsBefore || span.from == startCh && marker.type == \"bookmark\" && (!isInsert || !span.marker.insertLeft)) {\n        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh)\n        ;(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));\n      }\n    } }\n    return nw\n  }\n  function markedSpansAfter(old, endCh, isInsert) {\n    var nw;\n    if (old) { for (var i = 0; i < old.length; ++i) {\n      var span = old[i], marker = span.marker;\n      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);\n      if (endsAfter || span.from == endCh && marker.type == \"bookmark\" && (!isInsert || span.marker.insertLeft)) {\n        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh)\n        ;(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,\n                                              span.to == null ? null : span.to - endCh));\n      }\n    } }\n    return nw\n  }\n\n  // Given a change object, compute the new set of marker spans that\n  // cover the line in which the change took place. Removes spans\n  // entirely within the change, reconnects spans belonging to the\n  // same marker that appear on both sides of the change, and cuts off\n  // spans partially within the change. Returns an array of span\n  // arrays with one element for each line in (after) the change.\n  function stretchSpansOverChange(doc, change) {\n    if (change.full) { return null }\n    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;\n    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;\n    if (!oldFirst && !oldLast) { return null }\n\n    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;\n    // Get the spans that 'stick out' on both sides\n    var first = markedSpansBefore(oldFirst, startCh, isInsert);\n    var last = markedSpansAfter(oldLast, endCh, isInsert);\n\n    // Next, merge those two ends\n    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);\n    if (first) {\n      // Fix up .to properties of first\n      for (var i = 0; i < first.length; ++i) {\n        var span = first[i];\n        if (span.to == null) {\n          var found = getMarkedSpanFor(last, span.marker);\n          if (!found) { span.to = startCh; }\n          else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }\n        }\n      }\n    }\n    if (last) {\n      // Fix up .from in last (or move them into first in case of sameLine)\n      for (var i$1 = 0; i$1 < last.length; ++i$1) {\n        var span$1 = last[i$1];\n        if (span$1.to != null) { span$1.to += offset; }\n        if (span$1.from == null) {\n          var found$1 = getMarkedSpanFor(first, span$1.marker);\n          if (!found$1) {\n            span$1.from = offset;\n            if (sameLine) { (first || (first = [])).push(span$1); }\n          }\n        } else {\n          span$1.from += offset;\n          if (sameLine) { (first || (first = [])).push(span$1); }\n        }\n      }\n    }\n    // Make sure we didn't create any zero-length spans\n    if (first) { first = clearEmptySpans(first); }\n    if (last && last != first) { last = clearEmptySpans(last); }\n\n    var newMarkers = [first];\n    if (!sameLine) {\n      // Fill gap with whole-line-spans\n      var gap = change.text.length - 2, gapMarkers;\n      if (gap > 0 && first)\n        { for (var i$2 = 0; i$2 < first.length; ++i$2)\n          { if (first[i$2].to == null)\n            { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }\n      for (var i$3 = 0; i$3 < gap; ++i$3)\n        { newMarkers.push(gapMarkers); }\n      newMarkers.push(last);\n    }\n    return newMarkers\n  }\n\n  // Remove spans that are empty and don't have a clearWhenEmpty\n  // option of false.\n  function clearEmptySpans(spans) {\n    for (var i = 0; i < spans.length; ++i) {\n      var span = spans[i];\n      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)\n        { spans.splice(i--, 1); }\n    }\n    if (!spans.length) { return null }\n    return spans\n  }\n\n  // Used to 'clip' out readOnly ranges when making a change.\n  function removeReadOnlyRanges(doc, from, to) {\n    var markers = null;\n    doc.iter(from.line, to.line + 1, function (line) {\n      if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\n        var mark = line.markedSpans[i].marker;\n        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))\n          { (markers || (markers = [])).push(mark); }\n      } }\n    });\n    if (!markers) { return null }\n    var parts = [{from: from, to: to}];\n    for (var i = 0; i < markers.length; ++i) {\n      var mk = markers[i], m = mk.find(0);\n      for (var j = 0; j < parts.length; ++j) {\n        var p = parts[j];\n        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }\n        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);\n        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)\n          { newParts.push({from: p.from, to: m.from}); }\n        if (dto > 0 || !mk.inclusiveRight && !dto)\n          { newParts.push({from: m.to, to: p.to}); }\n        parts.splice.apply(parts, newParts);\n        j += newParts.length - 3;\n      }\n    }\n    return parts\n  }\n\n  // Connect or disconnect spans from a line.\n  function detachMarkedSpans(line) {\n    var spans = line.markedSpans;\n    if (!spans) { return }\n    for (var i = 0; i < spans.length; ++i)\n      { spans[i].marker.detachLine(line); }\n    line.markedSpans = null;\n  }\n  function attachMarkedSpans(line, spans) {\n    if (!spans) { return }\n    for (var i = 0; i < spans.length; ++i)\n      { spans[i].marker.attachLine(line); }\n    line.markedSpans = spans;\n  }\n\n  // Helpers used when computing which overlapping collapsed span\n  // counts as the larger one.\n  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }\n  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }\n\n  // Returns a number indicating which of two overlapping collapsed\n  // spans is larger (and thus includes the other). Falls back to\n  // comparing ids when the spans cover exactly the same range.\n  function compareCollapsedMarkers(a, b) {\n    var lenDiff = a.lines.length - b.lines.length;\n    if (lenDiff != 0) { return lenDiff }\n    var aPos = a.find(), bPos = b.find();\n    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);\n    if (fromCmp) { return -fromCmp }\n    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);\n    if (toCmp) { return toCmp }\n    return b.id - a.id\n  }\n\n  // Find out whether a line ends or starts in a collapsed span. If\n  // so, return the marker for that span.\n  function collapsedSpanAtSide(line, start) {\n    var sps = sawCollapsedSpans && line.markedSpans, found;\n    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&\n          (!found || compareCollapsedMarkers(found, sp.marker) < 0))\n        { found = sp.marker; }\n    } }\n    return found\n  }\n  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }\n  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }\n\n  function collapsedSpanAround(line, ch) {\n    var sps = sawCollapsedSpans && line.markedSpans, found;\n    if (sps) { for (var i = 0; i < sps.length; ++i) {\n      var sp = sps[i];\n      if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) &&\n          (!found || compareCollapsedMarkers(found, sp.marker) < 0)) { found = sp.marker; }\n    } }\n    return found\n  }\n\n  // Test whether there exists a collapsed span that partially\n  // overlaps (covers the start or end, but not both) of a new span.\n  // Such overlap is not allowed.\n  function conflictingCollapsedRange(doc, lineNo$$1, from, to, marker) {\n    var line = getLine(doc, lineNo$$1);\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) { for (var i = 0; i < sps.length; ++i) {\n      var sp = sps[i];\n      if (!sp.marker.collapsed) { continue }\n      var found = sp.marker.find(0);\n      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);\n      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);\n      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }\n      if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||\n          fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))\n        { return true }\n    } }\n  }\n\n  // A visual line is a line as drawn on the screen. Folding, for\n  // example, can cause multiple logical lines to appear on the same\n  // visual line. This finds the start of the visual line that the\n  // given line is part of (usually that is the line itself).\n  function visualLine(line) {\n    var merged;\n    while (merged = collapsedSpanAtStart(line))\n      { line = merged.find(-1, true).line; }\n    return line\n  }\n\n  function visualLineEnd(line) {\n    var merged;\n    while (merged = collapsedSpanAtEnd(line))\n      { line = merged.find(1, true).line; }\n    return line\n  }\n\n  // Returns an array of logical lines that continue the visual line\n  // started by the argument, or undefined if there are no such lines.\n  function visualLineContinued(line) {\n    var merged, lines;\n    while (merged = collapsedSpanAtEnd(line)) {\n      line = merged.find(1, true).line\n      ;(lines || (lines = [])).push(line);\n    }\n    return lines\n  }\n\n  // Get the line number of the start of the visual line that the\n  // given line number is part of.\n  function visualLineNo(doc, lineN) {\n    var line = getLine(doc, lineN), vis = visualLine(line);\n    if (line == vis) { return lineN }\n    return lineNo(vis)\n  }\n\n  // Get the line number of the start of the next visual line after\n  // the given line.\n  function visualLineEndNo(doc, lineN) {\n    if (lineN > doc.lastLine()) { return lineN }\n    var line = getLine(doc, lineN), merged;\n    if (!lineIsHidden(doc, line)) { return lineN }\n    while (merged = collapsedSpanAtEnd(line))\n      { line = merged.find(1, true).line; }\n    return lineNo(line) + 1\n  }\n\n  // Compute whether a line is hidden. Lines count as hidden when they\n  // are part of a visual line that starts with another line, or when\n  // they are entirely covered by collapsed, non-widget span.\n  function lineIsHidden(doc, line) {\n    var sps = sawCollapsedSpans && line.markedSpans;\n    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {\n      sp = sps[i];\n      if (!sp.marker.collapsed) { continue }\n      if (sp.from == null) { return true }\n      if (sp.marker.widgetNode) { continue }\n      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))\n        { return true }\n    } }\n  }\n  function lineIsHiddenInner(doc, line, span) {\n    if (span.to == null) {\n      var end = span.marker.find(1, true);\n      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))\n    }\n    if (span.marker.inclusiveRight && span.to == line.text.length)\n      { return true }\n    for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {\n      sp = line.markedSpans[i];\n      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&\n          (sp.to == null || sp.to != span.from) &&\n          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&\n          lineIsHiddenInner(doc, line, sp)) { return true }\n    }\n  }\n\n  // Find the height above the given line.\n  function heightAtLine(lineObj) {\n    lineObj = visualLine(lineObj);\n\n    var h = 0, chunk = lineObj.parent;\n    for (var i = 0; i < chunk.lines.length; ++i) {\n      var line = chunk.lines[i];\n      if (line == lineObj) { break }\n      else { h += line.height; }\n    }\n    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {\n      for (var i$1 = 0; i$1 < p.children.length; ++i$1) {\n        var cur = p.children[i$1];\n        if (cur == chunk) { break }\n        else { h += cur.height; }\n      }\n    }\n    return h\n  }\n\n  // Compute the character length of a line, taking into account\n  // collapsed ranges (see markText) that might hide parts, and join\n  // other lines onto it.\n  function lineLength(line) {\n    if (line.height == 0) { return 0 }\n    var len = line.text.length, merged, cur = line;\n    while (merged = collapsedSpanAtStart(cur)) {\n      var found = merged.find(0, true);\n      cur = found.from.line;\n      len += found.from.ch - found.to.ch;\n    }\n    cur = line;\n    while (merged = collapsedSpanAtEnd(cur)) {\n      var found$1 = merged.find(0, true);\n      len -= cur.text.length - found$1.from.ch;\n      cur = found$1.to.line;\n      len += cur.text.length - found$1.to.ch;\n    }\n    return len\n  }\n\n  // Find the longest line in the document.\n  function findMaxLine(cm) {\n    var d = cm.display, doc = cm.doc;\n    d.maxLine = getLine(doc, doc.first);\n    d.maxLineLength = lineLength(d.maxLine);\n    d.maxLineChanged = true;\n    doc.iter(function (line) {\n      var len = lineLength(line);\n      if (len > d.maxLineLength) {\n        d.maxLineLength = len;\n        d.maxLine = line;\n      }\n    });\n  }\n\n  // BIDI HELPERS\n\n  function iterateBidiSections(order, from, to, f) {\n    if (!order) { return f(from, to, \"ltr\", 0) }\n    var found = false;\n    for (var i = 0; i < order.length; ++i) {\n      var part = order[i];\n      if (part.from < to && part.to > from || from == to && part.to == from) {\n        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? \"rtl\" : \"ltr\", i);\n        found = true;\n      }\n    }\n    if (!found) { f(from, to, \"ltr\"); }\n  }\n\n  var bidiOther = null;\n  function getBidiPartAt(order, ch, sticky) {\n    var found;\n    bidiOther = null;\n    for (var i = 0; i < order.length; ++i) {\n      var cur = order[i];\n      if (cur.from < ch && cur.to > ch) { return i }\n      if (cur.to == ch) {\n        if (cur.from != cur.to && sticky == \"before\") { found = i; }\n        else { bidiOther = i; }\n      }\n      if (cur.from == ch) {\n        if (cur.from != cur.to && sticky != \"before\") { found = i; }\n        else { bidiOther = i; }\n      }\n    }\n    return found != null ? found : bidiOther\n  }\n\n  // Bidirectional ordering algorithm\n  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm\n  // that this (partially) implements.\n\n  // One-char codes used for character types:\n  // L (L):   Left-to-Right\n  // R (R):   Right-to-Left\n  // r (AL):  Right-to-Left Arabic\n  // 1 (EN):  European Number\n  // + (ES):  European Number Separator\n  // % (ET):  European Number Terminator\n  // n (AN):  Arabic Number\n  // , (CS):  Common Number Separator\n  // m (NSM): Non-Spacing Mark\n  // b (BN):  Boundary Neutral\n  // s (B):   Paragraph Separator\n  // t (S):   Segment Separator\n  // w (WS):  Whitespace\n  // N (ON):  Other Neutrals\n\n  // Returns null if characters are ordered as they appear\n  // (left-to-right), or an array of sections ({from, to, level}\n  // objects) in the order in which they occur visually.\n  var bidiOrdering = (function() {\n    // Character types for codepoints 0 to 0xff\n    var lowTypes = \"bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN\";\n    // Character types for codepoints 0x600 to 0x6f9\n    var arabicTypes = \"nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111\";\n    function charType(code) {\n      if (code <= 0xf7) { return lowTypes.charAt(code) }\n      else if (0x590 <= code && code <= 0x5f4) { return \"R\" }\n      else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }\n      else if (0x6ee <= code && code <= 0x8ac) { return \"r\" }\n      else if (0x2000 <= code && code <= 0x200b) { return \"w\" }\n      else if (code == 0x200c) { return \"b\" }\n      else { return \"L\" }\n    }\n\n    var bidiRE = /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac]/;\n    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;\n\n    function BidiSpan(level, from, to) {\n      this.level = level;\n      this.from = from; this.to = to;\n    }\n\n    return function(str, direction) {\n      var outerType = direction == \"ltr\" ? \"L\" : \"R\";\n\n      if (str.length == 0 || direction == \"ltr\" && !bidiRE.test(str)) { return false }\n      var len = str.length, types = [];\n      for (var i = 0; i < len; ++i)\n        { types.push(charType(str.charCodeAt(i))); }\n\n      // W1. Examine each non-spacing mark (NSM) in the level run, and\n      // change the type of the NSM to the type of the previous\n      // character. If the NSM is at the start of the level run, it will\n      // get the type of sor.\n      for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {\n        var type = types[i$1];\n        if (type == \"m\") { types[i$1] = prev; }\n        else { prev = type; }\n      }\n\n      // W2. Search backwards from each instance of a European number\n      // until the first strong type (R, L, AL, or sor) is found. If an\n      // AL is found, change the type of the European number to Arabic\n      // number.\n      // W3. Change all ALs to R.\n      for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {\n        var type$1 = types[i$2];\n        if (type$1 == \"1\" && cur == \"r\") { types[i$2] = \"n\"; }\n        else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == \"r\") { types[i$2] = \"R\"; } }\n      }\n\n      // W4. A single European separator between two European numbers\n      // changes to a European number. A single common separator between\n      // two numbers of the same type changes to that type.\n      for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {\n        var type$2 = types[i$3];\n        if (type$2 == \"+\" && prev$1 == \"1\" && types[i$3+1] == \"1\") { types[i$3] = \"1\"; }\n        else if (type$2 == \",\" && prev$1 == types[i$3+1] &&\n                 (prev$1 == \"1\" || prev$1 == \"n\")) { types[i$3] = prev$1; }\n        prev$1 = type$2;\n      }\n\n      // W5. A sequence of European terminators adjacent to European\n      // numbers changes to all European numbers.\n      // W6. Otherwise, separators and terminators change to Other\n      // Neutral.\n      for (var i$4 = 0; i$4 < len; ++i$4) {\n        var type$3 = types[i$4];\n        if (type$3 == \",\") { types[i$4] = \"N\"; }\n        else if (type$3 == \"%\") {\n          var end = (void 0);\n          for (end = i$4 + 1; end < len && types[end] == \"%\"; ++end) {}\n          var replace = (i$4 && types[i$4-1] == \"!\") || (end < len && types[end] == \"1\") ? \"1\" : \"N\";\n          for (var j = i$4; j < end; ++j) { types[j] = replace; }\n          i$4 = end - 1;\n        }\n      }\n\n      // W7. Search backwards from each instance of a European number\n      // until the first strong type (R, L, or sor) is found. If an L is\n      // found, then change the type of the European number to L.\n      for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {\n        var type$4 = types[i$5];\n        if (cur$1 == \"L\" && type$4 == \"1\") { types[i$5] = \"L\"; }\n        else if (isStrong.test(type$4)) { cur$1 = type$4; }\n      }\n\n      // N1. A sequence of neutrals takes the direction of the\n      // surrounding strong text if the text on both sides has the same\n      // direction. European and Arabic numbers act as if they were R in\n      // terms of their influence on neutrals. Start-of-level-run (sor)\n      // and end-of-level-run (eor) are used at level run boundaries.\n      // N2. Any remaining neutrals take the embedding direction.\n      for (var i$6 = 0; i$6 < len; ++i$6) {\n        if (isNeutral.test(types[i$6])) {\n          var end$1 = (void 0);\n          for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}\n          var before = (i$6 ? types[i$6-1] : outerType) == \"L\";\n          var after = (end$1 < len ? types[end$1] : outerType) == \"L\";\n          var replace$1 = before == after ? (before ? \"L\" : \"R\") : outerType;\n          for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1; }\n          i$6 = end$1 - 1;\n        }\n      }\n\n      // Here we depart from the documented algorithm, in order to avoid\n      // building up an actual levels array. Since there are only three\n      // levels (0, 1, 2) in an implementation that doesn't take\n      // explicit embedding into account, we can build up the order on\n      // the fly, without following the level-based algorithm.\n      var order = [], m;\n      for (var i$7 = 0; i$7 < len;) {\n        if (countsAsLeft.test(types[i$7])) {\n          var start = i$7;\n          for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}\n          order.push(new BidiSpan(0, start, i$7));\n        } else {\n          var pos = i$7, at = order.length;\n          for (++i$7; i$7 < len && types[i$7] != \"L\"; ++i$7) {}\n          for (var j$2 = pos; j$2 < i$7;) {\n            if (countsAsNum.test(types[j$2])) {\n              if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); }\n              var nstart = j$2;\n              for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}\n              order.splice(at, 0, new BidiSpan(2, nstart, j$2));\n              pos = j$2;\n            } else { ++j$2; }\n          }\n          if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }\n        }\n      }\n      if (direction == \"ltr\") {\n        if (order[0].level == 1 && (m = str.match(/^\\s+/))) {\n          order[0].from = m[0].length;\n          order.unshift(new BidiSpan(0, 0, m[0].length));\n        }\n        if (lst(order).level == 1 && (m = str.match(/\\s+$/))) {\n          lst(order).to -= m[0].length;\n          order.push(new BidiSpan(0, len - m[0].length, len));\n        }\n      }\n\n      return direction == \"rtl\" ? order.reverse() : order\n    }\n  })();\n\n  // Get the bidi ordering for the given line (and cache it). Returns\n  // false for lines that are fully left-to-right, and an array of\n  // BidiSpan objects otherwise.\n  function getOrder(line, direction) {\n    var order = line.order;\n    if (order == null) { order = line.order = bidiOrdering(line.text, direction); }\n    return order\n  }\n\n  // EVENT HANDLING\n\n  // Lightweight event framework. on/off also work on DOM nodes,\n  // registering native DOM handlers.\n\n  var noHandlers = [];\n\n  var on = function(emitter, type, f) {\n    if (emitter.addEventListener) {\n      emitter.addEventListener(type, f, false);\n    } else if (emitter.attachEvent) {\n      emitter.attachEvent(\"on\" + type, f);\n    } else {\n      var map$$1 = emitter._handlers || (emitter._handlers = {});\n      map$$1[type] = (map$$1[type] || noHandlers).concat(f);\n    }\n  };\n\n  function getHandlers(emitter, type) {\n    return emitter._handlers && emitter._handlers[type] || noHandlers\n  }\n\n  function off(emitter, type, f) {\n    if (emitter.removeEventListener) {\n      emitter.removeEventListener(type, f, false);\n    } else if (emitter.detachEvent) {\n      emitter.detachEvent(\"on\" + type, f);\n    } else {\n      var map$$1 = emitter._handlers, arr = map$$1 && map$$1[type];\n      if (arr) {\n        var index = indexOf(arr, f);\n        if (index > -1)\n          { map$$1[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }\n      }\n    }\n  }\n\n  function signal(emitter, type /*, values...*/) {\n    var handlers = getHandlers(emitter, type);\n    if (!handlers.length) { return }\n    var args = Array.prototype.slice.call(arguments, 2);\n    for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args); }\n  }\n\n  // The DOM events that CodeMirror handles can be overridden by\n  // registering a (non-DOM) handler on the editor for the event name,\n  // and preventDefault-ing the event in that handler.\n  function signalDOMEvent(cm, e, override) {\n    if (typeof e == \"string\")\n      { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }\n    signal(cm, override || e.type, cm, e);\n    return e_defaultPrevented(e) || e.codemirrorIgnore\n  }\n\n  function signalCursorActivity(cm) {\n    var arr = cm._handlers && cm._handlers.cursorActivity;\n    if (!arr) { return }\n    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);\n    for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)\n      { set.push(arr[i]); } }\n  }\n\n  function hasHandler(emitter, type) {\n    return getHandlers(emitter, type).length > 0\n  }\n\n  // Add on and off methods to a constructor's prototype, to make\n  // registering events on such objects more convenient.\n  function eventMixin(ctor) {\n    ctor.prototype.on = function(type, f) {on(this, type, f);};\n    ctor.prototype.off = function(type, f) {off(this, type, f);};\n  }\n\n  // Due to the fact that we still support jurassic IE versions, some\n  // compatibility wrappers are needed.\n\n  function e_preventDefault(e) {\n    if (e.preventDefault) { e.preventDefault(); }\n    else { e.returnValue = false; }\n  }\n  function e_stopPropagation(e) {\n    if (e.stopPropagation) { e.stopPropagation(); }\n    else { e.cancelBubble = true; }\n  }\n  function e_defaultPrevented(e) {\n    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false\n  }\n  function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}\n\n  function e_target(e) {return e.target || e.srcElement}\n  function e_button(e) {\n    var b = e.which;\n    if (b == null) {\n      if (e.button & 1) { b = 1; }\n      else if (e.button & 2) { b = 3; }\n      else if (e.button & 4) { b = 2; }\n    }\n    if (mac && e.ctrlKey && b == 1) { b = 3; }\n    return b\n  }\n\n  // Detect drag-and-drop\n  var dragAndDrop = function() {\n    // There is *some* kind of drag-and-drop support in IE6-8, but I\n    // couldn't get it to work yet.\n    if (ie && ie_version < 9) { return false }\n    var div = elt('div');\n    return \"draggable\" in div || \"dragDrop\" in div\n  }();\n\n  var zwspSupported;\n  function zeroWidthElement(measure) {\n    if (zwspSupported == null) {\n      var test = elt(\"span\", \"\\u200b\");\n      removeChildrenAndAdd(measure, elt(\"span\", [test, document.createTextNode(\"x\")]));\n      if (measure.firstChild.offsetHeight != 0)\n        { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8); }\n    }\n    var node = zwspSupported ? elt(\"span\", \"\\u200b\") :\n      elt(\"span\", \"\\u00a0\", null, \"display: inline-block; width: 1px; margin-right: -1px\");\n    node.setAttribute(\"cm-text\", \"\");\n    return node\n  }\n\n  // Feature-detect IE's crummy client rect reporting for bidi text\n  var badBidiRects;\n  function hasBadBidiRects(measure) {\n    if (badBidiRects != null) { return badBidiRects }\n    var txt = removeChildrenAndAdd(measure, document.createTextNode(\"A\\u062eA\"));\n    var r0 = range(txt, 0, 1).getBoundingClientRect();\n    var r1 = range(txt, 1, 2).getBoundingClientRect();\n    removeChildren(measure);\n    if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)\n    return badBidiRects = (r1.right - r0.right < 3)\n  }\n\n  // See if \"\".split is the broken IE version, if so, provide an\n  // alternative way to split lines.\n  var splitLinesAuto = \"\\n\\nb\".split(/\\n/).length != 3 ? function (string) {\n    var pos = 0, result = [], l = string.length;\n    while (pos <= l) {\n      var nl = string.indexOf(\"\\n\", pos);\n      if (nl == -1) { nl = string.length; }\n      var line = string.slice(pos, string.charAt(nl - 1) == \"\\r\" ? nl - 1 : nl);\n      var rt = line.indexOf(\"\\r\");\n      if (rt != -1) {\n        result.push(line.slice(0, rt));\n        pos += rt + 1;\n      } else {\n        result.push(line);\n        pos = nl + 1;\n      }\n    }\n    return result\n  } : function (string) { return string.split(/\\r\\n?|\\n/); };\n\n  var hasSelection = window.getSelection ? function (te) {\n    try { return te.selectionStart != te.selectionEnd }\n    catch(e) { return false }\n  } : function (te) {\n    var range$$1;\n    try {range$$1 = te.ownerDocument.selection.createRange();}\n    catch(e) {}\n    if (!range$$1 || range$$1.parentElement() != te) { return false }\n    return range$$1.compareEndPoints(\"StartToEnd\", range$$1) != 0\n  };\n\n  var hasCopyEvent = (function () {\n    var e = elt(\"div\");\n    if (\"oncopy\" in e) { return true }\n    e.setAttribute(\"oncopy\", \"return;\");\n    return typeof e.oncopy == \"function\"\n  })();\n\n  var badZoomedRects = null;\n  function hasBadZoomedRects(measure) {\n    if (badZoomedRects != null) { return badZoomedRects }\n    var node = removeChildrenAndAdd(measure, elt(\"span\", \"x\"));\n    var normal = node.getBoundingClientRect();\n    var fromRange = range(node, 0, 1).getBoundingClientRect();\n    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1\n  }\n\n  // Known modes, by name and by MIME\n  var modes = {}, mimeModes = {};\n\n  // Extra arguments are stored as the mode's dependencies, which is\n  // used by (legacy) mechanisms like loadmode.js to automatically\n  // load a mode. (Preferred mechanism is the require/define calls.)\n  function defineMode(name, mode) {\n    if (arguments.length > 2)\n      { mode.dependencies = Array.prototype.slice.call(arguments, 2); }\n    modes[name] = mode;\n  }\n\n  function defineMIME(mime, spec) {\n    mimeModes[mime] = spec;\n  }\n\n  // Given a MIME type, a {name, ...options} config object, or a name\n  // string, return a mode config object.\n  function resolveMode(spec) {\n    if (typeof spec == \"string\" && mimeModes.hasOwnProperty(spec)) {\n      spec = mimeModes[spec];\n    } else if (spec && typeof spec.name == \"string\" && mimeModes.hasOwnProperty(spec.name)) {\n      var found = mimeModes[spec.name];\n      if (typeof found == \"string\") { found = {name: found}; }\n      spec = createObj(found, spec);\n      spec.name = found.name;\n    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+xml$/.test(spec)) {\n      return resolveMode(\"application/xml\")\n    } else if (typeof spec == \"string\" && /^[\\w\\-]+\\/[\\w\\-]+\\+json$/.test(spec)) {\n      return resolveMode(\"application/json\")\n    }\n    if (typeof spec == \"string\") { return {name: spec} }\n    else { return spec || {name: \"null\"} }\n  }\n\n  // Given a mode spec (anything that resolveMode accepts), find and\n  // initialize an actual mode object.\n  function getMode(options, spec) {\n    spec = resolveMode(spec);\n    var mfactory = modes[spec.name];\n    if (!mfactory) { return getMode(options, \"text/plain\") }\n    var modeObj = mfactory(options, spec);\n    if (modeExtensions.hasOwnProperty(spec.name)) {\n      var exts = modeExtensions[spec.name];\n      for (var prop in exts) {\n        if (!exts.hasOwnProperty(prop)) { continue }\n        if (modeObj.hasOwnProperty(prop)) { modeObj[\"_\" + prop] = modeObj[prop]; }\n        modeObj[prop] = exts[prop];\n      }\n    }\n    modeObj.name = spec.name;\n    if (spec.helperType) { modeObj.helperType = spec.helperType; }\n    if (spec.modeProps) { for (var prop$1 in spec.modeProps)\n      { modeObj[prop$1] = spec.modeProps[prop$1]; } }\n\n    return modeObj\n  }\n\n  // This can be used to attach properties to mode objects from\n  // outside the actual mode definition.\n  var modeExtensions = {};\n  function extendMode(mode, properties) {\n    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});\n    copyObj(properties, exts);\n  }\n\n  function copyState(mode, state) {\n    if (state === true) { return state }\n    if (mode.copyState) { return mode.copyState(state) }\n    var nstate = {};\n    for (var n in state) {\n      var val = state[n];\n      if (val instanceof Array) { val = val.concat([]); }\n      nstate[n] = val;\n    }\n    return nstate\n  }\n\n  // Given a mode and a state (for that mode), find the inner mode and\n  // state at the position that the state refers to.\n  function innerMode(mode, state) {\n    var info;\n    while (mode.innerMode) {\n      info = mode.innerMode(state);\n      if (!info || info.mode == mode) { break }\n      state = info.state;\n      mode = info.mode;\n    }\n    return info || {mode: mode, state: state}\n  }\n\n  function startState(mode, a1, a2) {\n    return mode.startState ? mode.startState(a1, a2) : true\n  }\n\n  // STRING STREAM\n\n  // Fed to the mode parsers, provides helper functions to make\n  // parsers more succinct.\n\n  var StringStream = function(string, tabSize, lineOracle) {\n    this.pos = this.start = 0;\n    this.string = string;\n    this.tabSize = tabSize || 8;\n    this.lastColumnPos = this.lastColumnValue = 0;\n    this.lineStart = 0;\n    this.lineOracle = lineOracle;\n  };\n\n  StringStream.prototype.eol = function () {return this.pos >= this.string.length};\n  StringStream.prototype.sol = function () {return this.pos == this.lineStart};\n  StringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};\n  StringStream.prototype.next = function () {\n    if (this.pos < this.string.length)\n      { return this.string.charAt(this.pos++) }\n  };\n  StringStream.prototype.eat = function (match) {\n    var ch = this.string.charAt(this.pos);\n    var ok;\n    if (typeof match == \"string\") { ok = ch == match; }\n    else { ok = ch && (match.test ? match.test(ch) : match(ch)); }\n    if (ok) {++this.pos; return ch}\n  };\n  StringStream.prototype.eatWhile = function (match) {\n    var start = this.pos;\n    while (this.eat(match)){}\n    return this.pos > start\n  };\n  StringStream.prototype.eatSpace = function () {\n      var this$1 = this;\n\n    var start = this.pos;\n    while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) { ++this$1.pos; }\n    return this.pos > start\n  };\n  StringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};\n  StringStream.prototype.skipTo = function (ch) {\n    var found = this.string.indexOf(ch, this.pos);\n    if (found > -1) {this.pos = found; return true}\n  };\n  StringStream.prototype.backUp = function (n) {this.pos -= n;};\n  StringStream.prototype.column = function () {\n    if (this.lastColumnPos < this.start) {\n      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n      this.lastColumnPos = this.start;\n    }\n    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\n  };\n  StringStream.prototype.indentation = function () {\n    return countColumn(this.string, null, this.tabSize) -\n      (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)\n  };\n  StringStream.prototype.match = function (pattern, consume, caseInsensitive) {\n    if (typeof pattern == \"string\") {\n      var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };\n      var substr = this.string.substr(this.pos, pattern.length);\n      if (cased(substr) == cased(pattern)) {\n        if (consume !== false) { this.pos += pattern.length; }\n        return true\n      }\n    } else {\n      var match = this.string.slice(this.pos).match(pattern);\n      if (match && match.index > 0) { return null }\n      if (match && consume !== false) { this.pos += match[0].length; }\n      return match\n    }\n  };\n  StringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};\n  StringStream.prototype.hideFirstChars = function (n, inner) {\n    this.lineStart += n;\n    try { return inner() }\n    finally { this.lineStart -= n; }\n  };\n  StringStream.prototype.lookAhead = function (n) {\n    var oracle = this.lineOracle;\n    return oracle && oracle.lookAhead(n)\n  };\n  StringStream.prototype.baseToken = function () {\n    var oracle = this.lineOracle;\n    return oracle && oracle.baseToken(this.pos)\n  };\n\n  var SavedContext = function(state, lookAhead) {\n    this.state = state;\n    this.lookAhead = lookAhead;\n  };\n\n  var Context = function(doc, state, line, lookAhead) {\n    this.state = state;\n    this.doc = doc;\n    this.line = line;\n    this.maxLookAhead = lookAhead || 0;\n    this.baseTokens = null;\n    this.baseTokenPos = 1;\n  };\n\n  Context.prototype.lookAhead = function (n) {\n    var line = this.doc.getLine(this.line + n);\n    if (line != null && n > this.maxLookAhead) { this.maxLookAhead = n; }\n    return line\n  };\n\n  Context.prototype.baseToken = function (n) {\n      var this$1 = this;\n\n    if (!this.baseTokens) { return null }\n    while (this.baseTokens[this.baseTokenPos] <= n)\n      { this$1.baseTokenPos += 2; }\n    var type = this.baseTokens[this.baseTokenPos + 1];\n    return {type: type && type.replace(/( |^)overlay .*/, \"\"),\n            size: this.baseTokens[this.baseTokenPos] - n}\n  };\n\n  Context.prototype.nextLine = function () {\n    this.line++;\n    if (this.maxLookAhead > 0) { this.maxLookAhead--; }\n  };\n\n  Context.fromSaved = function (doc, saved, line) {\n    if (saved instanceof SavedContext)\n      { return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) }\n    else\n      { return new Context(doc, copyState(doc.mode, saved), line) }\n  };\n\n  Context.prototype.save = function (copy) {\n    var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;\n    return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state\n  };\n\n\n  // Compute a style array (an array starting with a mode generation\n  // -- for invalidation -- followed by pairs of end positions and\n  // style strings), which is used to highlight the tokens on the\n  // line.\n  function highlightLine(cm, line, context, forceToEnd) {\n    // A styles array always starts with a number identifying the\n    // mode/overlays that it is based on (for easy invalidation).\n    var st = [cm.state.modeGen], lineClasses = {};\n    // Compute the base array of styles\n    runMode(cm, line.text, cm.doc.mode, context, function (end, style) { return st.push(end, style); },\n            lineClasses, forceToEnd);\n    var state = context.state;\n\n    // Run overlays, adjust style array.\n    var loop = function ( o ) {\n      context.baseTokens = st;\n      var overlay = cm.state.overlays[o], i = 1, at = 0;\n      context.state = true;\n      runMode(cm, line.text, overlay.mode, context, function (end, style) {\n        var start = i;\n        // Ensure there's a token end at the current position, and that i points at it\n        while (at < end) {\n          var i_end = st[i];\n          if (i_end > end)\n            { st.splice(i, 1, end, st[i+1], i_end); }\n          i += 2;\n          at = Math.min(end, i_end);\n        }\n        if (!style) { return }\n        if (overlay.opaque) {\n          st.splice(start, i - start, end, \"overlay \" + style);\n          i = start + 2;\n        } else {\n          for (; start < i; start += 2) {\n            var cur = st[start+1];\n            st[start+1] = (cur ? cur + \" \" : \"\") + \"overlay \" + style;\n          }\n        }\n      }, lineClasses);\n      context.state = state;\n      context.baseTokens = null;\n      context.baseTokenPos = 1;\n    };\n\n    for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );\n\n    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}\n  }\n\n  function getLineStyles(cm, line, updateFrontier) {\n    if (!line.styles || line.styles[0] != cm.state.modeGen) {\n      var context = getContextBefore(cm, lineNo(line));\n      var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);\n      var result = highlightLine(cm, line, context);\n      if (resetState) { context.state = resetState; }\n      line.stateAfter = context.save(!resetState);\n      line.styles = result.styles;\n      if (result.classes) { line.styleClasses = result.classes; }\n      else if (line.styleClasses) { line.styleClasses = null; }\n      if (updateFrontier === cm.doc.highlightFrontier)\n        { cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier); }\n    }\n    return line.styles\n  }\n\n  function getContextBefore(cm, n, precise) {\n    var doc = cm.doc, display = cm.display;\n    if (!doc.mode.startState) { return new Context(doc, true, n) }\n    var start = findStartLine(cm, n, precise);\n    var saved = start > doc.first && getLine(doc, start - 1).stateAfter;\n    var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);\n\n    doc.iter(start, n, function (line) {\n      processLine(cm, line.text, context);\n      var pos = context.line;\n      line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;\n      context.nextLine();\n    });\n    if (precise) { doc.modeFrontier = context.line; }\n    return context\n  }\n\n  // Lightweight form of highlight -- proceed over this line and\n  // update state, but don't save a style array. Used for lines that\n  // aren't currently visible.\n  function processLine(cm, text, context, startAt) {\n    var mode = cm.doc.mode;\n    var stream = new StringStream(text, cm.options.tabSize, context);\n    stream.start = stream.pos = startAt || 0;\n    if (text == \"\") { callBlankLine(mode, context.state); }\n    while (!stream.eol()) {\n      readToken(mode, stream, context.state);\n      stream.start = stream.pos;\n    }\n  }\n\n  function callBlankLine(mode, state) {\n    if (mode.blankLine) { return mode.blankLine(state) }\n    if (!mode.innerMode) { return }\n    var inner = innerMode(mode, state);\n    if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }\n  }\n\n  function readToken(mode, stream, state, inner) {\n    for (var i = 0; i < 10; i++) {\n      if (inner) { inner[0] = innerMode(mode, state).mode; }\n      var style = mode.token(stream, state);\n      if (stream.pos > stream.start) { return style }\n    }\n    throw new Error(\"Mode \" + mode.name + \" failed to advance stream.\")\n  }\n\n  var Token = function(stream, type, state) {\n    this.start = stream.start; this.end = stream.pos;\n    this.string = stream.current();\n    this.type = type || null;\n    this.state = state;\n  };\n\n  // Utility for getTokenAt and getLineTokens\n  function takeToken(cm, pos, precise, asArray) {\n    var doc = cm.doc, mode = doc.mode, style;\n    pos = clipPos(doc, pos);\n    var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);\n    var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;\n    if (asArray) { tokens = []; }\n    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {\n      stream.start = stream.pos;\n      style = readToken(mode, stream, context.state);\n      if (asArray) { tokens.push(new Token(stream, style, copyState(doc.mode, context.state))); }\n    }\n    return asArray ? tokens : new Token(stream, style, context.state)\n  }\n\n  function extractLineClasses(type, output) {\n    if (type) { for (;;) {\n      var lineClass = type.match(/(?:^|\\s+)line-(background-)?(\\S+)/);\n      if (!lineClass) { break }\n      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);\n      var prop = lineClass[1] ? \"bgClass\" : \"textClass\";\n      if (output[prop] == null)\n        { output[prop] = lineClass[2]; }\n      else if (!(new RegExp(\"(?:^|\\s)\" + lineClass[2] + \"(?:$|\\s)\")).test(output[prop]))\n        { output[prop] += \" \" + lineClass[2]; }\n    } }\n    return type\n  }\n\n  // Run the given mode's parser over a line, calling f for each token.\n  function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {\n    var flattenSpans = mode.flattenSpans;\n    if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }\n    var curStart = 0, curStyle = null;\n    var stream = new StringStream(text, cm.options.tabSize, context), style;\n    var inner = cm.options.addModeClass && [null];\n    if (text == \"\") { extractLineClasses(callBlankLine(mode, context.state), lineClasses); }\n    while (!stream.eol()) {\n      if (stream.pos > cm.options.maxHighlightLength) {\n        flattenSpans = false;\n        if (forceToEnd) { processLine(cm, text, context, stream.pos); }\n        stream.pos = text.length;\n        style = null;\n      } else {\n        style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);\n      }\n      if (inner) {\n        var mName = inner[0].name;\n        if (mName) { style = \"m-\" + (style ? mName + \" \" + style : mName); }\n      }\n      if (!flattenSpans || curStyle != style) {\n        while (curStart < stream.start) {\n          curStart = Math.min(stream.start, curStart + 5000);\n          f(curStart, curStyle);\n        }\n        curStyle = style;\n      }\n      stream.start = stream.pos;\n    }\n    while (curStart < stream.pos) {\n      // Webkit seems to refuse to render text nodes longer than 57444\n      // characters, and returns inaccurate measurements in nodes\n      // starting around 5000 chars.\n      var pos = Math.min(stream.pos, curStart + 5000);\n      f(pos, curStyle);\n      curStart = pos;\n    }\n  }\n\n  // Finds the line to start with when starting a parse. Tries to\n  // find a line with a stateAfter, so that it can start with a\n  // valid state. If that fails, it returns the line with the\n  // smallest indentation, which tends to need the least context to\n  // parse correctly.\n  function findStartLine(cm, n, precise) {\n    var minindent, minline, doc = cm.doc;\n    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);\n    for (var search = n; search > lim; --search) {\n      if (search <= doc.first) { return doc.first }\n      var line = getLine(doc, search - 1), after = line.stateAfter;\n      if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier))\n        { return search }\n      var indented = countColumn(line.text, null, cm.options.tabSize);\n      if (minline == null || minindent > indented) {\n        minline = search - 1;\n        minindent = indented;\n      }\n    }\n    return minline\n  }\n\n  function retreatFrontier(doc, n) {\n    doc.modeFrontier = Math.min(doc.modeFrontier, n);\n    if (doc.highlightFrontier < n - 10) { return }\n    var start = doc.first;\n    for (var line = n - 1; line > start; line--) {\n      var saved = getLine(doc, line).stateAfter;\n      // change is on 3\n      // state on line 1 looked ahead 2 -- so saw 3\n      // test 1 + 2 < 3 should cover this\n      if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {\n        start = line + 1;\n        break\n      }\n    }\n    doc.highlightFrontier = Math.min(doc.highlightFrontier, start);\n  }\n\n  // LINE DATA STRUCTURE\n\n  // Line objects. These hold state related to a line, including\n  // highlighting info (the styles array).\n  var Line = function(text, markedSpans, estimateHeight) {\n    this.text = text;\n    attachMarkedSpans(this, markedSpans);\n    this.height = estimateHeight ? estimateHeight(this) : 1;\n  };\n\n  Line.prototype.lineNo = function () { return lineNo(this) };\n  eventMixin(Line);\n\n  // Change the content (text, markers) of a line. Automatically\n  // invalidates cached information and tries to re-estimate the\n  // line's height.\n  function updateLine(line, text, markedSpans, estimateHeight) {\n    line.text = text;\n    if (line.stateAfter) { line.stateAfter = null; }\n    if (line.styles) { line.styles = null; }\n    if (line.order != null) { line.order = null; }\n    detachMarkedSpans(line);\n    attachMarkedSpans(line, markedSpans);\n    var estHeight = estimateHeight ? estimateHeight(line) : 1;\n    if (estHeight != line.height) { updateLineHeight(line, estHeight); }\n  }\n\n  // Detach a line from the document tree and its markers.\n  function cleanUpLine(line) {\n    line.parent = null;\n    detachMarkedSpans(line);\n  }\n\n  // Convert a style as returned by a mode (either null, or a string\n  // containing one or more styles) to a CSS style. This is cached,\n  // and also looks for line-wide styles.\n  var styleToClassCache = {}, styleToClassCacheWithMode = {};\n  function interpretTokenStyle(style, options) {\n    if (!style || /^\\s*$/.test(style)) { return null }\n    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;\n    return cache[style] ||\n      (cache[style] = style.replace(/\\S+/g, \"cm-$&\"))\n  }\n\n  // Render the DOM representation of the text of a line. Also builds\n  // up a 'line map', which points at the DOM nodes that represent\n  // specific stretches of text, and is used by the measuring code.\n  // The returned object contains the DOM node, this map, and\n  // information about line-wide styles that were set by the mode.\n  function buildLineContent(cm, lineView) {\n    // The padding-right forces the element to have a 'border', which\n    // is needed on Webkit to be able to get line-level bounding\n    // rectangles for it (in measureChar).\n    var content = eltP(\"span\", null, null, webkit ? \"padding-right: .1px\" : null);\n    var builder = {pre: eltP(\"pre\", [content], \"CodeMirror-line\"), content: content,\n                   col: 0, pos: 0, cm: cm,\n                   trailingSpace: false,\n                   splitSpaces: cm.getOption(\"lineWrapping\")};\n    lineView.measure = {};\n\n    // Iterate over the logical lines that make up this visual line.\n    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {\n      var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);\n      builder.pos = 0;\n      builder.addToken = buildToken;\n      // Optionally wire in some hacks into the token-rendering\n      // algorithm, to deal with browser quirks.\n      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))\n        { builder.addToken = buildTokenBadBidi(builder.addToken, order); }\n      builder.map = [];\n      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);\n      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));\n      if (line.styleClasses) {\n        if (line.styleClasses.bgClass)\n          { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || \"\"); }\n        if (line.styleClasses.textClass)\n          { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || \"\"); }\n      }\n\n      // Ensure at least a single node is present, for measuring.\n      if (builder.map.length == 0)\n        { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }\n\n      // Store the map and a cache object for the current logical line\n      if (i == 0) {\n        lineView.measure.map = builder.map;\n        lineView.measure.cache = {};\n      } else {\n  (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)\n        ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});\n      }\n    }\n\n    // See issue #2901\n    if (webkit) {\n      var last = builder.content.lastChild;\n      if (/\\bcm-tab\\b/.test(last.className) || (last.querySelector && last.querySelector(\".cm-tab\")))\n        { builder.content.className = \"cm-tab-wrap-hack\"; }\n    }\n\n    signal(cm, \"renderLine\", cm, lineView.line, builder.pre);\n    if (builder.pre.className)\n      { builder.textClass = joinClasses(builder.pre.className, builder.textClass || \"\"); }\n\n    return builder\n  }\n\n  function defaultSpecialCharPlaceholder(ch) {\n    var token = elt(\"span\", \"\\u2022\", \"cm-invalidchar\");\n    token.title = \"\\\\u\" + ch.charCodeAt(0).toString(16);\n    token.setAttribute(\"aria-label\", token.title);\n    return token\n  }\n\n  // Build up the DOM representation for a single token, and add it to\n  // the line map. Takes care to render special characters separately.\n  function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {\n    if (!text) { return }\n    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;\n    var special = builder.cm.state.specialChars, mustWrap = false;\n    var content;\n    if (!special.test(text)) {\n      builder.col += text.length;\n      content = document.createTextNode(displayText);\n      builder.map.push(builder.pos, builder.pos + text.length, content);\n      if (ie && ie_version < 9) { mustWrap = true; }\n      builder.pos += text.length;\n    } else {\n      content = document.createDocumentFragment();\n      var pos = 0;\n      while (true) {\n        special.lastIndex = pos;\n        var m = special.exec(text);\n        var skipped = m ? m.index - pos : text.length - pos;\n        if (skipped) {\n          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));\n          if (ie && ie_version < 9) { content.appendChild(elt(\"span\", [txt])); }\n          else { content.appendChild(txt); }\n          builder.map.push(builder.pos, builder.pos + skipped, txt);\n          builder.col += skipped;\n          builder.pos += skipped;\n        }\n        if (!m) { break }\n        pos += skipped + 1;\n        var txt$1 = (void 0);\n        if (m[0] == \"\\t\") {\n          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;\n          txt$1 = content.appendChild(elt(\"span\", spaceStr(tabWidth), \"cm-tab\"));\n          txt$1.setAttribute(\"role\", \"presentation\");\n          txt$1.setAttribute(\"cm-text\", \"\\t\");\n          builder.col += tabWidth;\n        } else if (m[0] == \"\\r\" || m[0] == \"\\n\") {\n          txt$1 = content.appendChild(elt(\"span\", m[0] == \"\\r\" ? \"\\u240d\" : \"\\u2424\", \"cm-invalidchar\"));\n          txt$1.setAttribute(\"cm-text\", m[0]);\n          builder.col += 1;\n        } else {\n          txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);\n          txt$1.setAttribute(\"cm-text\", m[0]);\n          if (ie && ie_version < 9) { content.appendChild(elt(\"span\", [txt$1])); }\n          else { content.appendChild(txt$1); }\n          builder.col += 1;\n        }\n        builder.map.push(builder.pos, builder.pos + 1, txt$1);\n        builder.pos++;\n      }\n    }\n    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;\n    if (style || startStyle || endStyle || mustWrap || css) {\n      var fullStyle = style || \"\";\n      if (startStyle) { fullStyle += startStyle; }\n      if (endStyle) { fullStyle += endStyle; }\n      var token = elt(\"span\", [content], fullStyle, css);\n      if (attributes) {\n        for (var attr in attributes) { if (attributes.hasOwnProperty(attr) && attr != \"style\" && attr != \"class\")\n          { token.setAttribute(attr, attributes[attr]); } }\n      }\n      return builder.content.appendChild(token)\n    }\n    builder.content.appendChild(content);\n  }\n\n  // Change some spaces to NBSP to prevent the browser from collapsing\n  // trailing spaces at the end of a line when rendering text (issue #1362).\n  function splitSpaces(text, trailingBefore) {\n    if (text.length > 1 && !/  /.test(text)) { return text }\n    var spaceBefore = trailingBefore, result = \"\";\n    for (var i = 0; i < text.length; i++) {\n      var ch = text.charAt(i);\n      if (ch == \" \" && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))\n        { ch = \"\\u00a0\"; }\n      result += ch;\n      spaceBefore = ch == \" \";\n    }\n    return result\n  }\n\n  // Work around nonsense dimensions being reported for stretches of\n  // right-to-left text.\n  function buildTokenBadBidi(inner, order) {\n    return function (builder, text, style, startStyle, endStyle, css, attributes) {\n      style = style ? style + \" cm-force-border\" : \"cm-force-border\";\n      var start = builder.pos, end = start + text.length;\n      for (;;) {\n        // Find the part that overlaps with the start of this text\n        var part = (void 0);\n        for (var i = 0; i < order.length; i++) {\n          part = order[i];\n          if (part.to > start && part.from <= start) { break }\n        }\n        if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, css, attributes) }\n        inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);\n        startStyle = null;\n        text = text.slice(part.to - start);\n        start = part.to;\n      }\n    }\n  }\n\n  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {\n    var widget = !ignoreWidget && marker.widgetNode;\n    if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }\n    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {\n      if (!widget)\n        { widget = builder.content.appendChild(document.createElement(\"span\")); }\n      widget.setAttribute(\"cm-marker\", marker.id);\n    }\n    if (widget) {\n      builder.cm.display.input.setUneditable(widget);\n      builder.content.appendChild(widget);\n    }\n    builder.pos += size;\n    builder.trailingSpace = false;\n  }\n\n  // Outputs a number of spans to make up a line, taking highlighting\n  // and marked text into account.\n  function insertLineContent(line, builder, styles) {\n    var spans = line.markedSpans, allText = line.text, at = 0;\n    if (!spans) {\n      for (var i$1 = 1; i$1 < styles.length; i$1+=2)\n        { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }\n      return\n    }\n\n    var len = allText.length, pos = 0, i = 1, text = \"\", style, css;\n    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;\n    for (;;) {\n      if (nextChange == pos) { // Update current marker set\n        spanStyle = spanEndStyle = spanStartStyle = css = \"\";\n        attributes = null;\n        collapsed = null; nextChange = Infinity;\n        var foundBookmarks = [], endStyles = (void 0);\n        for (var j = 0; j < spans.length; ++j) {\n          var sp = spans[j], m = sp.marker;\n          if (m.type == \"bookmark\" && sp.from == pos && m.widgetNode) {\n            foundBookmarks.push(m);\n          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {\n            if (sp.to != null && sp.to != pos && nextChange > sp.to) {\n              nextChange = sp.to;\n              spanEndStyle = \"\";\n            }\n            if (m.className) { spanStyle += \" \" + m.className; }\n            if (m.css) { css = (css ? css + \";\" : \"\") + m.css; }\n            if (m.startStyle && sp.from == pos) { spanStartStyle += \" \" + m.startStyle; }\n            if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }\n            // support for the old title property\n            // https://github.com/codemirror/CodeMirror/pull/5673\n            if (m.title) { (attributes || (attributes = {})).title = m.title; }\n            if (m.attributes) {\n              for (var attr in m.attributes)\n                { (attributes || (attributes = {}))[attr] = m.attributes[attr]; }\n            }\n            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))\n              { collapsed = sp; }\n          } else if (sp.from > pos && nextChange > sp.from) {\n            nextChange = sp.from;\n          }\n        }\n        if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)\n          { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += \" \" + endStyles[j$1]; } } }\n\n        if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)\n          { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }\n        if (collapsed && (collapsed.from || 0) == pos) {\n          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,\n                             collapsed.marker, collapsed.from == null);\n          if (collapsed.to == null) { return }\n          if (collapsed.to == pos) { collapsed = false; }\n        }\n      }\n      if (pos >= len) { break }\n\n      var upto = Math.min(len, nextChange);\n      while (true) {\n        if (text) {\n          var end = pos + text.length;\n          if (!collapsed) {\n            var tokenText = end > upto ? text.slice(0, upto - pos) : text;\n            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,\n                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : \"\", css, attributes);\n          }\n          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}\n          pos = end;\n          spanStartStyle = \"\";\n        }\n        text = allText.slice(at, at = styles[i++]);\n        style = interpretTokenStyle(styles[i++], builder.cm.options);\n      }\n    }\n  }\n\n\n  // These objects are used to represent the visible (currently drawn)\n  // part of the document. A LineView may correspond to multiple\n  // logical lines, if those are connected by collapsed ranges.\n  function LineView(doc, line, lineN) {\n    // The starting line\n    this.line = line;\n    // Continuing lines, if any\n    this.rest = visualLineContinued(line);\n    // Number of logical lines in this visual line\n    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;\n    this.node = this.text = null;\n    this.hidden = lineIsHidden(doc, line);\n  }\n\n  // Create a range of LineView objects for the given lines.\n  function buildViewArray(cm, from, to) {\n    var array = [], nextPos;\n    for (var pos = from; pos < to; pos = nextPos) {\n      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);\n      nextPos = pos + view.size;\n      array.push(view);\n    }\n    return array\n  }\n\n  var operationGroup = null;\n\n  function pushOperation(op) {\n    if (operationGroup) {\n      operationGroup.ops.push(op);\n    } else {\n      op.ownsGroup = operationGroup = {\n        ops: [op],\n        delayedCallbacks: []\n      };\n    }\n  }\n\n  function fireCallbacksForOps(group) {\n    // Calls delayed callbacks and cursorActivity handlers until no\n    // new ones appear\n    var callbacks = group.delayedCallbacks, i = 0;\n    do {\n      for (; i < callbacks.length; i++)\n        { callbacks[i].call(null); }\n      for (var j = 0; j < group.ops.length; j++) {\n        var op = group.ops[j];\n        if (op.cursorActivityHandlers)\n          { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)\n            { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }\n      }\n    } while (i < callbacks.length)\n  }\n\n  function finishOperation(op, endCb) {\n    var group = op.ownsGroup;\n    if (!group) { return }\n\n    try { fireCallbacksForOps(group); }\n    finally {\n      operationGroup = null;\n      endCb(group);\n    }\n  }\n\n  var orphanDelayedCallbacks = null;\n\n  // Often, we want to signal events at a point where we are in the\n  // middle of some work, but don't want the handler to start calling\n  // other methods on the editor, which might be in an inconsistent\n  // state or simply not expect any other events to happen.\n  // signalLater looks whether there are any handlers, and schedules\n  // them to be executed when the last operation ends, or, if no\n  // operation is active, when a timeout fires.\n  function signalLater(emitter, type /*, values...*/) {\n    var arr = getHandlers(emitter, type);\n    if (!arr.length) { return }\n    var args = Array.prototype.slice.call(arguments, 2), list;\n    if (operationGroup) {\n      list = operationGroup.delayedCallbacks;\n    } else if (orphanDelayedCallbacks) {\n      list = orphanDelayedCallbacks;\n    } else {\n      list = orphanDelayedCallbacks = [];\n      setTimeout(fireOrphanDelayed, 0);\n    }\n    var loop = function ( i ) {\n      list.push(function () { return arr[i].apply(null, args); });\n    };\n\n    for (var i = 0; i < arr.length; ++i)\n      loop( i );\n  }\n\n  function fireOrphanDelayed() {\n    var delayed = orphanDelayedCallbacks;\n    orphanDelayedCallbacks = null;\n    for (var i = 0; i < delayed.length; ++i) { delayed[i](); }\n  }\n\n  // When an aspect of a line changes, a string is added to\n  // lineView.changes. This updates the relevant part of the line's\n  // DOM structure.\n  function updateLineForChanges(cm, lineView, lineN, dims) {\n    for (var j = 0; j < lineView.changes.length; j++) {\n      var type = lineView.changes[j];\n      if (type == \"text\") { updateLineText(cm, lineView); }\n      else if (type == \"gutter\") { updateLineGutter(cm, lineView, lineN, dims); }\n      else if (type == \"class\") { updateLineClasses(cm, lineView); }\n      else if (type == \"widget\") { updateLineWidgets(cm, lineView, dims); }\n    }\n    lineView.changes = null;\n  }\n\n  // Lines with gutter elements, widgets or a background class need to\n  // be wrapped, and have the extra elements added to the wrapper div\n  function ensureLineWrapped(lineView) {\n    if (lineView.node == lineView.text) {\n      lineView.node = elt(\"div\", null, null, \"position: relative\");\n      if (lineView.text.parentNode)\n        { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }\n      lineView.node.appendChild(lineView.text);\n      if (ie && ie_version < 8) { lineView.node.style.zIndex = 2; }\n    }\n    return lineView.node\n  }\n\n  function updateLineBackground(cm, lineView) {\n    var cls = lineView.bgClass ? lineView.bgClass + \" \" + (lineView.line.bgClass || \"\") : lineView.line.bgClass;\n    if (cls) { cls += \" CodeMirror-linebackground\"; }\n    if (lineView.background) {\n      if (cls) { lineView.background.className = cls; }\n      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }\n    } else if (cls) {\n      var wrap = ensureLineWrapped(lineView);\n      lineView.background = wrap.insertBefore(elt(\"div\", null, cls), wrap.firstChild);\n      cm.display.input.setUneditable(lineView.background);\n    }\n  }\n\n  // Wrapper around buildLineContent which will reuse the structure\n  // in display.externalMeasured when possible.\n  function getLineContent(cm, lineView) {\n    var ext = cm.display.externalMeasured;\n    if (ext && ext.line == lineView.line) {\n      cm.display.externalMeasured = null;\n      lineView.measure = ext.measure;\n      return ext.built\n    }\n    return buildLineContent(cm, lineView)\n  }\n\n  // Redraw the line's text. Interacts with the background and text\n  // classes because the mode may output tokens that influence these\n  // classes.\n  function updateLineText(cm, lineView) {\n    var cls = lineView.text.className;\n    var built = getLineContent(cm, lineView);\n    if (lineView.text == lineView.node) { lineView.node = built.pre; }\n    lineView.text.parentNode.replaceChild(built.pre, lineView.text);\n    lineView.text = built.pre;\n    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {\n      lineView.bgClass = built.bgClass;\n      lineView.textClass = built.textClass;\n      updateLineClasses(cm, lineView);\n    } else if (cls) {\n      lineView.text.className = cls;\n    }\n  }\n\n  function updateLineClasses(cm, lineView) {\n    updateLineBackground(cm, lineView);\n    if (lineView.line.wrapClass)\n      { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }\n    else if (lineView.node != lineView.text)\n      { lineView.node.className = \"\"; }\n    var textClass = lineView.textClass ? lineView.textClass + \" \" + (lineView.line.textClass || \"\") : lineView.line.textClass;\n    lineView.text.className = textClass || \"\";\n  }\n\n  function updateLineGutter(cm, lineView, lineN, dims) {\n    if (lineView.gutter) {\n      lineView.node.removeChild(lineView.gutter);\n      lineView.gutter = null;\n    }\n    if (lineView.gutterBackground) {\n      lineView.node.removeChild(lineView.gutterBackground);\n      lineView.gutterBackground = null;\n    }\n    if (lineView.line.gutterClass) {\n      var wrap = ensureLineWrapped(lineView);\n      lineView.gutterBackground = elt(\"div\", null, \"CodeMirror-gutter-background \" + lineView.line.gutterClass,\n                                      (\"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px; width: \" + (dims.gutterTotalWidth) + \"px\"));\n      cm.display.input.setUneditable(lineView.gutterBackground);\n      wrap.insertBefore(lineView.gutterBackground, lineView.text);\n    }\n    var markers = lineView.line.gutterMarkers;\n    if (cm.options.lineNumbers || markers) {\n      var wrap$1 = ensureLineWrapped(lineView);\n      var gutterWrap = lineView.gutter = elt(\"div\", null, \"CodeMirror-gutter-wrapper\", (\"left: \" + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + \"px\"));\n      cm.display.input.setUneditable(gutterWrap);\n      wrap$1.insertBefore(gutterWrap, lineView.text);\n      if (lineView.line.gutterClass)\n        { gutterWrap.className += \" \" + lineView.line.gutterClass; }\n      if (cm.options.lineNumbers && (!markers || !markers[\"CodeMirror-linenumbers\"]))\n        { lineView.lineNumber = gutterWrap.appendChild(\n          elt(\"div\", lineNumberFor(cm.options, lineN),\n              \"CodeMirror-linenumber CodeMirror-gutter-elt\",\n              (\"left: \" + (dims.gutterLeft[\"CodeMirror-linenumbers\"]) + \"px; width: \" + (cm.display.lineNumInnerWidth) + \"px\"))); }\n      if (markers) { for (var k = 0; k < cm.options.gutters.length; ++k) {\n        var id = cm.options.gutters[k], found = markers.hasOwnProperty(id) && markers[id];\n        if (found)\n          { gutterWrap.appendChild(elt(\"div\", [found], \"CodeMirror-gutter-elt\",\n                                     (\"left: \" + (dims.gutterLeft[id]) + \"px; width: \" + (dims.gutterWidth[id]) + \"px\"))); }\n      } }\n    }\n  }\n\n  function updateLineWidgets(cm, lineView, dims) {\n    if (lineView.alignable) { lineView.alignable = null; }\n    for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {\n      next = node.nextSibling;\n      if (node.className == \"CodeMirror-linewidget\")\n        { lineView.node.removeChild(node); }\n    }\n    insertLineWidgets(cm, lineView, dims);\n  }\n\n  // Build a line's DOM representation from scratch\n  function buildLineElement(cm, lineView, lineN, dims) {\n    var built = getLineContent(cm, lineView);\n    lineView.text = lineView.node = built.pre;\n    if (built.bgClass) { lineView.bgClass = built.bgClass; }\n    if (built.textClass) { lineView.textClass = built.textClass; }\n\n    updateLineClasses(cm, lineView);\n    updateLineGutter(cm, lineView, lineN, dims);\n    insertLineWidgets(cm, lineView, dims);\n    return lineView.node\n  }\n\n  // A lineView may contain multiple logical lines (when merged by\n  // collapsed spans). The widgets for all of them need to be drawn.\n  function insertLineWidgets(cm, lineView, dims) {\n    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);\n    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\n      { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }\n  }\n\n  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {\n    if (!line.widgets) { return }\n    var wrap = ensureLineWrapped(lineView);\n    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {\n      var widget = ws[i], node = elt(\"div\", [widget.node], \"CodeMirror-linewidget\");\n      if (!widget.handleMouseEvents) { node.setAttribute(\"cm-ignore-events\", \"true\"); }\n      positionLineWidget(widget, node, lineView, dims);\n      cm.display.input.setUneditable(node);\n      if (allowAbove && widget.above)\n        { wrap.insertBefore(node, lineView.gutter || lineView.text); }\n      else\n        { wrap.appendChild(node); }\n      signalLater(widget, \"redraw\");\n    }\n  }\n\n  function positionLineWidget(widget, node, lineView, dims) {\n    if (widget.noHScroll) {\n  (lineView.alignable || (lineView.alignable = [])).push(node);\n      var width = dims.wrapperWidth;\n      node.style.left = dims.fixedPos + \"px\";\n      if (!widget.coverGutter) {\n        width -= dims.gutterTotalWidth;\n        node.style.paddingLeft = dims.gutterTotalWidth + \"px\";\n      }\n      node.style.width = width + \"px\";\n    }\n    if (widget.coverGutter) {\n      node.style.zIndex = 5;\n      node.style.position = \"relative\";\n      if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + \"px\"; }\n    }\n  }\n\n  function widgetHeight(widget) {\n    if (widget.height != null) { return widget.height }\n    var cm = widget.doc.cm;\n    if (!cm) { return 0 }\n    if (!contains(document.body, widget.node)) {\n      var parentStyle = \"position: relative;\";\n      if (widget.coverGutter)\n        { parentStyle += \"margin-left: -\" + cm.display.gutters.offsetWidth + \"px;\"; }\n      if (widget.noHScroll)\n        { parentStyle += \"width: \" + cm.display.wrapper.clientWidth + \"px;\"; }\n      removeChildrenAndAdd(cm.display.measure, elt(\"div\", [widget.node], null, parentStyle));\n    }\n    return widget.height = widget.node.parentNode.offsetHeight\n  }\n\n  // Return true when the given mouse event happened in a widget\n  function eventInWidget(display, e) {\n    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {\n      if (!n || (n.nodeType == 1 && n.getAttribute(\"cm-ignore-events\") == \"true\") ||\n          (n.parentNode == display.sizer && n != display.mover))\n        { return true }\n    }\n  }\n\n  // POSITION MEASUREMENT\n\n  function paddingTop(display) {return display.lineSpace.offsetTop}\n  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}\n  function paddingH(display) {\n    if (display.cachedPaddingH) { return display.cachedPaddingH }\n    var e = removeChildrenAndAdd(display.measure, elt(\"pre\", \"x\"));\n    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;\n    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};\n    if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }\n    return data\n  }\n\n  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }\n  function displayWidth(cm) {\n    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth\n  }\n  function displayHeight(cm) {\n    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight\n  }\n\n  // Ensure the lineView.wrapping.heights array is populated. This is\n  // an array of bottom offsets for the lines that make up a drawn\n  // line. When lineWrapping is on, there might be more than one\n  // height.\n  function ensureLineHeights(cm, lineView, rect) {\n    var wrapping = cm.options.lineWrapping;\n    var curWidth = wrapping && displayWidth(cm);\n    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {\n      var heights = lineView.measure.heights = [];\n      if (wrapping) {\n        lineView.measure.width = curWidth;\n        var rects = lineView.text.firstChild.getClientRects();\n        for (var i = 0; i < rects.length - 1; i++) {\n          var cur = rects[i], next = rects[i + 1];\n          if (Math.abs(cur.bottom - next.bottom) > 2)\n            { heights.push((cur.bottom + next.top) / 2 - rect.top); }\n        }\n      }\n      heights.push(rect.bottom - rect.top);\n    }\n  }\n\n  // Find a line map (mapping character offsets to text nodes) and a\n  // measurement cache for the given line number. (A line view might\n  // contain multiple lines when collapsed ranges are present.)\n  function mapFromLineView(lineView, line, lineN) {\n    if (lineView.line == line)\n      { return {map: lineView.measure.map, cache: lineView.measure.cache} }\n    for (var i = 0; i < lineView.rest.length; i++)\n      { if (lineView.rest[i] == line)\n        { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }\n    for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)\n      { if (lineNo(lineView.rest[i$1]) > lineN)\n        { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }\n  }\n\n  // Render a line into the hidden node display.externalMeasured. Used\n  // when measurement is needed for a line that's not in the viewport.\n  function updateExternalMeasurement(cm, line) {\n    line = visualLine(line);\n    var lineN = lineNo(line);\n    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);\n    view.lineN = lineN;\n    var built = view.built = buildLineContent(cm, view);\n    view.text = built.pre;\n    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);\n    return view\n  }\n\n  // Get a {top, bottom, left, right} box (in line-local coordinates)\n  // for a given character.\n  function measureChar(cm, line, ch, bias) {\n    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)\n  }\n\n  // Find a line view that corresponds to the given line number.\n  function findViewForLine(cm, lineN) {\n    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)\n      { return cm.display.view[findViewIndex(cm, lineN)] }\n    var ext = cm.display.externalMeasured;\n    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)\n      { return ext }\n  }\n\n  // Measurement can be split in two steps, the set-up work that\n  // applies to the whole line, and the measurement of the actual\n  // character. Functions like coordsChar, that need to do a lot of\n  // measurements in a row, can thus ensure that the set-up work is\n  // only done once.\n  function prepareMeasureForLine(cm, line) {\n    var lineN = lineNo(line);\n    var view = findViewForLine(cm, lineN);\n    if (view && !view.text) {\n      view = null;\n    } else if (view && view.changes) {\n      updateLineForChanges(cm, view, lineN, getDimensions(cm));\n      cm.curOp.forceUpdate = true;\n    }\n    if (!view)\n      { view = updateExternalMeasurement(cm, line); }\n\n    var info = mapFromLineView(view, line, lineN);\n    return {\n      line: line, view: view, rect: null,\n      map: info.map, cache: info.cache, before: info.before,\n      hasHeights: false\n    }\n  }\n\n  // Given a prepared measurement object, measures the position of an\n  // actual character (or fetches it from the cache).\n  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {\n    if (prepared.before) { ch = -1; }\n    var key = ch + (bias || \"\"), found;\n    if (prepared.cache.hasOwnProperty(key)) {\n      found = prepared.cache[key];\n    } else {\n      if (!prepared.rect)\n        { prepared.rect = prepared.view.text.getBoundingClientRect(); }\n      if (!prepared.hasHeights) {\n        ensureLineHeights(cm, prepared.view, prepared.rect);\n        prepared.hasHeights = true;\n      }\n      found = measureCharInner(cm, prepared, ch, bias);\n      if (!found.bogus) { prepared.cache[key] = found; }\n    }\n    return {left: found.left, right: found.right,\n            top: varHeight ? found.rtop : found.top,\n            bottom: varHeight ? found.rbottom : found.bottom}\n  }\n\n  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};\n\n  function nodeAndOffsetInLineMap(map$$1, ch, bias) {\n    var node, start, end, collapse, mStart, mEnd;\n    // First, search the line map for the text node corresponding to,\n    // or closest to, the target character.\n    for (var i = 0; i < map$$1.length; i += 3) {\n      mStart = map$$1[i];\n      mEnd = map$$1[i + 1];\n      if (ch < mStart) {\n        start = 0; end = 1;\n        collapse = \"left\";\n      } else if (ch < mEnd) {\n        start = ch - mStart;\n        end = start + 1;\n      } else if (i == map$$1.length - 3 || ch == mEnd && map$$1[i + 3] > ch) {\n        end = mEnd - mStart;\n        start = end - 1;\n        if (ch >= mEnd) { collapse = \"right\"; }\n      }\n      if (start != null) {\n        node = map$$1[i + 2];\n        if (mStart == mEnd && bias == (node.insertLeft ? \"left\" : \"right\"))\n          { collapse = bias; }\n        if (bias == \"left\" && start == 0)\n          { while (i && map$$1[i - 2] == map$$1[i - 3] && map$$1[i - 1].insertLeft) {\n            node = map$$1[(i -= 3) + 2];\n            collapse = \"left\";\n          } }\n        if (bias == \"right\" && start == mEnd - mStart)\n          { while (i < map$$1.length - 3 && map$$1[i + 3] == map$$1[i + 4] && !map$$1[i + 5].insertLeft) {\n            node = map$$1[(i += 3) + 2];\n            collapse = \"right\";\n          } }\n        break\n      }\n    }\n    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}\n  }\n\n  function getUsefulRect(rects, bias) {\n    var rect = nullRect;\n    if (bias == \"left\") { for (var i = 0; i < rects.length; i++) {\n      if ((rect = rects[i]).left != rect.right) { break }\n    } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {\n      if ((rect = rects[i$1]).left != rect.right) { break }\n    } }\n    return rect\n  }\n\n  function measureCharInner(cm, prepared, ch, bias) {\n    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);\n    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;\n\n    var rect;\n    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.\n      for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned\n        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }\n        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }\n        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)\n          { rect = node.parentNode.getBoundingClientRect(); }\n        else\n          { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }\n        if (rect.left || rect.right || start == 0) { break }\n        end = start;\n        start = start - 1;\n        collapse = \"right\";\n      }\n      if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }\n    } else { // If it is a widget, simply get the box for the whole widget.\n      if (start > 0) { collapse = bias = \"right\"; }\n      var rects;\n      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)\n        { rect = rects[bias == \"right\" ? rects.length - 1 : 0]; }\n      else\n        { rect = node.getBoundingClientRect(); }\n    }\n    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {\n      var rSpan = node.parentNode.getClientRects()[0];\n      if (rSpan)\n        { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }\n      else\n        { rect = nullRect; }\n    }\n\n    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;\n    var mid = (rtop + rbot) / 2;\n    var heights = prepared.view.measure.heights;\n    var i = 0;\n    for (; i < heights.length - 1; i++)\n      { if (mid < heights[i]) { break } }\n    var top = i ? heights[i - 1] : 0, bot = heights[i];\n    var result = {left: (collapse == \"right\" ? rect.right : rect.left) - prepared.rect.left,\n                  right: (collapse == \"left\" ? rect.left : rect.right) - prepared.rect.left,\n                  top: top, bottom: bot};\n    if (!rect.left && !rect.right) { result.bogus = true; }\n    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }\n\n    return result\n  }\n\n  // Work around problem with bounding client rects on ranges being\n  // returned incorrectly when zoomed on IE10 and below.\n  function maybeUpdateRectForZooming(measure, rect) {\n    if (!window.screen || screen.logicalXDPI == null ||\n        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))\n      { return rect }\n    var scaleX = screen.logicalXDPI / screen.deviceXDPI;\n    var scaleY = screen.logicalYDPI / screen.deviceYDPI;\n    return {left: rect.left * scaleX, right: rect.right * scaleX,\n            top: rect.top * scaleY, bottom: rect.bottom * scaleY}\n  }\n\n  function clearLineMeasurementCacheFor(lineView) {\n    if (lineView.measure) {\n      lineView.measure.cache = {};\n      lineView.measure.heights = null;\n      if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)\n        { lineView.measure.caches[i] = {}; } }\n    }\n  }\n\n  function clearLineMeasurementCache(cm) {\n    cm.display.externalMeasure = null;\n    removeChildren(cm.display.lineMeasure);\n    for (var i = 0; i < cm.display.view.length; i++)\n      { clearLineMeasurementCacheFor(cm.display.view[i]); }\n  }\n\n  function clearCaches(cm) {\n    clearLineMeasurementCache(cm);\n    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;\n    if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }\n    cm.display.lineNumChars = null;\n  }\n\n  function pageScrollX() {\n    // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206\n    // which causes page_Offset and bounding client rects to use\n    // different reference viewports and invalidate our calculations.\n    if (chrome && android) { return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) }\n    return window.pageXOffset || (document.documentElement || document.body).scrollLeft\n  }\n  function pageScrollY() {\n    if (chrome && android) { return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) }\n    return window.pageYOffset || (document.documentElement || document.body).scrollTop\n  }\n\n  function widgetTopHeight(lineObj) {\n    var height = 0;\n    if (lineObj.widgets) { for (var i = 0; i < lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above)\n      { height += widgetHeight(lineObj.widgets[i]); } } }\n    return height\n  }\n\n  // Converts a {top, bottom, left, right} box from line-local\n  // coordinates into another coordinate system. Context may be one of\n  // \"line\", \"div\" (display.lineDiv), \"local\"./null (editor), \"window\",\n  // or \"page\".\n  function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {\n    if (!includeWidgets) {\n      var height = widgetTopHeight(lineObj);\n      rect.top += height; rect.bottom += height;\n    }\n    if (context == \"line\") { return rect }\n    if (!context) { context = \"local\"; }\n    var yOff = heightAtLine(lineObj);\n    if (context == \"local\") { yOff += paddingTop(cm.display); }\n    else { yOff -= cm.display.viewOffset; }\n    if (context == \"page\" || context == \"window\") {\n      var lOff = cm.display.lineSpace.getBoundingClientRect();\n      yOff += lOff.top + (context == \"window\" ? 0 : pageScrollY());\n      var xOff = lOff.left + (context == \"window\" ? 0 : pageScrollX());\n      rect.left += xOff; rect.right += xOff;\n    }\n    rect.top += yOff; rect.bottom += yOff;\n    return rect\n  }\n\n  // Coverts a box from \"div\" coords to another coordinate system.\n  // Context may be \"window\", \"page\", \"div\", or \"local\"./null.\n  function fromCoordSystem(cm, coords, context) {\n    if (context == \"div\") { return coords }\n    var left = coords.left, top = coords.top;\n    // First move into \"page\" coordinate system\n    if (context == \"page\") {\n      left -= pageScrollX();\n      top -= pageScrollY();\n    } else if (context == \"local\" || !context) {\n      var localBox = cm.display.sizer.getBoundingClientRect();\n      left += localBox.left;\n      top += localBox.top;\n    }\n\n    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();\n    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}\n  }\n\n  function charCoords(cm, pos, context, lineObj, bias) {\n    if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }\n    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)\n  }\n\n  // Returns a box for a given cursor position, which may have an\n  // 'other' property containing the position of the secondary cursor\n  // on a bidi boundary.\n  // A cursor Pos(line, char, \"before\") is on the same visual line as `char - 1`\n  // and after `char - 1` in writing order of `char - 1`\n  // A cursor Pos(line, char, \"after\") is on the same visual line as `char`\n  // and before `char` in writing order of `char`\n  // Examples (upper-case letters are RTL, lower-case are LTR):\n  //     Pos(0, 1, ...)\n  //     before   after\n  // ab     a|b     a|b\n  // aB     a|B     aB|\n  // Ab     |Ab     A|b\n  // AB     B|A     B|A\n  // Every position after the last character on a line is considered to stick\n  // to the last character on the line.\n  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {\n    lineObj = lineObj || getLine(cm.doc, pos.line);\n    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }\n    function get(ch, right) {\n      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? \"right\" : \"left\", varHeight);\n      if (right) { m.left = m.right; } else { m.right = m.left; }\n      return intoCoordSystem(cm, lineObj, m, context)\n    }\n    var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;\n    if (ch >= lineObj.text.length) {\n      ch = lineObj.text.length;\n      sticky = \"before\";\n    } else if (ch <= 0) {\n      ch = 0;\n      sticky = \"after\";\n    }\n    if (!order) { return get(sticky == \"before\" ? ch - 1 : ch, sticky == \"before\") }\n\n    function getBidi(ch, partPos, invert) {\n      var part = order[partPos], right = part.level == 1;\n      return get(invert ? ch - 1 : ch, right != invert)\n    }\n    var partPos = getBidiPartAt(order, ch, sticky);\n    var other = bidiOther;\n    var val = getBidi(ch, partPos, sticky == \"before\");\n    if (other != null) { val.other = getBidi(ch, other, sticky != \"before\"); }\n    return val\n  }\n\n  // Used to cheaply estimate the coordinates for a position. Used for\n  // intermediate scroll updates.\n  function estimateCoords(cm, pos) {\n    var left = 0;\n    pos = clipPos(cm.doc, pos);\n    if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }\n    var lineObj = getLine(cm.doc, pos.line);\n    var top = heightAtLine(lineObj) + paddingTop(cm.display);\n    return {left: left, right: left, top: top, bottom: top + lineObj.height}\n  }\n\n  // Positions returned by coordsChar contain some extra information.\n  // xRel is the relative x position of the input coordinates compared\n  // to the found position (so xRel > 0 means the coordinates are to\n  // the right of the character position, for example). When outside\n  // is true, that means the coordinates lie outside the line's\n  // vertical range.\n  function PosWithInfo(line, ch, sticky, outside, xRel) {\n    var pos = Pos(line, ch, sticky);\n    pos.xRel = xRel;\n    if (outside) { pos.outside = true; }\n    return pos\n  }\n\n  // Compute the character position closest to the given coordinates.\n  // Input must be lineSpace-local (\"div\" coordinate system).\n  function coordsChar(cm, x, y) {\n    var doc = cm.doc;\n    y += cm.display.viewOffset;\n    if (y < 0) { return PosWithInfo(doc.first, 0, null, true, -1) }\n    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;\n    if (lineN > last)\n      { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, true, 1) }\n    if (x < 0) { x = 0; }\n\n    var lineObj = getLine(doc, lineN);\n    for (;;) {\n      var found = coordsCharInner(cm, lineObj, lineN, x, y);\n      var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 ? 1 : 0));\n      if (!collapsed) { return found }\n      var rangeEnd = collapsed.find(1);\n      if (rangeEnd.line == lineN) { return rangeEnd }\n      lineObj = getLine(doc, lineN = rangeEnd.line);\n    }\n  }\n\n  function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {\n    y -= widgetTopHeight(lineObj);\n    var end = lineObj.text.length;\n    var begin = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y; }, end, 0);\n    end = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch).top > y; }, begin, end);\n    return {begin: begin, end: end}\n  }\n\n  function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {\n    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }\n    var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), \"line\").top;\n    return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)\n  }\n\n  // Returns true if the given side of a box is after the given\n  // coordinates, in top-to-bottom, left-to-right order.\n  function boxIsAfter(box, x, y, left) {\n    return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x\n  }\n\n  function coordsCharInner(cm, lineObj, lineNo$$1, x, y) {\n    // Move y into line-local coordinate space\n    y -= heightAtLine(lineObj);\n    var preparedMeasure = prepareMeasureForLine(cm, lineObj);\n    // When directly calling `measureCharPrepared`, we have to adjust\n    // for the widgets at this line.\n    var widgetHeight$$1 = widgetTopHeight(lineObj);\n    var begin = 0, end = lineObj.text.length, ltr = true;\n\n    var order = getOrder(lineObj, cm.doc.direction);\n    // If the line isn't plain left-to-right text, first figure out\n    // which bidi section the coordinates fall into.\n    if (order) {\n      var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)\n                   (cm, lineObj, lineNo$$1, preparedMeasure, order, x, y);\n      ltr = part.level != 1;\n      // The awkward -1 offsets are needed because findFirst (called\n      // on these below) will treat its first bound as inclusive,\n      // second as exclusive, but we want to actually address the\n      // characters in the part's range\n      begin = ltr ? part.from : part.to - 1;\n      end = ltr ? part.to : part.from - 1;\n    }\n\n    // A binary search to find the first character whose bounding box\n    // starts after the coordinates. If we run across any whose box wrap\n    // the coordinates, store that.\n    var chAround = null, boxAround = null;\n    var ch = findFirst(function (ch) {\n      var box = measureCharPrepared(cm, preparedMeasure, ch);\n      box.top += widgetHeight$$1; box.bottom += widgetHeight$$1;\n      if (!boxIsAfter(box, x, y, false)) { return false }\n      if (box.top <= y && box.left <= x) {\n        chAround = ch;\n        boxAround = box;\n      }\n      return true\n    }, begin, end);\n\n    var baseX, sticky, outside = false;\n    // If a box around the coordinates was found, use that\n    if (boxAround) {\n      // Distinguish coordinates nearer to the left or right side of the box\n      var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;\n      ch = chAround + (atStart ? 0 : 1);\n      sticky = atStart ? \"after\" : \"before\";\n      baseX = atLeft ? boxAround.left : boxAround.right;\n    } else {\n      // (Adjust for extended bound, if necessary.)\n      if (!ltr && (ch == end || ch == begin)) { ch++; }\n      // To determine which side to associate with, get the box to the\n      // left of the character and compare it's vertical position to the\n      // coordinates\n      sticky = ch == 0 ? \"after\" : ch == lineObj.text.length ? \"before\" :\n        (measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight$$1 <= y) == ltr ?\n        \"after\" : \"before\";\n      // Now get accurate coordinates for this place, in order to get a\n      // base X position\n      var coords = cursorCoords(cm, Pos(lineNo$$1, ch, sticky), \"line\", lineObj, preparedMeasure);\n      baseX = coords.left;\n      outside = y < coords.top || y >= coords.bottom;\n    }\n\n    ch = skipExtendingChars(lineObj.text, ch, 1);\n    return PosWithInfo(lineNo$$1, ch, sticky, outside, x - baseX)\n  }\n\n  function coordsBidiPart(cm, lineObj, lineNo$$1, preparedMeasure, order, x, y) {\n    // Bidi parts are sorted left-to-right, and in a non-line-wrapping\n    // situation, we can take this ordering to correspond to the visual\n    // ordering. This finds the first part whose end is after the given\n    // coordinates.\n    var index = findFirst(function (i) {\n      var part = order[i], ltr = part.level != 1;\n      return boxIsAfter(cursorCoords(cm, Pos(lineNo$$1, ltr ? part.to : part.from, ltr ? \"before\" : \"after\"),\n                                     \"line\", lineObj, preparedMeasure), x, y, true)\n    }, 0, order.length - 1);\n    var part = order[index];\n    // If this isn't the first part, the part's start is also after\n    // the coordinates, and the coordinates aren't on the same line as\n    // that start, move one part back.\n    if (index > 0) {\n      var ltr = part.level != 1;\n      var start = cursorCoords(cm, Pos(lineNo$$1, ltr ? part.from : part.to, ltr ? \"after\" : \"before\"),\n                               \"line\", lineObj, preparedMeasure);\n      if (boxIsAfter(start, x, y, true) && start.top > y)\n        { part = order[index - 1]; }\n    }\n    return part\n  }\n\n  function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {\n    // In a wrapped line, rtl text on wrapping boundaries can do things\n    // that don't correspond to the ordering in our `order` array at\n    // all, so a binary search doesn't work, and we want to return a\n    // part that only spans one line so that the binary search in\n    // coordsCharInner is safe. As such, we first find the extent of the\n    // wrapped line, and then do a flat search in which we discard any\n    // spans that aren't on the line.\n    var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);\n    var begin = ref.begin;\n    var end = ref.end;\n    if (/\\s/.test(lineObj.text.charAt(end - 1))) { end--; }\n    var part = null, closestDist = null;\n    for (var i = 0; i < order.length; i++) {\n      var p = order[i];\n      if (p.from >= end || p.to <= begin) { continue }\n      var ltr = p.level != 1;\n      var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;\n      // Weigh against spans ending before this, so that they are only\n      // picked if nothing ends after\n      var dist = endX < x ? x - endX + 1e9 : endX - x;\n      if (!part || closestDist > dist) {\n        part = p;\n        closestDist = dist;\n      }\n    }\n    if (!part) { part = order[order.length - 1]; }\n    // Clip the part to the wrapped line.\n    if (part.from < begin) { part = {from: begin, to: part.to, level: part.level}; }\n    if (part.to > end) { part = {from: part.from, to: end, level: part.level}; }\n    return part\n  }\n\n  var measureText;\n  // Compute the default text height.\n  function textHeight(display) {\n    if (display.cachedTextHeight != null) { return display.cachedTextHeight }\n    if (measureText == null) {\n      measureText = elt(\"pre\");\n      // Measure a bunch of lines, for browsers that compute\n      // fractional heights.\n      for (var i = 0; i < 49; ++i) {\n        measureText.appendChild(document.createTextNode(\"x\"));\n        measureText.appendChild(elt(\"br\"));\n      }\n      measureText.appendChild(document.createTextNode(\"x\"));\n    }\n    removeChildrenAndAdd(display.measure, measureText);\n    var height = measureText.offsetHeight / 50;\n    if (height > 3) { display.cachedTextHeight = height; }\n    removeChildren(display.measure);\n    return height || 1\n  }\n\n  // Compute the default character width.\n  function charWidth(display) {\n    if (display.cachedCharWidth != null) { return display.cachedCharWidth }\n    var anchor = elt(\"span\", \"xxxxxxxxxx\");\n    var pre = elt(\"pre\", [anchor]);\n    removeChildrenAndAdd(display.measure, pre);\n    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;\n    if (width > 2) { display.cachedCharWidth = width; }\n    return width || 10\n  }\n\n  // Do a bulk-read of the DOM positions and sizes needed to draw the\n  // view, so that we don't interleave reading and writing to the DOM.\n  function getDimensions(cm) {\n    var d = cm.display, left = {}, width = {};\n    var gutterLeft = d.gutters.clientLeft;\n    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {\n      left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft;\n      width[cm.options.gutters[i]] = n.clientWidth;\n    }\n    return {fixedPos: compensateForHScroll(d),\n            gutterTotalWidth: d.gutters.offsetWidth,\n            gutterLeft: left,\n            gutterWidth: width,\n            wrapperWidth: d.wrapper.clientWidth}\n  }\n\n  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,\n  // but using getBoundingClientRect to get a sub-pixel-accurate\n  // result.\n  function compensateForHScroll(display) {\n    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left\n  }\n\n  // Returns a function that estimates the height of a line, to use as\n  // first approximation until the line becomes visible (and is thus\n  // properly measurable).\n  function estimateHeight(cm) {\n    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;\n    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);\n    return function (line) {\n      if (lineIsHidden(cm.doc, line)) { return 0 }\n\n      var widgetsHeight = 0;\n      if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {\n        if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }\n      } }\n\n      if (wrapping)\n        { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }\n      else\n        { return widgetsHeight + th }\n    }\n  }\n\n  function estimateLineHeights(cm) {\n    var doc = cm.doc, est = estimateHeight(cm);\n    doc.iter(function (line) {\n      var estHeight = est(line);\n      if (estHeight != line.height) { updateLineHeight(line, estHeight); }\n    });\n  }\n\n  // Given a mouse event, find the corresponding position. If liberal\n  // is false, it checks whether a gutter or scrollbar was clicked,\n  // and returns null if it was. forRect is used by rectangular\n  // selections, and tries to estimate a character position even for\n  // coordinates beyond the right of the text.\n  function posFromMouse(cm, e, liberal, forRect) {\n    var display = cm.display;\n    if (!liberal && e_target(e).getAttribute(\"cm-not-content\") == \"true\") { return null }\n\n    var x, y, space = display.lineSpace.getBoundingClientRect();\n    // Fails unpredictably on IE[67] when mouse is dragged around quickly.\n    try { x = e.clientX - space.left; y = e.clientY - space.top; }\n    catch (e) { return null }\n    var coords = coordsChar(cm, x, y), line;\n    if (forRect && coords.xRel == 1 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {\n      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;\n      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));\n    }\n    return coords\n  }\n\n  // Find the view element corresponding to a given line. Return null\n  // when the line isn't visible.\n  function findViewIndex(cm, n) {\n    if (n >= cm.display.viewTo) { return null }\n    n -= cm.display.viewFrom;\n    if (n < 0) { return null }\n    var view = cm.display.view;\n    for (var i = 0; i < view.length; i++) {\n      n -= view[i].size;\n      if (n < 0) { return i }\n    }\n  }\n\n  function updateSelection(cm) {\n    cm.display.input.showSelection(cm.display.input.prepareSelection());\n  }\n\n  function prepareSelection(cm, primary) {\n    if ( primary === void 0 ) primary = true;\n\n    var doc = cm.doc, result = {};\n    var curFragment = result.cursors = document.createDocumentFragment();\n    var selFragment = result.selection = document.createDocumentFragment();\n\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\n      if (!primary && i == doc.sel.primIndex) { continue }\n      var range$$1 = doc.sel.ranges[i];\n      if (range$$1.from().line >= cm.display.viewTo || range$$1.to().line < cm.display.viewFrom) { continue }\n      var collapsed = range$$1.empty();\n      if (collapsed || cm.options.showCursorWhenSelecting)\n        { drawSelectionCursor(cm, range$$1.head, curFragment); }\n      if (!collapsed)\n        { drawSelectionRange(cm, range$$1, selFragment); }\n    }\n    return result\n  }\n\n  // Draws a cursor for the given range\n  function drawSelectionCursor(cm, head, output) {\n    var pos = cursorCoords(cm, head, \"div\", null, null, !cm.options.singleCursorHeightPerLine);\n\n    var cursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor\"));\n    cursor.style.left = pos.left + \"px\";\n    cursor.style.top = pos.top + \"px\";\n    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + \"px\";\n\n    if (pos.other) {\n      // Secondary cursor, shown when on a 'jump' in bi-directional text\n      var otherCursor = output.appendChild(elt(\"div\", \"\\u00a0\", \"CodeMirror-cursor CodeMirror-secondarycursor\"));\n      otherCursor.style.display = \"\";\n      otherCursor.style.left = pos.other.left + \"px\";\n      otherCursor.style.top = pos.other.top + \"px\";\n      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + \"px\";\n    }\n  }\n\n  function cmpCoords(a, b) { return a.top - b.top || a.left - b.left }\n\n  // Draws the given range as a highlighted selection\n  function drawSelectionRange(cm, range$$1, output) {\n    var display = cm.display, doc = cm.doc;\n    var fragment = document.createDocumentFragment();\n    var padding = paddingH(cm.display), leftSide = padding.left;\n    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;\n    var docLTR = doc.direction == \"ltr\";\n\n    function add(left, top, width, bottom) {\n      if (top < 0) { top = 0; }\n      top = Math.round(top);\n      bottom = Math.round(bottom);\n      fragment.appendChild(elt(\"div\", null, \"CodeMirror-selected\", (\"position: absolute; left: \" + left + \"px;\\n                             top: \" + top + \"px; width: \" + (width == null ? rightSide - left : width) + \"px;\\n                             height: \" + (bottom - top) + \"px\")));\n    }\n\n    function drawForLine(line, fromArg, toArg) {\n      var lineObj = getLine(doc, line);\n      var lineLen = lineObj.text.length;\n      var start, end;\n      function coords(ch, bias) {\n        return charCoords(cm, Pos(line, ch), \"div\", lineObj, bias)\n      }\n\n      function wrapX(pos, dir, side) {\n        var extent = wrappedLineExtentChar(cm, lineObj, null, pos);\n        var prop = (dir == \"ltr\") == (side == \"after\") ? \"left\" : \"right\";\n        var ch = side == \"after\" ? extent.begin : extent.end - (/\\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);\n        return coords(ch, prop)[prop]\n      }\n\n      var order = getOrder(lineObj, doc.direction);\n      iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {\n        var ltr = dir == \"ltr\";\n        var fromPos = coords(from, ltr ? \"left\" : \"right\");\n        var toPos = coords(to - 1, ltr ? \"right\" : \"left\");\n\n        var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;\n        var first = i == 0, last = !order || i == order.length - 1;\n        if (toPos.top - fromPos.top <= 3) { // Single line\n          var openLeft = (docLTR ? openStart : openEnd) && first;\n          var openRight = (docLTR ? openEnd : openStart) && last;\n          var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;\n          var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;\n          add(left, fromPos.top, right - left, fromPos.bottom);\n        } else { // Multiple lines\n          var topLeft, topRight, botLeft, botRight;\n          if (ltr) {\n            topLeft = docLTR && openStart && first ? leftSide : fromPos.left;\n            topRight = docLTR ? rightSide : wrapX(from, dir, \"before\");\n            botLeft = docLTR ? leftSide : wrapX(to, dir, \"after\");\n            botRight = docLTR && openEnd && last ? rightSide : toPos.right;\n          } else {\n            topLeft = !docLTR ? leftSide : wrapX(from, dir, \"before\");\n            topRight = !docLTR && openStart && first ? rightSide : fromPos.right;\n            botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;\n            botRight = !docLTR ? rightSide : wrapX(to, dir, \"after\");\n          }\n          add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);\n          if (fromPos.bottom < toPos.top) { add(leftSide, fromPos.bottom, null, toPos.top); }\n          add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);\n        }\n\n        if (!start || cmpCoords(fromPos, start) < 0) { start = fromPos; }\n        if (cmpCoords(toPos, start) < 0) { start = toPos; }\n        if (!end || cmpCoords(fromPos, end) < 0) { end = fromPos; }\n        if (cmpCoords(toPos, end) < 0) { end = toPos; }\n      });\n      return {start: start, end: end}\n    }\n\n    var sFrom = range$$1.from(), sTo = range$$1.to();\n    if (sFrom.line == sTo.line) {\n      drawForLine(sFrom.line, sFrom.ch, sTo.ch);\n    } else {\n      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);\n      var singleVLine = visualLine(fromLine) == visualLine(toLine);\n      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;\n      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;\n      if (singleVLine) {\n        if (leftEnd.top < rightStart.top - 2) {\n          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);\n          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);\n        } else {\n          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);\n        }\n      }\n      if (leftEnd.bottom < rightStart.top)\n        { add(leftSide, leftEnd.bottom, null, rightStart.top); }\n    }\n\n    output.appendChild(fragment);\n  }\n\n  // Cursor-blinking\n  function restartBlink(cm) {\n    if (!cm.state.focused) { return }\n    var display = cm.display;\n    clearInterval(display.blinker);\n    var on = true;\n    display.cursorDiv.style.visibility = \"\";\n    if (cm.options.cursorBlinkRate > 0)\n      { display.blinker = setInterval(function () { return display.cursorDiv.style.visibility = (on = !on) ? \"\" : \"hidden\"; },\n        cm.options.cursorBlinkRate); }\n    else if (cm.options.cursorBlinkRate < 0)\n      { display.cursorDiv.style.visibility = \"hidden\"; }\n  }\n\n  function ensureFocus(cm) {\n    if (!cm.state.focused) { cm.display.input.focus(); onFocus(cm); }\n  }\n\n  function delayBlurEvent(cm) {\n    cm.state.delayingBlurEvent = true;\n    setTimeout(function () { if (cm.state.delayingBlurEvent) {\n      cm.state.delayingBlurEvent = false;\n      onBlur(cm);\n    } }, 100);\n  }\n\n  function onFocus(cm, e) {\n    if (cm.state.delayingBlurEvent) { cm.state.delayingBlurEvent = false; }\n\n    if (cm.options.readOnly == \"nocursor\") { return }\n    if (!cm.state.focused) {\n      signal(cm, \"focus\", cm, e);\n      cm.state.focused = true;\n      addClass(cm.display.wrapper, \"CodeMirror-focused\");\n      // This test prevents this from firing when a context\n      // menu is closed (since the input reset would kill the\n      // select-all detection hack)\n      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {\n        cm.display.input.reset();\n        if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730\n      }\n      cm.display.input.receivedFocus();\n    }\n    restartBlink(cm);\n  }\n  function onBlur(cm, e) {\n    if (cm.state.delayingBlurEvent) { return }\n\n    if (cm.state.focused) {\n      signal(cm, \"blur\", cm, e);\n      cm.state.focused = false;\n      rmClass(cm.display.wrapper, \"CodeMirror-focused\");\n    }\n    clearInterval(cm.display.blinker);\n    setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);\n  }\n\n  // Read the actual heights of the rendered lines, and update their\n  // stored heights to match.\n  function updateHeightsInViewport(cm) {\n    var display = cm.display;\n    var prevBottom = display.lineDiv.offsetTop;\n    for (var i = 0; i < display.view.length; i++) {\n      var cur = display.view[i], wrapping = cm.options.lineWrapping;\n      var height = (void 0), width = 0;\n      if (cur.hidden) { continue }\n      if (ie && ie_version < 8) {\n        var bot = cur.node.offsetTop + cur.node.offsetHeight;\n        height = bot - prevBottom;\n        prevBottom = bot;\n      } else {\n        var box = cur.node.getBoundingClientRect();\n        height = box.bottom - box.top;\n        // Check that lines don't extend past the right of the current\n        // editor width\n        if (!wrapping && cur.text.firstChild)\n          { width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1; }\n      }\n      var diff = cur.line.height - height;\n      if (diff > .005 || diff < -.005) {\n        updateLineHeight(cur.line, height);\n        updateWidgetHeight(cur.line);\n        if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)\n          { updateWidgetHeight(cur.rest[j]); } }\n      }\n      if (width > cm.display.sizerWidth) {\n        var chWidth = Math.ceil(width / charWidth(cm.display));\n        if (chWidth > cm.display.maxLineLength) {\n          cm.display.maxLineLength = chWidth;\n          cm.display.maxLine = cur.line;\n          cm.display.maxLineChanged = true;\n        }\n      }\n    }\n  }\n\n  // Read and store the height of line widgets associated with the\n  // given line.\n  function updateWidgetHeight(line) {\n    if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i) {\n      var w = line.widgets[i], parent = w.node.parentNode;\n      if (parent) { w.height = parent.offsetHeight; }\n    } }\n  }\n\n  // Compute the lines that are visible in a given viewport (defaults\n  // the the current scroll position). viewport may contain top,\n  // height, and ensure (see op.scrollToPos) properties.\n  function visibleLines(display, doc, viewport) {\n    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;\n    top = Math.floor(top - paddingTop(display));\n    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;\n\n    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);\n    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and\n    // forces those lines into the viewport (if possible).\n    if (viewport && viewport.ensure) {\n      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;\n      if (ensureFrom < from) {\n        from = ensureFrom;\n        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);\n      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {\n        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);\n        to = ensureTo;\n      }\n    }\n    return {from: from, to: Math.max(to, from + 1)}\n  }\n\n  // Re-align line numbers and gutter marks to compensate for\n  // horizontal scrolling.\n  function alignHorizontally(cm) {\n    var display = cm.display, view = display.view;\n    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }\n    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;\n    var gutterW = display.gutters.offsetWidth, left = comp + \"px\";\n    for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {\n      if (cm.options.fixedGutter) {\n        if (view[i].gutter)\n          { view[i].gutter.style.left = left; }\n        if (view[i].gutterBackground)\n          { view[i].gutterBackground.style.left = left; }\n      }\n      var align = view[i].alignable;\n      if (align) { for (var j = 0; j < align.length; j++)\n        { align[j].style.left = left; } }\n    } }\n    if (cm.options.fixedGutter)\n      { display.gutters.style.left = (comp + gutterW) + \"px\"; }\n  }\n\n  // Used to ensure that the line number gutter is still the right\n  // size for the current document size. Returns true when an update\n  // is needed.\n  function maybeUpdateLineNumberWidth(cm) {\n    if (!cm.options.lineNumbers) { return false }\n    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;\n    if (last.length != display.lineNumChars) {\n      var test = display.measure.appendChild(elt(\"div\", [elt(\"div\", last)],\n                                                 \"CodeMirror-linenumber CodeMirror-gutter-elt\"));\n      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;\n      display.lineGutter.style.width = \"\";\n      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;\n      display.lineNumWidth = display.lineNumInnerWidth + padding;\n      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;\n      display.lineGutter.style.width = display.lineNumWidth + \"px\";\n      updateGutterSpace(cm);\n      return true\n    }\n    return false\n  }\n\n  // SCROLLING THINGS INTO VIEW\n\n  // If an editor sits on the top or bottom of the window, partially\n  // scrolled out of view, this ensures that the cursor is visible.\n  function maybeScrollWindow(cm, rect) {\n    if (signalDOMEvent(cm, \"scrollCursorIntoView\")) { return }\n\n    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;\n    if (rect.top + box.top < 0) { doScroll = true; }\n    else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false; }\n    if (doScroll != null && !phantom) {\n      var scrollNode = elt(\"div\", \"\\u200b\", null, (\"position: absolute;\\n                         top: \" + (rect.top - display.viewOffset - paddingTop(cm.display)) + \"px;\\n                         height: \" + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + \"px;\\n                         left: \" + (rect.left) + \"px; width: \" + (Math.max(2, rect.right - rect.left)) + \"px;\"));\n      cm.display.lineSpace.appendChild(scrollNode);\n      scrollNode.scrollIntoView(doScroll);\n      cm.display.lineSpace.removeChild(scrollNode);\n    }\n  }\n\n  // Scroll a given position into view (immediately), verifying that\n  // it actually became visible (as line heights are accurately\n  // measured, the position of something may 'drift' during drawing).\n  function scrollPosIntoView(cm, pos, end, margin) {\n    if (margin == null) { margin = 0; }\n    var rect;\n    if (!cm.options.lineWrapping && pos == end) {\n      // Set pos and end to the cursor positions around the character pos sticks to\n      // If pos.sticky == \"before\", that is around pos.ch - 1, otherwise around pos.ch\n      // If pos == Pos(_, 0, \"before\"), pos and end are unchanged\n      pos = pos.ch ? Pos(pos.line, pos.sticky == \"before\" ? pos.ch - 1 : pos.ch, \"after\") : pos;\n      end = pos.sticky == \"before\" ? Pos(pos.line, pos.ch + 1, \"before\") : pos;\n    }\n    for (var limit = 0; limit < 5; limit++) {\n      var changed = false;\n      var coords = cursorCoords(cm, pos);\n      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);\n      rect = {left: Math.min(coords.left, endCoords.left),\n              top: Math.min(coords.top, endCoords.top) - margin,\n              right: Math.max(coords.left, endCoords.left),\n              bottom: Math.max(coords.bottom, endCoords.bottom) + margin};\n      var scrollPos = calculateScrollPos(cm, rect);\n      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;\n      if (scrollPos.scrollTop != null) {\n        updateScrollTop(cm, scrollPos.scrollTop);\n        if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true; }\n      }\n      if (scrollPos.scrollLeft != null) {\n        setScrollLeft(cm, scrollPos.scrollLeft);\n        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true; }\n      }\n      if (!changed) { break }\n    }\n    return rect\n  }\n\n  // Scroll a given set of coordinates into view (immediately).\n  function scrollIntoView(cm, rect) {\n    var scrollPos = calculateScrollPos(cm, rect);\n    if (scrollPos.scrollTop != null) { updateScrollTop(cm, scrollPos.scrollTop); }\n    if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }\n  }\n\n  // Calculate a new scroll position needed to scroll the given\n  // rectangle into view. Returns an object with scrollTop and\n  // scrollLeft properties. When these are undefined, the\n  // vertical/horizontal position does not need to be adjusted.\n  function calculateScrollPos(cm, rect) {\n    var display = cm.display, snapMargin = textHeight(cm.display);\n    if (rect.top < 0) { rect.top = 0; }\n    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;\n    var screen = displayHeight(cm), result = {};\n    if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen; }\n    var docBottom = cm.doc.height + paddingVert(display);\n    var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;\n    if (rect.top < screentop) {\n      result.scrollTop = atTop ? 0 : rect.top;\n    } else if (rect.bottom > screentop + screen) {\n      var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);\n      if (newTop != screentop) { result.scrollTop = newTop; }\n    }\n\n    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft;\n    var screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0);\n    var tooWide = rect.right - rect.left > screenw;\n    if (tooWide) { rect.right = rect.left + screenw; }\n    if (rect.left < 10)\n      { result.scrollLeft = 0; }\n    else if (rect.left < screenleft)\n      { result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10)); }\n    else if (rect.right > screenw + screenleft - 3)\n      { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }\n    return result\n  }\n\n  // Store a relative adjustment to the scroll position in the current\n  // operation (to be applied when the operation finishes).\n  function addToScrollTop(cm, top) {\n    if (top == null) { return }\n    resolveScrollToPos(cm);\n    cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;\n  }\n\n  // Make sure that at the end of the operation the current cursor is\n  // shown.\n  function ensureCursorVisible(cm) {\n    resolveScrollToPos(cm);\n    var cur = cm.getCursor();\n    cm.curOp.scrollToPos = {from: cur, to: cur, margin: cm.options.cursorScrollMargin};\n  }\n\n  function scrollToCoords(cm, x, y) {\n    if (x != null || y != null) { resolveScrollToPos(cm); }\n    if (x != null) { cm.curOp.scrollLeft = x; }\n    if (y != null) { cm.curOp.scrollTop = y; }\n  }\n\n  function scrollToRange(cm, range$$1) {\n    resolveScrollToPos(cm);\n    cm.curOp.scrollToPos = range$$1;\n  }\n\n  // When an operation has its scrollToPos property set, and another\n  // scroll action is applied before the end of the operation, this\n  // 'simulates' scrolling that position into view in a cheap way, so\n  // that the effect of intermediate scroll commands is not ignored.\n  function resolveScrollToPos(cm) {\n    var range$$1 = cm.curOp.scrollToPos;\n    if (range$$1) {\n      cm.curOp.scrollToPos = null;\n      var from = estimateCoords(cm, range$$1.from), to = estimateCoords(cm, range$$1.to);\n      scrollToCoordsRange(cm, from, to, range$$1.margin);\n    }\n  }\n\n  function scrollToCoordsRange(cm, from, to, margin) {\n    var sPos = calculateScrollPos(cm, {\n      left: Math.min(from.left, to.left),\n      top: Math.min(from.top, to.top) - margin,\n      right: Math.max(from.right, to.right),\n      bottom: Math.max(from.bottom, to.bottom) + margin\n    });\n    scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);\n  }\n\n  // Sync the scrollable area and scrollbars, ensure the viewport\n  // covers the visible area.\n  function updateScrollTop(cm, val) {\n    if (Math.abs(cm.doc.scrollTop - val) < 2) { return }\n    if (!gecko) { updateDisplaySimple(cm, {top: val}); }\n    setScrollTop(cm, val, true);\n    if (gecko) { updateDisplaySimple(cm); }\n    startWorker(cm, 100);\n  }\n\n  function setScrollTop(cm, val, forceScroll) {\n    val = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val);\n    if (cm.display.scroller.scrollTop == val && !forceScroll) { return }\n    cm.doc.scrollTop = val;\n    cm.display.scrollbars.setScrollTop(val);\n    if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }\n  }\n\n  // Sync scroller and scrollbar, ensure the gutter elements are\n  // aligned.\n  function setScrollLeft(cm, val, isScroller, forceScroll) {\n    val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth);\n    if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) { return }\n    cm.doc.scrollLeft = val;\n    alignHorizontally(cm);\n    if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }\n    cm.display.scrollbars.setScrollLeft(val);\n  }\n\n  // SCROLLBARS\n\n  // Prepare DOM reads needed to update the scrollbars. Done in one\n  // shot to minimize update/measure roundtrips.\n  function measureForScrollbars(cm) {\n    var d = cm.display, gutterW = d.gutters.offsetWidth;\n    var docH = Math.round(cm.doc.height + paddingVert(cm.display));\n    return {\n      clientHeight: d.scroller.clientHeight,\n      viewHeight: d.wrapper.clientHeight,\n      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,\n      viewWidth: d.wrapper.clientWidth,\n      barLeft: cm.options.fixedGutter ? gutterW : 0,\n      docHeight: docH,\n      scrollHeight: docH + scrollGap(cm) + d.barHeight,\n      nativeBarWidth: d.nativeBarWidth,\n      gutterWidth: gutterW\n    }\n  }\n\n  var NativeScrollbars = function(place, scroll, cm) {\n    this.cm = cm;\n    var vert = this.vert = elt(\"div\", [elt(\"div\", null, null, \"min-width: 1px\")], \"CodeMirror-vscrollbar\");\n    var horiz = this.horiz = elt(\"div\", [elt(\"div\", null, null, \"height: 100%; min-height: 1px\")], \"CodeMirror-hscrollbar\");\n    vert.tabIndex = horiz.tabIndex = -1;\n    place(vert); place(horiz);\n\n    on(vert, \"scroll\", function () {\n      if (vert.clientHeight) { scroll(vert.scrollTop, \"vertical\"); }\n    });\n    on(horiz, \"scroll\", function () {\n      if (horiz.clientWidth) { scroll(horiz.scrollLeft, \"horizontal\"); }\n    });\n\n    this.checkedZeroWidth = false;\n    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).\n    if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = \"18px\"; }\n  };\n\n  NativeScrollbars.prototype.update = function (measure) {\n    var needsH = measure.scrollWidth > measure.clientWidth + 1;\n    var needsV = measure.scrollHeight > measure.clientHeight + 1;\n    var sWidth = measure.nativeBarWidth;\n\n    if (needsV) {\n      this.vert.style.display = \"block\";\n      this.vert.style.bottom = needsH ? sWidth + \"px\" : \"0\";\n      var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);\n      // A bug in IE8 can cause this value to be negative, so guard it.\n      this.vert.firstChild.style.height =\n        Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + \"px\";\n    } else {\n      this.vert.style.display = \"\";\n      this.vert.firstChild.style.height = \"0\";\n    }\n\n    if (needsH) {\n      this.horiz.style.display = \"block\";\n      this.horiz.style.right = needsV ? sWidth + \"px\" : \"0\";\n      this.horiz.style.left = measure.barLeft + \"px\";\n      var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);\n      this.horiz.firstChild.style.width =\n        Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + \"px\";\n    } else {\n      this.horiz.style.display = \"\";\n      this.horiz.firstChild.style.width = \"0\";\n    }\n\n    if (!this.checkedZeroWidth && measure.clientHeight > 0) {\n      if (sWidth == 0) { this.zeroWidthHack(); }\n      this.checkedZeroWidth = true;\n    }\n\n    return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}\n  };\n\n  NativeScrollbars.prototype.setScrollLeft = function (pos) {\n    if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }\n    if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz, \"horiz\"); }\n  };\n\n  NativeScrollbars.prototype.setScrollTop = function (pos) {\n    if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }\n    if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert, \"vert\"); }\n  };\n\n  NativeScrollbars.prototype.zeroWidthHack = function () {\n    var w = mac && !mac_geMountainLion ? \"12px\" : \"18px\";\n    this.horiz.style.height = this.vert.style.width = w;\n    this.horiz.style.pointerEvents = this.vert.style.pointerEvents = \"none\";\n    this.disableHoriz = new Delayed;\n    this.disableVert = new Delayed;\n  };\n\n  NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {\n    bar.style.pointerEvents = \"auto\";\n    function maybeDisable() {\n      // To find out whether the scrollbar is still visible, we\n      // check whether the element under the pixel in the bottom\n      // right corner of the scrollbar box is the scrollbar box\n      // itself (when the bar is still visible) or its filler child\n      // (when the bar is hidden). If it is still visible, we keep\n      // it enabled, if it's hidden, we disable pointer events.\n      var box = bar.getBoundingClientRect();\n      var elt$$1 = type == \"vert\" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2)\n          : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);\n      if (elt$$1 != bar) { bar.style.pointerEvents = \"none\"; }\n      else { delay.set(1000, maybeDisable); }\n    }\n    delay.set(1000, maybeDisable);\n  };\n\n  NativeScrollbars.prototype.clear = function () {\n    var parent = this.horiz.parentNode;\n    parent.removeChild(this.horiz);\n    parent.removeChild(this.vert);\n  };\n\n  var NullScrollbars = function () {};\n\n  NullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };\n  NullScrollbars.prototype.setScrollLeft = function () {};\n  NullScrollbars.prototype.setScrollTop = function () {};\n  NullScrollbars.prototype.clear = function () {};\n\n  function updateScrollbars(cm, measure) {\n    if (!measure) { measure = measureForScrollbars(cm); }\n    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;\n    updateScrollbarsInner(cm, measure);\n    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {\n      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)\n        { updateHeightsInViewport(cm); }\n      updateScrollbarsInner(cm, measureForScrollbars(cm));\n      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;\n    }\n  }\n\n  // Re-synchronize the fake scrollbars with the actual size of the\n  // content.\n  function updateScrollbarsInner(cm, measure) {\n    var d = cm.display;\n    var sizes = d.scrollbars.update(measure);\n\n    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + \"px\";\n    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + \"px\";\n    d.heightForcer.style.borderBottom = sizes.bottom + \"px solid transparent\";\n\n    if (sizes.right && sizes.bottom) {\n      d.scrollbarFiller.style.display = \"block\";\n      d.scrollbarFiller.style.height = sizes.bottom + \"px\";\n      d.scrollbarFiller.style.width = sizes.right + \"px\";\n    } else { d.scrollbarFiller.style.display = \"\"; }\n    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {\n      d.gutterFiller.style.display = \"block\";\n      d.gutterFiller.style.height = sizes.bottom + \"px\";\n      d.gutterFiller.style.width = measure.gutterWidth + \"px\";\n    } else { d.gutterFiller.style.display = \"\"; }\n  }\n\n  var scrollbarModel = {\"native\": NativeScrollbars, \"null\": NullScrollbars};\n\n  function initScrollbars(cm) {\n    if (cm.display.scrollbars) {\n      cm.display.scrollbars.clear();\n      if (cm.display.scrollbars.addClass)\n        { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\n    }\n\n    cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {\n      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);\n      // Prevent clicks in the scrollbars from killing focus\n      on(node, \"mousedown\", function () {\n        if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }\n      });\n      node.setAttribute(\"cm-not-content\", \"true\");\n    }, function (pos, axis) {\n      if (axis == \"horizontal\") { setScrollLeft(cm, pos); }\n      else { updateScrollTop(cm, pos); }\n    }, cm);\n    if (cm.display.scrollbars.addClass)\n      { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }\n  }\n\n  // Operations are used to wrap a series of changes to the editor\n  // state in such a way that each change won't have to update the\n  // cursor and display (which would be awkward, slow, and\n  // error-prone). Instead, display updates are batched and then all\n  // combined and executed at once.\n\n  var nextOpId = 0;\n  // Start a new operation.\n  function startOperation(cm) {\n    cm.curOp = {\n      cm: cm,\n      viewChanged: false,      // Flag that indicates that lines might need to be redrawn\n      startHeight: cm.doc.height, // Used to detect need to update scrollbar\n      forceUpdate: false,      // Used to force a redraw\n      updateInput: 0,       // Whether to reset the input textarea\n      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)\n      changeObjs: null,        // Accumulated changes, for firing change events\n      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on\n      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already\n      selectionChanged: false, // Whether the selection needs to be redrawn\n      updateMaxLine: false,    // Set when the widest line needs to be determined anew\n      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet\n      scrollToPos: null,       // Used to scroll to a specific position\n      focus: false,\n      id: ++nextOpId           // Unique ID\n    };\n    pushOperation(cm.curOp);\n  }\n\n  // Finish an operation, updating the display and signalling delayed events\n  function endOperation(cm) {\n    var op = cm.curOp;\n    if (op) { finishOperation(op, function (group) {\n      for (var i = 0; i < group.ops.length; i++)\n        { group.ops[i].cm.curOp = null; }\n      endOperations(group);\n    }); }\n  }\n\n  // The DOM updates done when an operation finishes are batched so\n  // that the minimum number of relayouts are required.\n  function endOperations(group) {\n    var ops = group.ops;\n    for (var i = 0; i < ops.length; i++) // Read DOM\n      { endOperation_R1(ops[i]); }\n    for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)\n      { endOperation_W1(ops[i$1]); }\n    for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM\n      { endOperation_R2(ops[i$2]); }\n    for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)\n      { endOperation_W2(ops[i$3]); }\n    for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM\n      { endOperation_finish(ops[i$4]); }\n  }\n\n  function endOperation_R1(op) {\n    var cm = op.cm, display = cm.display;\n    maybeClipScrollbars(cm);\n    if (op.updateMaxLine) { findMaxLine(cm); }\n\n    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||\n      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||\n                         op.scrollToPos.to.line >= display.viewTo) ||\n      display.maxLineChanged && cm.options.lineWrapping;\n    op.update = op.mustUpdate &&\n      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);\n  }\n\n  function endOperation_W1(op) {\n    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);\n  }\n\n  function endOperation_R2(op) {\n    var cm = op.cm, display = cm.display;\n    if (op.updatedDisplay) { updateHeightsInViewport(cm); }\n\n    op.barMeasure = measureForScrollbars(cm);\n\n    // If the max line changed since it was last measured, measure it,\n    // and ensure the document's width matches it.\n    // updateDisplay_W2 will use these properties to do the actual resizing\n    if (display.maxLineChanged && !cm.options.lineWrapping) {\n      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;\n      cm.display.sizerWidth = op.adjustWidthTo;\n      op.barMeasure.scrollWidth =\n        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);\n      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));\n    }\n\n    if (op.updatedDisplay || op.selectionChanged)\n      { op.preparedSelection = display.input.prepareSelection(); }\n  }\n\n  function endOperation_W2(op) {\n    var cm = op.cm;\n\n    if (op.adjustWidthTo != null) {\n      cm.display.sizer.style.minWidth = op.adjustWidthTo + \"px\";\n      if (op.maxScrollLeft < cm.doc.scrollLeft)\n        { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }\n      cm.display.maxLineChanged = false;\n    }\n\n    var takeFocus = op.focus && op.focus == activeElt();\n    if (op.preparedSelection)\n      { cm.display.input.showSelection(op.preparedSelection, takeFocus); }\n    if (op.updatedDisplay || op.startHeight != cm.doc.height)\n      { updateScrollbars(cm, op.barMeasure); }\n    if (op.updatedDisplay)\n      { setDocumentHeight(cm, op.barMeasure); }\n\n    if (op.selectionChanged) { restartBlink(cm); }\n\n    if (cm.state.focused && op.updateInput)\n      { cm.display.input.reset(op.typing); }\n    if (takeFocus) { ensureFocus(op.cm); }\n  }\n\n  function endOperation_finish(op) {\n    var cm = op.cm, display = cm.display, doc = cm.doc;\n\n    if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }\n\n    // Abort mouse wheel delta measurement, when scrolling explicitly\n    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))\n      { display.wheelStartX = display.wheelStartY = null; }\n\n    // Propagate the scroll position to the actual DOM scroller\n    if (op.scrollTop != null) { setScrollTop(cm, op.scrollTop, op.forceScroll); }\n\n    if (op.scrollLeft != null) { setScrollLeft(cm, op.scrollLeft, true, true); }\n    // If we need to scroll a specific position into view, do so.\n    if (op.scrollToPos) {\n      var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),\n                                   clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);\n      maybeScrollWindow(cm, rect);\n    }\n\n    // Fire events for markers that are hidden/unidden by editing or\n    // undoing\n    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;\n    if (hidden) { for (var i = 0; i < hidden.length; ++i)\n      { if (!hidden[i].lines.length) { signal(hidden[i], \"hide\"); } } }\n    if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)\n      { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], \"unhide\"); } } }\n\n    if (display.wrapper.offsetHeight)\n      { doc.scrollTop = cm.display.scroller.scrollTop; }\n\n    // Fire change events, and delayed event handlers\n    if (op.changeObjs)\n      { signal(cm, \"changes\", cm, op.changeObjs); }\n    if (op.update)\n      { op.update.finish(); }\n  }\n\n  // Run the given function in an operation\n  function runInOp(cm, f) {\n    if (cm.curOp) { return f() }\n    startOperation(cm);\n    try { return f() }\n    finally { endOperation(cm); }\n  }\n  // Wraps a function in an operation. Returns the wrapped function.\n  function operation(cm, f) {\n    return function() {\n      if (cm.curOp) { return f.apply(cm, arguments) }\n      startOperation(cm);\n      try { return f.apply(cm, arguments) }\n      finally { endOperation(cm); }\n    }\n  }\n  // Used to add methods to editor and doc instances, wrapping them in\n  // operations.\n  function methodOp(f) {\n    return function() {\n      if (this.curOp) { return f.apply(this, arguments) }\n      startOperation(this);\n      try { return f.apply(this, arguments) }\n      finally { endOperation(this); }\n    }\n  }\n  function docMethodOp(f) {\n    return function() {\n      var cm = this.cm;\n      if (!cm || cm.curOp) { return f.apply(this, arguments) }\n      startOperation(cm);\n      try { return f.apply(this, arguments) }\n      finally { endOperation(cm); }\n    }\n  }\n\n  // Updates the display.view data structure for a given change to the\n  // document. From and to are in pre-change coordinates. Lendiff is\n  // the amount of lines added or subtracted by the change. This is\n  // used for changes that span multiple lines, or change the way\n  // lines are divided into visual lines. regLineChange (below)\n  // registers single-line changes.\n  function regChange(cm, from, to, lendiff) {\n    if (from == null) { from = cm.doc.first; }\n    if (to == null) { to = cm.doc.first + cm.doc.size; }\n    if (!lendiff) { lendiff = 0; }\n\n    var display = cm.display;\n    if (lendiff && to < display.viewTo &&\n        (display.updateLineNumbers == null || display.updateLineNumbers > from))\n      { display.updateLineNumbers = from; }\n\n    cm.curOp.viewChanged = true;\n\n    if (from >= display.viewTo) { // Change after\n      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)\n        { resetView(cm); }\n    } else if (to <= display.viewFrom) { // Change before\n      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {\n        resetView(cm);\n      } else {\n        display.viewFrom += lendiff;\n        display.viewTo += lendiff;\n      }\n    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap\n      resetView(cm);\n    } else if (from <= display.viewFrom) { // Top overlap\n      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);\n      if (cut) {\n        display.view = display.view.slice(cut.index);\n        display.viewFrom = cut.lineN;\n        display.viewTo += lendiff;\n      } else {\n        resetView(cm);\n      }\n    } else if (to >= display.viewTo) { // Bottom overlap\n      var cut$1 = viewCuttingPoint(cm, from, from, -1);\n      if (cut$1) {\n        display.view = display.view.slice(0, cut$1.index);\n        display.viewTo = cut$1.lineN;\n      } else {\n        resetView(cm);\n      }\n    } else { // Gap in the middle\n      var cutTop = viewCuttingPoint(cm, from, from, -1);\n      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);\n      if (cutTop && cutBot) {\n        display.view = display.view.slice(0, cutTop.index)\n          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))\n          .concat(display.view.slice(cutBot.index));\n        display.viewTo += lendiff;\n      } else {\n        resetView(cm);\n      }\n    }\n\n    var ext = display.externalMeasured;\n    if (ext) {\n      if (to < ext.lineN)\n        { ext.lineN += lendiff; }\n      else if (from < ext.lineN + ext.size)\n        { display.externalMeasured = null; }\n    }\n  }\n\n  // Register a change to a single line. Type must be one of \"text\",\n  // \"gutter\", \"class\", \"widget\"\n  function regLineChange(cm, line, type) {\n    cm.curOp.viewChanged = true;\n    var display = cm.display, ext = cm.display.externalMeasured;\n    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)\n      { display.externalMeasured = null; }\n\n    if (line < display.viewFrom || line >= display.viewTo) { return }\n    var lineView = display.view[findViewIndex(cm, line)];\n    if (lineView.node == null) { return }\n    var arr = lineView.changes || (lineView.changes = []);\n    if (indexOf(arr, type) == -1) { arr.push(type); }\n  }\n\n  // Clear the view.\n  function resetView(cm) {\n    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;\n    cm.display.view = [];\n    cm.display.viewOffset = 0;\n  }\n\n  function viewCuttingPoint(cm, oldN, newN, dir) {\n    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;\n    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)\n      { return {index: index, lineN: newN} }\n    var n = cm.display.viewFrom;\n    for (var i = 0; i < index; i++)\n      { n += view[i].size; }\n    if (n != oldN) {\n      if (dir > 0) {\n        if (index == view.length - 1) { return null }\n        diff = (n + view[index].size) - oldN;\n        index++;\n      } else {\n        diff = n - oldN;\n      }\n      oldN += diff; newN += diff;\n    }\n    while (visualLineNo(cm.doc, newN) != newN) {\n      if (index == (dir < 0 ? 0 : view.length - 1)) { return null }\n      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;\n      index += dir;\n    }\n    return {index: index, lineN: newN}\n  }\n\n  // Force the view to cover a given range, adding empty view element\n  // or clipping off existing ones as needed.\n  function adjustView(cm, from, to) {\n    var display = cm.display, view = display.view;\n    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {\n      display.view = buildViewArray(cm, from, to);\n      display.viewFrom = from;\n    } else {\n      if (display.viewFrom > from)\n        { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }\n      else if (display.viewFrom < from)\n        { display.view = display.view.slice(findViewIndex(cm, from)); }\n      display.viewFrom = from;\n      if (display.viewTo < to)\n        { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }\n      else if (display.viewTo > to)\n        { display.view = display.view.slice(0, findViewIndex(cm, to)); }\n    }\n    display.viewTo = to;\n  }\n\n  // Count the number of lines in the view whose DOM representation is\n  // out of date (or nonexistent).\n  function countDirtyView(cm) {\n    var view = cm.display.view, dirty = 0;\n    for (var i = 0; i < view.length; i++) {\n      var lineView = view[i];\n      if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }\n    }\n    return dirty\n  }\n\n  // HIGHLIGHT WORKER\n\n  function startWorker(cm, time) {\n    if (cm.doc.highlightFrontier < cm.display.viewTo)\n      { cm.state.highlight.set(time, bind(highlightWorker, cm)); }\n  }\n\n  function highlightWorker(cm) {\n    var doc = cm.doc;\n    if (doc.highlightFrontier >= cm.display.viewTo) { return }\n    var end = +new Date + cm.options.workTime;\n    var context = getContextBefore(cm, doc.highlightFrontier);\n    var changedLines = [];\n\n    doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {\n      if (context.line >= cm.display.viewFrom) { // Visible\n        var oldStyles = line.styles;\n        var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;\n        var highlighted = highlightLine(cm, line, context, true);\n        if (resetState) { context.state = resetState; }\n        line.styles = highlighted.styles;\n        var oldCls = line.styleClasses, newCls = highlighted.classes;\n        if (newCls) { line.styleClasses = newCls; }\n        else if (oldCls) { line.styleClasses = null; }\n        var ischange = !oldStyles || oldStyles.length != line.styles.length ||\n          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);\n        for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }\n        if (ischange) { changedLines.push(context.line); }\n        line.stateAfter = context.save();\n        context.nextLine();\n      } else {\n        if (line.text.length <= cm.options.maxHighlightLength)\n          { processLine(cm, line.text, context); }\n        line.stateAfter = context.line % 5 == 0 ? context.save() : null;\n        context.nextLine();\n      }\n      if (+new Date > end) {\n        startWorker(cm, cm.options.workDelay);\n        return true\n      }\n    });\n    doc.highlightFrontier = context.line;\n    doc.modeFrontier = Math.max(doc.modeFrontier, context.line);\n    if (changedLines.length) { runInOp(cm, function () {\n      for (var i = 0; i < changedLines.length; i++)\n        { regLineChange(cm, changedLines[i], \"text\"); }\n    }); }\n  }\n\n  // DISPLAY DRAWING\n\n  var DisplayUpdate = function(cm, viewport, force) {\n    var display = cm.display;\n\n    this.viewport = viewport;\n    // Store some values that we'll need later (but don't want to force a relayout for)\n    this.visible = visibleLines(display, cm.doc, viewport);\n    this.editorIsHidden = !display.wrapper.offsetWidth;\n    this.wrapperHeight = display.wrapper.clientHeight;\n    this.wrapperWidth = display.wrapper.clientWidth;\n    this.oldDisplayWidth = displayWidth(cm);\n    this.force = force;\n    this.dims = getDimensions(cm);\n    this.events = [];\n  };\n\n  DisplayUpdate.prototype.signal = function (emitter, type) {\n    if (hasHandler(emitter, type))\n      { this.events.push(arguments); }\n  };\n  DisplayUpdate.prototype.finish = function () {\n      var this$1 = this;\n\n    for (var i = 0; i < this.events.length; i++)\n      { signal.apply(null, this$1.events[i]); }\n  };\n\n  function maybeClipScrollbars(cm) {\n    var display = cm.display;\n    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {\n      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;\n      display.heightForcer.style.height = scrollGap(cm) + \"px\";\n      display.sizer.style.marginBottom = -display.nativeBarWidth + \"px\";\n      display.sizer.style.borderRightWidth = scrollGap(cm) + \"px\";\n      display.scrollbarsClipped = true;\n    }\n  }\n\n  function selectionSnapshot(cm) {\n    if (cm.hasFocus()) { return null }\n    var active = activeElt();\n    if (!active || !contains(cm.display.lineDiv, active)) { return null }\n    var result = {activeElt: active};\n    if (window.getSelection) {\n      var sel = window.getSelection();\n      if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {\n        result.anchorNode = sel.anchorNode;\n        result.anchorOffset = sel.anchorOffset;\n        result.focusNode = sel.focusNode;\n        result.focusOffset = sel.focusOffset;\n      }\n    }\n    return result\n  }\n\n  function restoreSelection(snapshot) {\n    if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) { return }\n    snapshot.activeElt.focus();\n    if (snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {\n      var sel = window.getSelection(), range$$1 = document.createRange();\n      range$$1.setEnd(snapshot.anchorNode, snapshot.anchorOffset);\n      range$$1.collapse(false);\n      sel.removeAllRanges();\n      sel.addRange(range$$1);\n      sel.extend(snapshot.focusNode, snapshot.focusOffset);\n    }\n  }\n\n  // Does the actual updating of the line display. Bails out\n  // (returning false) when there is nothing to be done and forced is\n  // false.\n  function updateDisplayIfNeeded(cm, update) {\n    var display = cm.display, doc = cm.doc;\n\n    if (update.editorIsHidden) {\n      resetView(cm);\n      return false\n    }\n\n    // Bail out if the visible area is already rendered and nothing changed.\n    if (!update.force &&\n        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&\n        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&\n        display.renderedView == display.view && countDirtyView(cm) == 0)\n      { return false }\n\n    if (maybeUpdateLineNumberWidth(cm)) {\n      resetView(cm);\n      update.dims = getDimensions(cm);\n    }\n\n    // Compute a suitable new viewport (from & to)\n    var end = doc.first + doc.size;\n    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);\n    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);\n    if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom); }\n    if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo); }\n    if (sawCollapsedSpans) {\n      from = visualLineNo(cm.doc, from);\n      to = visualLineEndNo(cm.doc, to);\n    }\n\n    var different = from != display.viewFrom || to != display.viewTo ||\n      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;\n    adjustView(cm, from, to);\n\n    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));\n    // Position the mover div to align with the current scroll position\n    cm.display.mover.style.top = display.viewOffset + \"px\";\n\n    var toUpdate = countDirtyView(cm);\n    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&\n        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))\n      { return false }\n\n    // For big changes, we hide the enclosing element during the\n    // update, since that speeds up the operations on most browsers.\n    var selSnapshot = selectionSnapshot(cm);\n    if (toUpdate > 4) { display.lineDiv.style.display = \"none\"; }\n    patchDisplay(cm, display.updateLineNumbers, update.dims);\n    if (toUpdate > 4) { display.lineDiv.style.display = \"\"; }\n    display.renderedView = display.view;\n    // There might have been a widget with a focused element that got\n    // hidden or updated, if so re-focus it.\n    restoreSelection(selSnapshot);\n\n    // Prevent selection and cursors from interfering with the scroll\n    // width and height.\n    removeChildren(display.cursorDiv);\n    removeChildren(display.selectionDiv);\n    display.gutters.style.height = display.sizer.style.minHeight = 0;\n\n    if (different) {\n      display.lastWrapHeight = update.wrapperHeight;\n      display.lastWrapWidth = update.wrapperWidth;\n      startWorker(cm, 400);\n    }\n\n    display.updateLineNumbers = null;\n\n    return true\n  }\n\n  function postUpdateDisplay(cm, update) {\n    var viewport = update.viewport;\n\n    for (var first = true;; first = false) {\n      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {\n        // Clip forced viewport to actual scrollable area.\n        if (viewport && viewport.top != null)\n          { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }\n        // Updated line heights might result in the drawn area not\n        // actually covering the viewport. Keep looping until it does.\n        update.visible = visibleLines(cm.display, cm.doc, viewport);\n        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)\n          { break }\n      }\n      if (!updateDisplayIfNeeded(cm, update)) { break }\n      updateHeightsInViewport(cm);\n      var barMeasure = measureForScrollbars(cm);\n      updateSelection(cm);\n      updateScrollbars(cm, barMeasure);\n      setDocumentHeight(cm, barMeasure);\n      update.force = false;\n    }\n\n    update.signal(cm, \"update\", cm);\n    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {\n      update.signal(cm, \"viewportChange\", cm, cm.display.viewFrom, cm.display.viewTo);\n      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;\n    }\n  }\n\n  function updateDisplaySimple(cm, viewport) {\n    var update = new DisplayUpdate(cm, viewport);\n    if (updateDisplayIfNeeded(cm, update)) {\n      updateHeightsInViewport(cm);\n      postUpdateDisplay(cm, update);\n      var barMeasure = measureForScrollbars(cm);\n      updateSelection(cm);\n      updateScrollbars(cm, barMeasure);\n      setDocumentHeight(cm, barMeasure);\n      update.finish();\n    }\n  }\n\n  // Sync the actual display DOM structure with display.view, removing\n  // nodes for lines that are no longer in view, and creating the ones\n  // that are not there yet, and updating the ones that are out of\n  // date.\n  function patchDisplay(cm, updateNumbersFrom, dims) {\n    var display = cm.display, lineNumbers = cm.options.lineNumbers;\n    var container = display.lineDiv, cur = container.firstChild;\n\n    function rm(node) {\n      var next = node.nextSibling;\n      // Works around a throw-scroll bug in OS X Webkit\n      if (webkit && mac && cm.display.currentWheelTarget == node)\n        { node.style.display = \"none\"; }\n      else\n        { node.parentNode.removeChild(node); }\n      return next\n    }\n\n    var view = display.view, lineN = display.viewFrom;\n    // Loop over the elements in the view, syncing cur (the DOM nodes\n    // in display.lineDiv) with the view as we go.\n    for (var i = 0; i < view.length; i++) {\n      var lineView = view[i];\n      if (lineView.hidden) ; else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet\n        var node = buildLineElement(cm, lineView, lineN, dims);\n        container.insertBefore(node, cur);\n      } else { // Already drawn\n        while (cur != lineView.node) { cur = rm(cur); }\n        var updateNumber = lineNumbers && updateNumbersFrom != null &&\n          updateNumbersFrom <= lineN && lineView.lineNumber;\n        if (lineView.changes) {\n          if (indexOf(lineView.changes, \"gutter\") > -1) { updateNumber = false; }\n          updateLineForChanges(cm, lineView, lineN, dims);\n        }\n        if (updateNumber) {\n          removeChildren(lineView.lineNumber);\n          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));\n        }\n        cur = lineView.node.nextSibling;\n      }\n      lineN += lineView.size;\n    }\n    while (cur) { cur = rm(cur); }\n  }\n\n  function updateGutterSpace(cm) {\n    var width = cm.display.gutters.offsetWidth;\n    cm.display.sizer.style.marginLeft = width + \"px\";\n  }\n\n  function setDocumentHeight(cm, measure) {\n    cm.display.sizer.style.minHeight = measure.docHeight + \"px\";\n    cm.display.heightForcer.style.top = measure.docHeight + \"px\";\n    cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + \"px\";\n  }\n\n  // Rebuild the gutter elements, ensure the margin to the left of the\n  // code matches their width.\n  function updateGutters(cm) {\n    var gutters = cm.display.gutters, specs = cm.options.gutters;\n    removeChildren(gutters);\n    var i = 0;\n    for (; i < specs.length; ++i) {\n      var gutterClass = specs[i];\n      var gElt = gutters.appendChild(elt(\"div\", null, \"CodeMirror-gutter \" + gutterClass));\n      if (gutterClass == \"CodeMirror-linenumbers\") {\n        cm.display.lineGutter = gElt;\n        gElt.style.width = (cm.display.lineNumWidth || 1) + \"px\";\n      }\n    }\n    gutters.style.display = i ? \"\" : \"none\";\n    updateGutterSpace(cm);\n  }\n\n  // Make sure the gutters options contains the element\n  // \"CodeMirror-linenumbers\" when the lineNumbers option is true.\n  function setGuttersForLineNumbers(options) {\n    var found = indexOf(options.gutters, \"CodeMirror-linenumbers\");\n    if (found == -1 && options.lineNumbers) {\n      options.gutters = options.gutters.concat([\"CodeMirror-linenumbers\"]);\n    } else if (found > -1 && !options.lineNumbers) {\n      options.gutters = options.gutters.slice(0);\n      options.gutters.splice(found, 1);\n    }\n  }\n\n  // Since the delta values reported on mouse wheel events are\n  // unstandardized between browsers and even browser versions, and\n  // generally horribly unpredictable, this code starts by measuring\n  // the scroll effect that the first few mouse wheel events have,\n  // and, from that, detects the way it can convert deltas to pixel\n  // offsets afterwards.\n  //\n  // The reason we want to know the amount a wheel event will scroll\n  // is that it gives us a chance to update the display before the\n  // actual scrolling happens, reducing flickering.\n\n  var wheelSamples = 0, wheelPixelsPerUnit = null;\n  // Fill in a browser-detected starting value on browsers where we\n  // know one. These don't have to be accurate -- the result of them\n  // being wrong would just be a slight flicker on the first wheel\n  // scroll (if it is large enough).\n  if (ie) { wheelPixelsPerUnit = -.53; }\n  else if (gecko) { wheelPixelsPerUnit = 15; }\n  else if (chrome) { wheelPixelsPerUnit = -.7; }\n  else if (safari) { wheelPixelsPerUnit = -1/3; }\n\n  function wheelEventDelta(e) {\n    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;\n    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }\n    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }\n    else if (dy == null) { dy = e.wheelDelta; }\n    return {x: dx, y: dy}\n  }\n  function wheelEventPixels(e) {\n    var delta = wheelEventDelta(e);\n    delta.x *= wheelPixelsPerUnit;\n    delta.y *= wheelPixelsPerUnit;\n    return delta\n  }\n\n  function onScrollWheel(cm, e) {\n    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;\n\n    var display = cm.display, scroll = display.scroller;\n    // Quit if there's nothing to scroll here\n    var canScrollX = scroll.scrollWidth > scroll.clientWidth;\n    var canScrollY = scroll.scrollHeight > scroll.clientHeight;\n    if (!(dx && canScrollX || dy && canScrollY)) { return }\n\n    // Webkit browsers on OS X abort momentum scrolls when the target\n    // of the scroll event is removed from the scrollable element.\n    // This hack (see related code in patchDisplay) makes sure the\n    // element is kept around.\n    if (dy && mac && webkit) {\n      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {\n        for (var i = 0; i < view.length; i++) {\n          if (view[i].node == cur) {\n            cm.display.currentWheelTarget = cur;\n            break outer\n          }\n        }\n      }\n    }\n\n    // On some browsers, horizontal scrolling will cause redraws to\n    // happen before the gutter has been realigned, causing it to\n    // wriggle around in a most unseemly way. When we have an\n    // estimated pixels/delta value, we just handle horizontal\n    // scrolling entirely here. It'll be slightly off from native, but\n    // better than glitching out.\n    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {\n      if (dy && canScrollY)\n        { updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit)); }\n      setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit));\n      // Only prevent default scrolling if vertical scrolling is\n      // actually possible. Otherwise, it causes vertical scroll\n      // jitter on OSX trackpads when deltaX is small and deltaY\n      // is large (issue #3579)\n      if (!dy || (dy && canScrollY))\n        { e_preventDefault(e); }\n      display.wheelStartX = null; // Abort measurement, if in progress\n      return\n    }\n\n    // 'Project' the visible viewport to cover the area that is being\n    // scrolled into view (if we know enough to estimate it).\n    if (dy && wheelPixelsPerUnit != null) {\n      var pixels = dy * wheelPixelsPerUnit;\n      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;\n      if (pixels < 0) { top = Math.max(0, top + pixels - 50); }\n      else { bot = Math.min(cm.doc.height, bot + pixels + 50); }\n      updateDisplaySimple(cm, {top: top, bottom: bot});\n    }\n\n    if (wheelSamples < 20) {\n      if (display.wheelStartX == null) {\n        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;\n        display.wheelDX = dx; display.wheelDY = dy;\n        setTimeout(function () {\n          if (display.wheelStartX == null) { return }\n          var movedX = scroll.scrollLeft - display.wheelStartX;\n          var movedY = scroll.scrollTop - display.wheelStartY;\n          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||\n            (movedX && display.wheelDX && movedX / display.wheelDX);\n          display.wheelStartX = display.wheelStartY = null;\n          if (!sample) { return }\n          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);\n          ++wheelSamples;\n        }, 200);\n      } else {\n        display.wheelDX += dx; display.wheelDY += dy;\n      }\n    }\n  }\n\n  // Selection objects are immutable. A new one is created every time\n  // the selection changes. A selection is one or more non-overlapping\n  // (and non-touching) ranges, sorted, and an integer that indicates\n  // which one is the primary selection (the one that's scrolled into\n  // view, that getCursor returns, etc).\n  var Selection = function(ranges, primIndex) {\n    this.ranges = ranges;\n    this.primIndex = primIndex;\n  };\n\n  Selection.prototype.primary = function () { return this.ranges[this.primIndex] };\n\n  Selection.prototype.equals = function (other) {\n      var this$1 = this;\n\n    if (other == this) { return true }\n    if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }\n    for (var i = 0; i < this.ranges.length; i++) {\n      var here = this$1.ranges[i], there = other.ranges[i];\n      if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }\n    }\n    return true\n  };\n\n  Selection.prototype.deepCopy = function () {\n      var this$1 = this;\n\n    var out = [];\n    for (var i = 0; i < this.ranges.length; i++)\n      { out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head)); }\n    return new Selection(out, this.primIndex)\n  };\n\n  Selection.prototype.somethingSelected = function () {\n      var this$1 = this;\n\n    for (var i = 0; i < this.ranges.length; i++)\n      { if (!this$1.ranges[i].empty()) { return true } }\n    return false\n  };\n\n  Selection.prototype.contains = function (pos, end) {\n      var this$1 = this;\n\n    if (!end) { end = pos; }\n    for (var i = 0; i < this.ranges.length; i++) {\n      var range = this$1.ranges[i];\n      if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)\n        { return i }\n    }\n    return -1\n  };\n\n  var Range = function(anchor, head) {\n    this.anchor = anchor; this.head = head;\n  };\n\n  Range.prototype.from = function () { return minPos(this.anchor, this.head) };\n  Range.prototype.to = function () { return maxPos(this.anchor, this.head) };\n  Range.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };\n\n  // Take an unsorted, potentially overlapping set of ranges, and\n  // build a selection out of it. 'Consumes' ranges array (modifying\n  // it).\n  function normalizeSelection(cm, ranges, primIndex) {\n    var mayTouch = cm && cm.options.selectionsMayTouch;\n    var prim = ranges[primIndex];\n    ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });\n    primIndex = indexOf(ranges, prim);\n    for (var i = 1; i < ranges.length; i++) {\n      var cur = ranges[i], prev = ranges[i - 1];\n      var diff = cmp(prev.to(), cur.from());\n      if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {\n        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());\n        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;\n        if (i <= primIndex) { --primIndex; }\n        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));\n      }\n    }\n    return new Selection(ranges, primIndex)\n  }\n\n  function simpleSelection(anchor, head) {\n    return new Selection([new Range(anchor, head || anchor)], 0)\n  }\n\n  // Compute the position of the end of a change (its 'to' property\n  // refers to the pre-change end).\n  function changeEnd(change) {\n    if (!change.text) { return change.to }\n    return Pos(change.from.line + change.text.length - 1,\n               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))\n  }\n\n  // Adjust a position to refer to the post-change position of the\n  // same text, or the end of the change if the change covers it.\n  function adjustForChange(pos, change) {\n    if (cmp(pos, change.from) < 0) { return pos }\n    if (cmp(pos, change.to) <= 0) { return changeEnd(change) }\n\n    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;\n    if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }\n    return Pos(line, ch)\n  }\n\n  function computeSelAfterChange(doc, change) {\n    var out = [];\n    for (var i = 0; i < doc.sel.ranges.length; i++) {\n      var range = doc.sel.ranges[i];\n      out.push(new Range(adjustForChange(range.anchor, change),\n                         adjustForChange(range.head, change)));\n    }\n    return normalizeSelection(doc.cm, out, doc.sel.primIndex)\n  }\n\n  function offsetPos(pos, old, nw) {\n    if (pos.line == old.line)\n      { return Pos(nw.line, pos.ch - old.ch + nw.ch) }\n    else\n      { return Pos(nw.line + (pos.line - old.line), pos.ch) }\n  }\n\n  // Used by replaceSelections to allow moving the selection to the\n  // start or around the replaced test. Hint may be \"start\" or \"around\".\n  function computeReplacedSel(doc, changes, hint) {\n    var out = [];\n    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;\n    for (var i = 0; i < changes.length; i++) {\n      var change = changes[i];\n      var from = offsetPos(change.from, oldPrev, newPrev);\n      var to = offsetPos(changeEnd(change), oldPrev, newPrev);\n      oldPrev = change.to;\n      newPrev = to;\n      if (hint == \"around\") {\n        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;\n        out[i] = new Range(inv ? to : from, inv ? from : to);\n      } else {\n        out[i] = new Range(from, from);\n      }\n    }\n    return new Selection(out, doc.sel.primIndex)\n  }\n\n  // Used to get the editor into a consistent state again when options change.\n\n  function loadMode(cm) {\n    cm.doc.mode = getMode(cm.options, cm.doc.modeOption);\n    resetModeState(cm);\n  }\n\n  function resetModeState(cm) {\n    cm.doc.iter(function (line) {\n      if (line.stateAfter) { line.stateAfter = null; }\n      if (line.styles) { line.styles = null; }\n    });\n    cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;\n    startWorker(cm, 100);\n    cm.state.modeGen++;\n    if (cm.curOp) { regChange(cm); }\n  }\n\n  // DOCUMENT DATA STRUCTURE\n\n  // By default, updates that start and end at the beginning of a line\n  // are treated specially, in order to make the association of line\n  // widgets and marker elements with the text behave more intuitive.\n  function isWholeLineUpdate(doc, change) {\n    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == \"\" &&\n      (!doc.cm || doc.cm.options.wholeLineUpdateBefore)\n  }\n\n  // Perform a change on the document data structure.\n  function updateDoc(doc, change, markedSpans, estimateHeight$$1) {\n    function spansFor(n) {return markedSpans ? markedSpans[n] : null}\n    function update(line, text, spans) {\n      updateLine(line, text, spans, estimateHeight$$1);\n      signalLater(line, \"change\", line, change);\n    }\n    function linesFor(start, end) {\n      var result = [];\n      for (var i = start; i < end; ++i)\n        { result.push(new Line(text[i], spansFor(i), estimateHeight$$1)); }\n      return result\n    }\n\n    var from = change.from, to = change.to, text = change.text;\n    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);\n    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;\n\n    // Adjust the line structure\n    if (change.full) {\n      doc.insert(0, linesFor(0, text.length));\n      doc.remove(text.length, doc.size - text.length);\n    } else if (isWholeLineUpdate(doc, change)) {\n      // This is a whole-line replace. Treated specially to make\n      // sure line objects move the way they are supposed to.\n      var added = linesFor(0, text.length - 1);\n      update(lastLine, lastLine.text, lastSpans);\n      if (nlines) { doc.remove(from.line, nlines); }\n      if (added.length) { doc.insert(from.line, added); }\n    } else if (firstLine == lastLine) {\n      if (text.length == 1) {\n        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);\n      } else {\n        var added$1 = linesFor(1, text.length - 1);\n        added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight$$1));\n        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n        doc.insert(from.line + 1, added$1);\n      }\n    } else if (text.length == 1) {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));\n      doc.remove(from.line + 1, nlines);\n    } else {\n      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));\n      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);\n      var added$2 = linesFor(1, text.length - 1);\n      if (nlines > 1) { doc.remove(from.line + 1, nlines - 1); }\n      doc.insert(from.line + 1, added$2);\n    }\n\n    signalLater(doc, \"change\", doc, change);\n  }\n\n  // Call f for all linked documents.\n  function linkedDocs(doc, f, sharedHistOnly) {\n    function propagate(doc, skip, sharedHist) {\n      if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {\n        var rel = doc.linked[i];\n        if (rel.doc == skip) { continue }\n        var shared = sharedHist && rel.sharedHist;\n        if (sharedHistOnly && !shared) { continue }\n        f(rel.doc, shared);\n        propagate(rel.doc, doc, shared);\n      } }\n    }\n    propagate(doc, null, true);\n  }\n\n  // Attach a document to an editor.\n  function attachDoc(cm, doc) {\n    if (doc.cm) { throw new Error(\"This document is already in use.\") }\n    cm.doc = doc;\n    doc.cm = cm;\n    estimateLineHeights(cm);\n    loadMode(cm);\n    setDirectionClass(cm);\n    if (!cm.options.lineWrapping) { findMaxLine(cm); }\n    cm.options.mode = doc.modeOption;\n    regChange(cm);\n  }\n\n  function setDirectionClass(cm) {\n  (cm.doc.direction == \"rtl\" ? addClass : rmClass)(cm.display.lineDiv, \"CodeMirror-rtl\");\n  }\n\n  function directionChanged(cm) {\n    runInOp(cm, function () {\n      setDirectionClass(cm);\n      regChange(cm);\n    });\n  }\n\n  function History(startGen) {\n    // Arrays of change events and selections. Doing something adds an\n    // event to done and clears undo. Undoing moves events from done\n    // to undone, redoing moves them in the other direction.\n    this.done = []; this.undone = [];\n    this.undoDepth = Infinity;\n    // Used to track when changes can be merged into a single undo\n    // event\n    this.lastModTime = this.lastSelTime = 0;\n    this.lastOp = this.lastSelOp = null;\n    this.lastOrigin = this.lastSelOrigin = null;\n    // Used by the isClean() method\n    this.generation = this.maxGeneration = startGen || 1;\n  }\n\n  // Create a history change event from an updateDoc-style change\n  // object.\n  function historyChangeFromChange(doc, change) {\n    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};\n    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);\n    linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);\n    return histChange\n  }\n\n  // Pop all selection events off the end of a history array. Stop at\n  // a change event.\n  function clearSelectionEvents(array) {\n    while (array.length) {\n      var last = lst(array);\n      if (last.ranges) { array.pop(); }\n      else { break }\n    }\n  }\n\n  // Find the top change event in the history. Pop off selection\n  // events that are in the way.\n  function lastChangeEvent(hist, force) {\n    if (force) {\n      clearSelectionEvents(hist.done);\n      return lst(hist.done)\n    } else if (hist.done.length && !lst(hist.done).ranges) {\n      return lst(hist.done)\n    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {\n      hist.done.pop();\n      return lst(hist.done)\n    }\n  }\n\n  // Register a change in the history. Merges changes that are within\n  // a single operation, or are close together with an origin that\n  // allows merging (starting with \"+\") into a single event.\n  function addChangeToHistory(doc, change, selAfter, opId) {\n    var hist = doc.history;\n    hist.undone.length = 0;\n    var time = +new Date, cur;\n    var last;\n\n    if ((hist.lastOp == opId ||\n         hist.lastOrigin == change.origin && change.origin &&\n         ((change.origin.charAt(0) == \"+\" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500)) ||\n          change.origin.charAt(0) == \"*\")) &&\n        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {\n      // Merge this change into the last event\n      last = lst(cur.changes);\n      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {\n        // Optimized case for simple insertion -- don't want to add\n        // new changesets for every character typed\n        last.to = changeEnd(change);\n      } else {\n        // Add new sub-event\n        cur.changes.push(historyChangeFromChange(doc, change));\n      }\n    } else {\n      // Can not be merged, start a new event.\n      var before = lst(hist.done);\n      if (!before || !before.ranges)\n        { pushSelectionToHistory(doc.sel, hist.done); }\n      cur = {changes: [historyChangeFromChange(doc, change)],\n             generation: hist.generation};\n      hist.done.push(cur);\n      while (hist.done.length > hist.undoDepth) {\n        hist.done.shift();\n        if (!hist.done[0].ranges) { hist.done.shift(); }\n      }\n    }\n    hist.done.push(selAfter);\n    hist.generation = ++hist.maxGeneration;\n    hist.lastModTime = hist.lastSelTime = time;\n    hist.lastOp = hist.lastSelOp = opId;\n    hist.lastOrigin = hist.lastSelOrigin = change.origin;\n\n    if (!last) { signal(doc, \"historyAdded\"); }\n  }\n\n  function selectionEventCanBeMerged(doc, origin, prev, sel) {\n    var ch = origin.charAt(0);\n    return ch == \"*\" ||\n      ch == \"+\" &&\n      prev.ranges.length == sel.ranges.length &&\n      prev.somethingSelected() == sel.somethingSelected() &&\n      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)\n  }\n\n  // Called whenever the selection changes, sets the new selection as\n  // the pending selection in the history, and pushes the old pending\n  // selection into the 'done' array when it was significantly\n  // different (in number of selected ranges, emptiness, or time).\n  function addSelectionToHistory(doc, sel, opId, options) {\n    var hist = doc.history, origin = options && options.origin;\n\n    // A new event is started when the previous origin does not match\n    // the current, or the origins don't allow matching. Origins\n    // starting with * are always merged, those starting with + are\n    // merged when similar and close together in time.\n    if (opId == hist.lastSelOp ||\n        (origin && hist.lastSelOrigin == origin &&\n         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||\n          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))\n      { hist.done[hist.done.length - 1] = sel; }\n    else\n      { pushSelectionToHistory(sel, hist.done); }\n\n    hist.lastSelTime = +new Date;\n    hist.lastSelOrigin = origin;\n    hist.lastSelOp = opId;\n    if (options && options.clearRedo !== false)\n      { clearSelectionEvents(hist.undone); }\n  }\n\n  function pushSelectionToHistory(sel, dest) {\n    var top = lst(dest);\n    if (!(top && top.ranges && top.equals(sel)))\n      { dest.push(sel); }\n  }\n\n  // Used to store marked span information in the history.\n  function attachLocalSpans(doc, change, from, to) {\n    var existing = change[\"spans_\" + doc.id], n = 0;\n    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {\n      if (line.markedSpans)\n        { (existing || (existing = change[\"spans_\" + doc.id] = {}))[n] = line.markedSpans; }\n      ++n;\n    });\n  }\n\n  // When un/re-doing restores text containing marked spans, those\n  // that have been explicitly cleared should not be restored.\n  function removeClearedSpans(spans) {\n    if (!spans) { return null }\n    var out;\n    for (var i = 0; i < spans.length; ++i) {\n      if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }\n      else if (out) { out.push(spans[i]); }\n    }\n    return !out ? spans : out.length ? out : null\n  }\n\n  // Retrieve and filter the old marked spans stored in a change event.\n  function getOldSpans(doc, change) {\n    var found = change[\"spans_\" + doc.id];\n    if (!found) { return null }\n    var nw = [];\n    for (var i = 0; i < change.text.length; ++i)\n      { nw.push(removeClearedSpans(found[i])); }\n    return nw\n  }\n\n  // Used for un/re-doing changes from the history. Combines the\n  // result of computing the existing spans with the set of spans that\n  // existed in the history (so that deleting around a span and then\n  // undoing brings back the span).\n  function mergeOldSpans(doc, change) {\n    var old = getOldSpans(doc, change);\n    var stretched = stretchSpansOverChange(doc, change);\n    if (!old) { return stretched }\n    if (!stretched) { return old }\n\n    for (var i = 0; i < old.length; ++i) {\n      var oldCur = old[i], stretchCur = stretched[i];\n      if (oldCur && stretchCur) {\n        spans: for (var j = 0; j < stretchCur.length; ++j) {\n          var span = stretchCur[j];\n          for (var k = 0; k < oldCur.length; ++k)\n            { if (oldCur[k].marker == span.marker) { continue spans } }\n          oldCur.push(span);\n        }\n      } else if (stretchCur) {\n        old[i] = stretchCur;\n      }\n    }\n    return old\n  }\n\n  // Used both to provide a JSON-safe object in .getHistory, and, when\n  // detaching a document, to split the history in two\n  function copyHistoryArray(events, newGroup, instantiateSel) {\n    var copy = [];\n    for (var i = 0; i < events.length; ++i) {\n      var event = events[i];\n      if (event.ranges) {\n        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);\n        continue\n      }\n      var changes = event.changes, newChanges = [];\n      copy.push({changes: newChanges});\n      for (var j = 0; j < changes.length; ++j) {\n        var change = changes[j], m = (void 0);\n        newChanges.push({from: change.from, to: change.to, text: change.text});\n        if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\\d+)$/)) {\n          if (indexOf(newGroup, Number(m[1])) > -1) {\n            lst(newChanges)[prop] = change[prop];\n            delete change[prop];\n          }\n        } } }\n      }\n    }\n    return copy\n  }\n\n  // The 'scroll' parameter given to many of these indicated whether\n  // the new cursor position should be scrolled into view after\n  // modifying the selection.\n\n  // If shift is held or the extend flag is set, extends a range to\n  // include a given position (and optionally a second position).\n  // Otherwise, simply returns the range between the given positions.\n  // Used for cursor motion and such.\n  function extendRange(range, head, other, extend) {\n    if (extend) {\n      var anchor = range.anchor;\n      if (other) {\n        var posBefore = cmp(head, anchor) < 0;\n        if (posBefore != (cmp(other, anchor) < 0)) {\n          anchor = head;\n          head = other;\n        } else if (posBefore != (cmp(head, other) < 0)) {\n          head = other;\n        }\n      }\n      return new Range(anchor, head)\n    } else {\n      return new Range(other || head, head)\n    }\n  }\n\n  // Extend the primary selection range, discard the rest.\n  function extendSelection(doc, head, other, options, extend) {\n    if (extend == null) { extend = doc.cm && (doc.cm.display.shift || doc.extend); }\n    setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);\n  }\n\n  // Extend all selections (pos is an array of selections with length\n  // equal the number of selections)\n  function extendSelections(doc, heads, options) {\n    var out = [];\n    var extend = doc.cm && (doc.cm.display.shift || doc.extend);\n    for (var i = 0; i < doc.sel.ranges.length; i++)\n      { out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend); }\n    var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);\n    setSelection(doc, newSel, options);\n  }\n\n  // Updates a single range in the selection.\n  function replaceOneSelection(doc, i, range, options) {\n    var ranges = doc.sel.ranges.slice(0);\n    ranges[i] = range;\n    setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);\n  }\n\n  // Reset the selection to a single range.\n  function setSimpleSelection(doc, anchor, head, options) {\n    setSelection(doc, simpleSelection(anchor, head), options);\n  }\n\n  // Give beforeSelectionChange handlers a change to influence a\n  // selection update.\n  function filterSelectionChange(doc, sel, options) {\n    var obj = {\n      ranges: sel.ranges,\n      update: function(ranges) {\n        var this$1 = this;\n\n        this.ranges = [];\n        for (var i = 0; i < ranges.length; i++)\n          { this$1.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),\n                                     clipPos(doc, ranges[i].head)); }\n      },\n      origin: options && options.origin\n    };\n    signal(doc, \"beforeSelectionChange\", doc, obj);\n    if (doc.cm) { signal(doc.cm, \"beforeSelectionChange\", doc.cm, obj); }\n    if (obj.ranges != sel.ranges) { return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1) }\n    else { return sel }\n  }\n\n  function setSelectionReplaceHistory(doc, sel, options) {\n    var done = doc.history.done, last = lst(done);\n    if (last && last.ranges) {\n      done[done.length - 1] = sel;\n      setSelectionNoUndo(doc, sel, options);\n    } else {\n      setSelection(doc, sel, options);\n    }\n  }\n\n  // Set a new selection.\n  function setSelection(doc, sel, options) {\n    setSelectionNoUndo(doc, sel, options);\n    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);\n  }\n\n  function setSelectionNoUndo(doc, sel, options) {\n    if (hasHandler(doc, \"beforeSelectionChange\") || doc.cm && hasHandler(doc.cm, \"beforeSelectionChange\"))\n      { sel = filterSelectionChange(doc, sel, options); }\n\n    var bias = options && options.bias ||\n      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);\n    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));\n\n    if (!(options && options.scroll === false) && doc.cm)\n      { ensureCursorVisible(doc.cm); }\n  }\n\n  function setSelectionInner(doc, sel) {\n    if (sel.equals(doc.sel)) { return }\n\n    doc.sel = sel;\n\n    if (doc.cm) {\n      doc.cm.curOp.updateInput = 1;\n      doc.cm.curOp.selectionChanged = true;\n      signalCursorActivity(doc.cm);\n    }\n    signalLater(doc, \"cursorActivity\", doc);\n  }\n\n  // Verify that the selection does not partially select any atomic\n  // marked ranges.\n  function reCheckSelection(doc) {\n    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));\n  }\n\n  // Return a selection that does not partially select any atomic\n  // ranges.\n  function skipAtomicInSelection(doc, sel, bias, mayClear) {\n    var out;\n    for (var i = 0; i < sel.ranges.length; i++) {\n      var range = sel.ranges[i];\n      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];\n      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);\n      var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);\n      if (out || newAnchor != range.anchor || newHead != range.head) {\n        if (!out) { out = sel.ranges.slice(0, i); }\n        out[i] = new Range(newAnchor, newHead);\n      }\n    }\n    return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel\n  }\n\n  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {\n    var line = getLine(doc, pos.line);\n    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {\n      var sp = line.markedSpans[i], m = sp.marker;\n      if ((sp.from == null || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&\n          (sp.to == null || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {\n        if (mayClear) {\n          signal(m, \"beforeCursorEnter\");\n          if (m.explicitlyCleared) {\n            if (!line.markedSpans) { break }\n            else {--i; continue}\n          }\n        }\n        if (!m.atomic) { continue }\n\n        if (oldPos) {\n          var near = m.find(dir < 0 ? 1 : -1), diff = (void 0);\n          if (dir < 0 ? m.inclusiveRight : m.inclusiveLeft)\n            { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }\n          if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))\n            { return skipAtomicInner(doc, near, pos, dir, mayClear) }\n        }\n\n        var far = m.find(dir < 0 ? -1 : 1);\n        if (dir < 0 ? m.inclusiveLeft : m.inclusiveRight)\n          { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }\n        return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null\n      }\n    } }\n    return pos\n  }\n\n  // Ensure a given position is not inside an atomic range.\n  function skipAtomic(doc, pos, oldPos, bias, mayClear) {\n    var dir = bias || 1;\n    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||\n        (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||\n        skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||\n        (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));\n    if (!found) {\n      doc.cantEdit = true;\n      return Pos(doc.first, 0)\n    }\n    return found\n  }\n\n  function movePos(doc, pos, dir, line) {\n    if (dir < 0 && pos.ch == 0) {\n      if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }\n      else { return null }\n    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {\n      if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }\n      else { return null }\n    } else {\n      return new Pos(pos.line, pos.ch + dir)\n    }\n  }\n\n  function selectAll(cm) {\n    cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);\n  }\n\n  // UPDATING\n\n  // Allow \"beforeChange\" event handlers to influence a change\n  function filterChange(doc, change, update) {\n    var obj = {\n      canceled: false,\n      from: change.from,\n      to: change.to,\n      text: change.text,\n      origin: change.origin,\n      cancel: function () { return obj.canceled = true; }\n    };\n    if (update) { obj.update = function (from, to, text, origin) {\n      if (from) { obj.from = clipPos(doc, from); }\n      if (to) { obj.to = clipPos(doc, to); }\n      if (text) { obj.text = text; }\n      if (origin !== undefined) { obj.origin = origin; }\n    }; }\n    signal(doc, \"beforeChange\", doc, obj);\n    if (doc.cm) { signal(doc.cm, \"beforeChange\", doc.cm, obj); }\n\n    if (obj.canceled) {\n      if (doc.cm) { doc.cm.curOp.updateInput = 2; }\n      return null\n    }\n    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}\n  }\n\n  // Apply a change to a document, and add it to the document's\n  // history, and propagating it to all linked documents.\n  function makeChange(doc, change, ignoreReadOnly) {\n    if (doc.cm) {\n      if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }\n      if (doc.cm.state.suppressEdits) { return }\n    }\n\n    if (hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\")) {\n      change = filterChange(doc, change, true);\n      if (!change) { return }\n    }\n\n    // Possibly split or suppress the update based on the presence\n    // of read-only spans in its range.\n    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);\n    if (split) {\n      for (var i = split.length - 1; i >= 0; --i)\n        { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [\"\"] : change.text, origin: change.origin}); }\n    } else {\n      makeChangeInner(doc, change);\n    }\n  }\n\n  function makeChangeInner(doc, change) {\n    if (change.text.length == 1 && change.text[0] == \"\" && cmp(change.from, change.to) == 0) { return }\n    var selAfter = computeSelAfterChange(doc, change);\n    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);\n\n    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));\n    var rebased = [];\n\n    linkedDocs(doc, function (doc, sharedHist) {\n      if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n        rebaseHist(doc.history, change);\n        rebased.push(doc.history);\n      }\n      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));\n    });\n  }\n\n  // Revert a change stored in a document's history.\n  function makeChangeFromHistory(doc, type, allowSelectionOnly) {\n    var suppress = doc.cm && doc.cm.state.suppressEdits;\n    if (suppress && !allowSelectionOnly) { return }\n\n    var hist = doc.history, event, selAfter = doc.sel;\n    var source = type == \"undo\" ? hist.done : hist.undone, dest = type == \"undo\" ? hist.undone : hist.done;\n\n    // Verify that there is a useable event (so that ctrl-z won't\n    // needlessly clear selection events)\n    var i = 0;\n    for (; i < source.length; i++) {\n      event = source[i];\n      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)\n        { break }\n    }\n    if (i == source.length) { return }\n    hist.lastOrigin = hist.lastSelOrigin = null;\n\n    for (;;) {\n      event = source.pop();\n      if (event.ranges) {\n        pushSelectionToHistory(event, dest);\n        if (allowSelectionOnly && !event.equals(doc.sel)) {\n          setSelection(doc, event, {clearRedo: false});\n          return\n        }\n        selAfter = event;\n      } else if (suppress) {\n        source.push(event);\n        return\n      } else { break }\n    }\n\n    // Build up a reverse change object to add to the opposite history\n    // stack (redo when undoing, and vice versa).\n    var antiChanges = [];\n    pushSelectionToHistory(selAfter, dest);\n    dest.push({changes: antiChanges, generation: hist.generation});\n    hist.generation = event.generation || ++hist.maxGeneration;\n\n    var filter = hasHandler(doc, \"beforeChange\") || doc.cm && hasHandler(doc.cm, \"beforeChange\");\n\n    var loop = function ( i ) {\n      var change = event.changes[i];\n      change.origin = type;\n      if (filter && !filterChange(doc, change, false)) {\n        source.length = 0;\n        return {}\n      }\n\n      antiChanges.push(historyChangeFromChange(doc, change));\n\n      var after = i ? computeSelAfterChange(doc, change) : lst(source);\n      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));\n      if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }\n      var rebased = [];\n\n      // Propagate to the linked documents\n      linkedDocs(doc, function (doc, sharedHist) {\n        if (!sharedHist && indexOf(rebased, doc.history) == -1) {\n          rebaseHist(doc.history, change);\n          rebased.push(doc.history);\n        }\n        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));\n      });\n    };\n\n    for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {\n      var returned = loop( i$1 );\n\n      if ( returned ) return returned.v;\n    }\n  }\n\n  // Sub-views need their line numbers shifted when text is added\n  // above or below them in the parent document.\n  function shiftDoc(doc, distance) {\n    if (distance == 0) { return }\n    doc.first += distance;\n    doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(\n      Pos(range.anchor.line + distance, range.anchor.ch),\n      Pos(range.head.line + distance, range.head.ch)\n    ); }), doc.sel.primIndex);\n    if (doc.cm) {\n      regChange(doc.cm, doc.first, doc.first - distance, distance);\n      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)\n        { regLineChange(doc.cm, l, \"gutter\"); }\n    }\n  }\n\n  // More lower-level change function, handling only a single document\n  // (not linked ones).\n  function makeChangeSingleDoc(doc, change, selAfter, spans) {\n    if (doc.cm && !doc.cm.curOp)\n      { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }\n\n    if (change.to.line < doc.first) {\n      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));\n      return\n    }\n    if (change.from.line > doc.lastLine()) { return }\n\n    // Clip the change to the size of this doc\n    if (change.from.line < doc.first) {\n      var shift = change.text.length - 1 - (doc.first - change.from.line);\n      shiftDoc(doc, shift);\n      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),\n                text: [lst(change.text)], origin: change.origin};\n    }\n    var last = doc.lastLine();\n    if (change.to.line > last) {\n      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),\n                text: [change.text[0]], origin: change.origin};\n    }\n\n    change.removed = getBetween(doc, change.from, change.to);\n\n    if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }\n    if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }\n    else { updateDoc(doc, change, spans); }\n    setSelectionNoUndo(doc, selAfter, sel_dontScroll);\n  }\n\n  // Handle the interaction of a change to a document with the editor\n  // that this document is part of.\n  function makeChangeSingleDocInEditor(cm, change, spans) {\n    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;\n\n    var recomputeMaxLength = false, checkWidthStart = from.line;\n    if (!cm.options.lineWrapping) {\n      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));\n      doc.iter(checkWidthStart, to.line + 1, function (line) {\n        if (line == display.maxLine) {\n          recomputeMaxLength = true;\n          return true\n        }\n      });\n    }\n\n    if (doc.sel.contains(change.from, change.to) > -1)\n      { signalCursorActivity(cm); }\n\n    updateDoc(doc, change, spans, estimateHeight(cm));\n\n    if (!cm.options.lineWrapping) {\n      doc.iter(checkWidthStart, from.line + change.text.length, function (line) {\n        var len = lineLength(line);\n        if (len > display.maxLineLength) {\n          display.maxLine = line;\n          display.maxLineLength = len;\n          display.maxLineChanged = true;\n          recomputeMaxLength = false;\n        }\n      });\n      if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }\n    }\n\n    retreatFrontier(doc, from.line);\n    startWorker(cm, 400);\n\n    var lendiff = change.text.length - (to.line - from.line) - 1;\n    // Remember that these lines changed, for updating the display\n    if (change.full)\n      { regChange(cm); }\n    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))\n      { regLineChange(cm, from.line, \"text\"); }\n    else\n      { regChange(cm, from.line, to.line + 1, lendiff); }\n\n    var changesHandler = hasHandler(cm, \"changes\"), changeHandler = hasHandler(cm, \"change\");\n    if (changeHandler || changesHandler) {\n      var obj = {\n        from: from, to: to,\n        text: change.text,\n        removed: change.removed,\n        origin: change.origin\n      };\n      if (changeHandler) { signalLater(cm, \"change\", cm, obj); }\n      if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }\n    }\n    cm.display.selForContextMenu = null;\n  }\n\n  function replaceRange(doc, code, from, to, origin) {\n    var assign;\n\n    if (!to) { to = from; }\n    if (cmp(to, from) < 0) { (assign = [to, from], from = assign[0], to = assign[1]); }\n    if (typeof code == \"string\") { code = doc.splitLines(code); }\n    makeChange(doc, {from: from, to: to, text: code, origin: origin});\n  }\n\n  // Rebasing/resetting history to deal with externally-sourced changes\n\n  function rebaseHistSelSingle(pos, from, to, diff) {\n    if (to < pos.line) {\n      pos.line += diff;\n    } else if (from < pos.line) {\n      pos.line = from;\n      pos.ch = 0;\n    }\n  }\n\n  // Tries to rebase an array of history events given a change in the\n  // document. If the change touches the same lines as the event, the\n  // event, and everything 'behind' it, is discarded. If the change is\n  // before the event, the event's positions are updated. Uses a\n  // copy-on-write scheme for the positions, to avoid having to\n  // reallocate them all on every rebase, but also avoid problems with\n  // shared position objects being unsafely updated.\n  function rebaseHistArray(array, from, to, diff) {\n    for (var i = 0; i < array.length; ++i) {\n      var sub = array[i], ok = true;\n      if (sub.ranges) {\n        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }\n        for (var j = 0; j < sub.ranges.length; j++) {\n          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);\n          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);\n        }\n        continue\n      }\n      for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {\n        var cur = sub.changes[j$1];\n        if (to < cur.from.line) {\n          cur.from = Pos(cur.from.line + diff, cur.from.ch);\n          cur.to = Pos(cur.to.line + diff, cur.to.ch);\n        } else if (from <= cur.to.line) {\n          ok = false;\n          break\n        }\n      }\n      if (!ok) {\n        array.splice(0, i + 1);\n        i = 0;\n      }\n    }\n  }\n\n  function rebaseHist(hist, change) {\n    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;\n    rebaseHistArray(hist.done, from, to, diff);\n    rebaseHistArray(hist.undone, from, to, diff);\n  }\n\n  // Utility for applying a change to a line by handle or number,\n  // returning the number and optionally registering the line as\n  // changed.\n  function changeLine(doc, handle, changeType, op) {\n    var no = handle, line = handle;\n    if (typeof handle == \"number\") { line = getLine(doc, clipLine(doc, handle)); }\n    else { no = lineNo(handle); }\n    if (no == null) { return null }\n    if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }\n    return line\n  }\n\n  // The document is represented as a BTree consisting of leaves, with\n  // chunk of lines in them, and branches, with up to ten leaves or\n  // other branch nodes below them. The top node is always a branch\n  // node, and is the document object itself (meaning it has\n  // additional methods and properties).\n  //\n  // All nodes have parent links. The tree is used both to go from\n  // line numbers to line objects, and to go from objects to numbers.\n  // It also indexes by height, and is used to convert between height\n  // and line object, and to find the total height of the document.\n  //\n  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html\n\n  function LeafChunk(lines) {\n    var this$1 = this;\n\n    this.lines = lines;\n    this.parent = null;\n    var height = 0;\n    for (var i = 0; i < lines.length; ++i) {\n      lines[i].parent = this$1;\n      height += lines[i].height;\n    }\n    this.height = height;\n  }\n\n  LeafChunk.prototype = {\n    chunkSize: function() { return this.lines.length },\n\n    // Remove the n lines at offset 'at'.\n    removeInner: function(at, n) {\n      var this$1 = this;\n\n      for (var i = at, e = at + n; i < e; ++i) {\n        var line = this$1.lines[i];\n        this$1.height -= line.height;\n        cleanUpLine(line);\n        signalLater(line, \"delete\");\n      }\n      this.lines.splice(at, n);\n    },\n\n    // Helper used to collapse a small branch into a single leaf.\n    collapse: function(lines) {\n      lines.push.apply(lines, this.lines);\n    },\n\n    // Insert the given array of lines at offset 'at', count them as\n    // having the given height.\n    insertInner: function(at, lines, height) {\n      var this$1 = this;\n\n      this.height += height;\n      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));\n      for (var i = 0; i < lines.length; ++i) { lines[i].parent = this$1; }\n    },\n\n    // Used to iterate over a part of the tree.\n    iterN: function(at, n, op) {\n      var this$1 = this;\n\n      for (var e = at + n; at < e; ++at)\n        { if (op(this$1.lines[at])) { return true } }\n    }\n  };\n\n  function BranchChunk(children) {\n    var this$1 = this;\n\n    this.children = children;\n    var size = 0, height = 0;\n    for (var i = 0; i < children.length; ++i) {\n      var ch = children[i];\n      size += ch.chunkSize(); height += ch.height;\n      ch.parent = this$1;\n    }\n    this.size = size;\n    this.height = height;\n    this.parent = null;\n  }\n\n  BranchChunk.prototype = {\n    chunkSize: function() { return this.size },\n\n    removeInner: function(at, n) {\n      var this$1 = this;\n\n      this.size -= n;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this$1.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var rm = Math.min(n, sz - at), oldHeight = child.height;\n          child.removeInner(at, rm);\n          this$1.height -= oldHeight - child.height;\n          if (sz == rm) { this$1.children.splice(i--, 1); child.parent = null; }\n          if ((n -= rm) == 0) { break }\n          at = 0;\n        } else { at -= sz; }\n      }\n      // If the result is smaller than 25 lines, ensure that it is a\n      // single leaf node.\n      if (this.size - n < 25 &&\n          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {\n        var lines = [];\n        this.collapse(lines);\n        this.children = [new LeafChunk(lines)];\n        this.children[0].parent = this;\n      }\n    },\n\n    collapse: function(lines) {\n      var this$1 = this;\n\n      for (var i = 0; i < this.children.length; ++i) { this$1.children[i].collapse(lines); }\n    },\n\n    insertInner: function(at, lines, height) {\n      var this$1 = this;\n\n      this.size += lines.length;\n      this.height += height;\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this$1.children[i], sz = child.chunkSize();\n        if (at <= sz) {\n          child.insertInner(at, lines, height);\n          if (child.lines && child.lines.length > 50) {\n            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.\n            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.\n            var remaining = child.lines.length % 25 + 25;\n            for (var pos = remaining; pos < child.lines.length;) {\n              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));\n              child.height -= leaf.height;\n              this$1.children.splice(++i, 0, leaf);\n              leaf.parent = this$1;\n            }\n            child.lines = child.lines.slice(0, remaining);\n            this$1.maybeSpill();\n          }\n          break\n        }\n        at -= sz;\n      }\n    },\n\n    // When a node has grown, check whether it should be split.\n    maybeSpill: function() {\n      if (this.children.length <= 10) { return }\n      var me = this;\n      do {\n        var spilled = me.children.splice(me.children.length - 5, 5);\n        var sibling = new BranchChunk(spilled);\n        if (!me.parent) { // Become the parent node\n          var copy = new BranchChunk(me.children);\n          copy.parent = me;\n          me.children = [copy, sibling];\n          me = copy;\n       } else {\n          me.size -= sibling.size;\n          me.height -= sibling.height;\n          var myIndex = indexOf(me.parent.children, me);\n          me.parent.children.splice(myIndex + 1, 0, sibling);\n        }\n        sibling.parent = me.parent;\n      } while (me.children.length > 10)\n      me.parent.maybeSpill();\n    },\n\n    iterN: function(at, n, op) {\n      var this$1 = this;\n\n      for (var i = 0; i < this.children.length; ++i) {\n        var child = this$1.children[i], sz = child.chunkSize();\n        if (at < sz) {\n          var used = Math.min(n, sz - at);\n          if (child.iterN(at, used, op)) { return true }\n          if ((n -= used) == 0) { break }\n          at = 0;\n        } else { at -= sz; }\n      }\n    }\n  };\n\n  // Line widgets are block elements displayed above or below a line.\n\n  var LineWidget = function(doc, node, options) {\n    var this$1 = this;\n\n    if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))\n      { this$1[opt] = options[opt]; } } }\n    this.doc = doc;\n    this.node = node;\n  };\n\n  LineWidget.prototype.clear = function () {\n      var this$1 = this;\n\n    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);\n    if (no == null || !ws) { return }\n    for (var i = 0; i < ws.length; ++i) { if (ws[i] == this$1) { ws.splice(i--, 1); } }\n    if (!ws.length) { line.widgets = null; }\n    var height = widgetHeight(this);\n    updateLineHeight(line, Math.max(0, line.height - height));\n    if (cm) {\n      runInOp(cm, function () {\n        adjustScrollWhenAboveVisible(cm, line, -height);\n        regLineChange(cm, no, \"widget\");\n      });\n      signalLater(cm, \"lineWidgetCleared\", cm, this, no);\n    }\n  };\n\n  LineWidget.prototype.changed = function () {\n      var this$1 = this;\n\n    var oldH = this.height, cm = this.doc.cm, line = this.line;\n    this.height = null;\n    var diff = widgetHeight(this) - oldH;\n    if (!diff) { return }\n    if (!lineIsHidden(this.doc, line)) { updateLineHeight(line, line.height + diff); }\n    if (cm) {\n      runInOp(cm, function () {\n        cm.curOp.forceUpdate = true;\n        adjustScrollWhenAboveVisible(cm, line, diff);\n        signalLater(cm, \"lineWidgetChanged\", cm, this$1, lineNo(line));\n      });\n    }\n  };\n  eventMixin(LineWidget);\n\n  function adjustScrollWhenAboveVisible(cm, line, diff) {\n    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))\n      { addToScrollTop(cm, diff); }\n  }\n\n  function addLineWidget(doc, handle, node, options) {\n    var widget = new LineWidget(doc, node, options);\n    var cm = doc.cm;\n    if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }\n    changeLine(doc, handle, \"widget\", function (line) {\n      var widgets = line.widgets || (line.widgets = []);\n      if (widget.insertAt == null) { widgets.push(widget); }\n      else { widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget); }\n      widget.line = line;\n      if (cm && !lineIsHidden(doc, line)) {\n        var aboveVisible = heightAtLine(line) < doc.scrollTop;\n        updateLineHeight(line, line.height + widgetHeight(widget));\n        if (aboveVisible) { addToScrollTop(cm, widget.height); }\n        cm.curOp.forceUpdate = true;\n      }\n      return true\n    });\n    if (cm) { signalLater(cm, \"lineWidgetAdded\", cm, widget, typeof handle == \"number\" ? handle : lineNo(handle)); }\n    return widget\n  }\n\n  // TEXTMARKERS\n\n  // Created with markText and setBookmark methods. A TextMarker is a\n  // handle that can be used to clear or find a marked position in the\n  // document. Line objects hold arrays (markedSpans) containing\n  // {from, to, marker} object pointing to such marker objects, and\n  // indicating that such a marker is present on that line. Multiple\n  // lines may point to the same marker when it spans across lines.\n  // The spans will have null for their from/to properties when the\n  // marker continues beyond the start/end of the line. Markers have\n  // links back to the lines they currently touch.\n\n  // Collapsed markers have unique ids, in order to be able to order\n  // them, which is needed for uniquely determining an outer marker\n  // when they overlap (they may nest, but not partially overlap).\n  var nextMarkerId = 0;\n\n  var TextMarker = function(doc, type) {\n    this.lines = [];\n    this.type = type;\n    this.doc = doc;\n    this.id = ++nextMarkerId;\n  };\n\n  // Clear the marker.\n  TextMarker.prototype.clear = function () {\n      var this$1 = this;\n\n    if (this.explicitlyCleared) { return }\n    var cm = this.doc.cm, withOp = cm && !cm.curOp;\n    if (withOp) { startOperation(cm); }\n    if (hasHandler(this, \"clear\")) {\n      var found = this.find();\n      if (found) { signalLater(this, \"clear\", found.from, found.to); }\n    }\n    var min = null, max = null;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this$1.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this$1);\n      if (cm && !this$1.collapsed) { regLineChange(cm, lineNo(line), \"text\"); }\n      else if (cm) {\n        if (span.to != null) { max = lineNo(line); }\n        if (span.from != null) { min = lineNo(line); }\n      }\n      line.markedSpans = removeMarkedSpan(line.markedSpans, span);\n      if (span.from == null && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm)\n        { updateLineHeight(line, textHeight(cm.display)); }\n    }\n    if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {\n      var visual = visualLine(this$1.lines[i$1]), len = lineLength(visual);\n      if (len > cm.display.maxLineLength) {\n        cm.display.maxLine = visual;\n        cm.display.maxLineLength = len;\n        cm.display.maxLineChanged = true;\n      }\n    } }\n\n    if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }\n    this.lines.length = 0;\n    this.explicitlyCleared = true;\n    if (this.atomic && this.doc.cantEdit) {\n      this.doc.cantEdit = false;\n      if (cm) { reCheckSelection(cm.doc); }\n    }\n    if (cm) { signalLater(cm, \"markerCleared\", cm, this, min, max); }\n    if (withOp) { endOperation(cm); }\n    if (this.parent) { this.parent.clear(); }\n  };\n\n  // Find the position of the marker in the document. Returns a {from,\n  // to} object by default. Side can be passed to get a specific side\n  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the\n  // Pos objects returned contain a line object, rather than a line\n  // number (used to prevent looking up the same line twice).\n  TextMarker.prototype.find = function (side, lineObj) {\n      var this$1 = this;\n\n    if (side == null && this.type == \"bookmark\") { side = 1; }\n    var from, to;\n    for (var i = 0; i < this.lines.length; ++i) {\n      var line = this$1.lines[i];\n      var span = getMarkedSpanFor(line.markedSpans, this$1);\n      if (span.from != null) {\n        from = Pos(lineObj ? line : lineNo(line), span.from);\n        if (side == -1) { return from }\n      }\n      if (span.to != null) {\n        to = Pos(lineObj ? line : lineNo(line), span.to);\n        if (side == 1) { return to }\n      }\n    }\n    return from && {from: from, to: to}\n  };\n\n  // Signals that the marker's widget changed, and surrounding layout\n  // should be recomputed.\n  TextMarker.prototype.changed = function () {\n      var this$1 = this;\n\n    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;\n    if (!pos || !cm) { return }\n    runInOp(cm, function () {\n      var line = pos.line, lineN = lineNo(pos.line);\n      var view = findViewForLine(cm, lineN);\n      if (view) {\n        clearLineMeasurementCacheFor(view);\n        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;\n      }\n      cm.curOp.updateMaxLine = true;\n      if (!lineIsHidden(widget.doc, line) && widget.height != null) {\n        var oldHeight = widget.height;\n        widget.height = null;\n        var dHeight = widgetHeight(widget) - oldHeight;\n        if (dHeight)\n          { updateLineHeight(line, line.height + dHeight); }\n      }\n      signalLater(cm, \"markerChanged\", cm, this$1);\n    });\n  };\n\n  TextMarker.prototype.attachLine = function (line) {\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp;\n      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)\n        { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }\n    }\n    this.lines.push(line);\n  };\n\n  TextMarker.prototype.detachLine = function (line) {\n    this.lines.splice(indexOf(this.lines, line), 1);\n    if (!this.lines.length && this.doc.cm) {\n      var op = this.doc.cm.curOp\n      ;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);\n    }\n  };\n  eventMixin(TextMarker);\n\n  // Create a marker, wire it up to the right lines, and\n  function markText(doc, from, to, options, type) {\n    // Shared markers (across linked documents) are handled separately\n    // (markTextShared will call out to this again, once per\n    // document).\n    if (options && options.shared) { return markTextShared(doc, from, to, options, type) }\n    // Ensure we are in an operation.\n    if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }\n\n    var marker = new TextMarker(doc, type), diff = cmp(from, to);\n    if (options) { copyObj(options, marker, false); }\n    // Don't connect empty markers unless clearWhenEmpty is false\n    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)\n      { return marker }\n    if (marker.replacedWith) {\n      // Showing up as a widget implies collapsed (widget replaces text)\n      marker.collapsed = true;\n      marker.widgetNode = eltP(\"span\", [marker.replacedWith], \"CodeMirror-widget\");\n      if (!options.handleMouseEvents) { marker.widgetNode.setAttribute(\"cm-ignore-events\", \"true\"); }\n      if (options.insertLeft) { marker.widgetNode.insertLeft = true; }\n    }\n    if (marker.collapsed) {\n      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||\n          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))\n        { throw new Error(\"Inserting collapsed marker partially overlapping an existing one\") }\n      seeCollapsedSpans();\n    }\n\n    if (marker.addToHistory)\n      { addChangeToHistory(doc, {from: from, to: to, origin: \"markText\"}, doc.sel, NaN); }\n\n    var curLine = from.line, cm = doc.cm, updateMaxLine;\n    doc.iter(curLine, to.line + 1, function (line) {\n      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)\n        { updateMaxLine = true; }\n      if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }\n      addMarkedSpan(line, new MarkedSpan(marker,\n                                         curLine == from.line ? from.ch : null,\n                                         curLine == to.line ? to.ch : null));\n      ++curLine;\n    });\n    // lineIsHidden depends on the presence of the spans, so needs a second pass\n    if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {\n      if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }\n    }); }\n\n    if (marker.clearOnEnter) { on(marker, \"beforeCursorEnter\", function () { return marker.clear(); }); }\n\n    if (marker.readOnly) {\n      seeReadOnlySpans();\n      if (doc.history.done.length || doc.history.undone.length)\n        { doc.clearHistory(); }\n    }\n    if (marker.collapsed) {\n      marker.id = ++nextMarkerId;\n      marker.atomic = true;\n    }\n    if (cm) {\n      // Sync editor state\n      if (updateMaxLine) { cm.curOp.updateMaxLine = true; }\n      if (marker.collapsed)\n        { regChange(cm, from.line, to.line + 1); }\n      else if (marker.className || marker.startStyle || marker.endStyle || marker.css ||\n               marker.attributes || marker.title)\n        { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, \"text\"); } }\n      if (marker.atomic) { reCheckSelection(cm.doc); }\n      signalLater(cm, \"markerAdded\", cm, marker);\n    }\n    return marker\n  }\n\n  // SHARED TEXTMARKERS\n\n  // A shared marker spans multiple linked documents. It is\n  // implemented as a meta-marker-object controlling multiple normal\n  // markers.\n  var SharedTextMarker = function(markers, primary) {\n    var this$1 = this;\n\n    this.markers = markers;\n    this.primary = primary;\n    for (var i = 0; i < markers.length; ++i)\n      { markers[i].parent = this$1; }\n  };\n\n  SharedTextMarker.prototype.clear = function () {\n      var this$1 = this;\n\n    if (this.explicitlyCleared) { return }\n    this.explicitlyCleared = true;\n    for (var i = 0; i < this.markers.length; ++i)\n      { this$1.markers[i].clear(); }\n    signalLater(this, \"clear\");\n  };\n\n  SharedTextMarker.prototype.find = function (side, lineObj) {\n    return this.primary.find(side, lineObj)\n  };\n  eventMixin(SharedTextMarker);\n\n  function markTextShared(doc, from, to, options, type) {\n    options = copyObj(options);\n    options.shared = false;\n    var markers = [markText(doc, from, to, options, type)], primary = markers[0];\n    var widget = options.widgetNode;\n    linkedDocs(doc, function (doc) {\n      if (widget) { options.widgetNode = widget.cloneNode(true); }\n      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));\n      for (var i = 0; i < doc.linked.length; ++i)\n        { if (doc.linked[i].isParent) { return } }\n      primary = lst(markers);\n    });\n    return new SharedTextMarker(markers, primary)\n  }\n\n  function findSharedMarkers(doc) {\n    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })\n  }\n\n  function copySharedMarkers(doc, markers) {\n    for (var i = 0; i < markers.length; i++) {\n      var marker = markers[i], pos = marker.find();\n      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);\n      if (cmp(mFrom, mTo)) {\n        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);\n        marker.markers.push(subMark);\n        subMark.parent = marker;\n      }\n    }\n  }\n\n  function detachSharedMarkers(markers) {\n    var loop = function ( i ) {\n      var marker = markers[i], linked = [marker.primary.doc];\n      linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });\n      for (var j = 0; j < marker.markers.length; j++) {\n        var subMarker = marker.markers[j];\n        if (indexOf(linked, subMarker.doc) == -1) {\n          subMarker.parent = null;\n          marker.markers.splice(j--, 1);\n        }\n      }\n    };\n\n    for (var i = 0; i < markers.length; i++) loop( i );\n  }\n\n  var nextDocId = 0;\n  var Doc = function(text, mode, firstLine, lineSep, direction) {\n    if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }\n    if (firstLine == null) { firstLine = 0; }\n\n    BranchChunk.call(this, [new LeafChunk([new Line(\"\", null)])]);\n    this.first = firstLine;\n    this.scrollTop = this.scrollLeft = 0;\n    this.cantEdit = false;\n    this.cleanGeneration = 1;\n    this.modeFrontier = this.highlightFrontier = firstLine;\n    var start = Pos(firstLine, 0);\n    this.sel = simpleSelection(start);\n    this.history = new History(null);\n    this.id = ++nextDocId;\n    this.modeOption = mode;\n    this.lineSep = lineSep;\n    this.direction = (direction == \"rtl\") ? \"rtl\" : \"ltr\";\n    this.extend = false;\n\n    if (typeof text == \"string\") { text = this.splitLines(text); }\n    updateDoc(this, {from: start, to: start, text: text});\n    setSelection(this, simpleSelection(start), sel_dontScroll);\n  };\n\n  Doc.prototype = createObj(BranchChunk.prototype, {\n    constructor: Doc,\n    // Iterate over the document. Supports two forms -- with only one\n    // argument, it calls that for each line in the document. With\n    // three, it iterates over the range given by the first two (with\n    // the second being non-inclusive).\n    iter: function(from, to, op) {\n      if (op) { this.iterN(from - this.first, to - from, op); }\n      else { this.iterN(this.first, this.first + this.size, from); }\n    },\n\n    // Non-public interface for adding and removing lines.\n    insert: function(at, lines) {\n      var height = 0;\n      for (var i = 0; i < lines.length; ++i) { height += lines[i].height; }\n      this.insertInner(at - this.first, lines, height);\n    },\n    remove: function(at, n) { this.removeInner(at - this.first, n); },\n\n    // From here, the methods are part of the public interface. Most\n    // are also available from CodeMirror (editor) instances.\n\n    getValue: function(lineSep) {\n      var lines = getLines(this, this.first, this.first + this.size);\n      if (lineSep === false) { return lines }\n      return lines.join(lineSep || this.lineSeparator())\n    },\n    setValue: docMethodOp(function(code) {\n      var top = Pos(this.first, 0), last = this.first + this.size - 1;\n      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),\n                        text: this.splitLines(code), origin: \"setValue\", full: true}, true);\n      if (this.cm) { scrollToCoords(this.cm, 0, 0); }\n      setSelection(this, simpleSelection(top), sel_dontScroll);\n    }),\n    replaceRange: function(code, from, to, origin) {\n      from = clipPos(this, from);\n      to = to ? clipPos(this, to) : from;\n      replaceRange(this, code, from, to, origin);\n    },\n    getRange: function(from, to, lineSep) {\n      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));\n      if (lineSep === false) { return lines }\n      return lines.join(lineSep || this.lineSeparator())\n    },\n\n    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},\n\n    getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},\n    getLineNumber: function(line) {return lineNo(line)},\n\n    getLineHandleVisualStart: function(line) {\n      if (typeof line == \"number\") { line = getLine(this, line); }\n      return visualLine(line)\n    },\n\n    lineCount: function() {return this.size},\n    firstLine: function() {return this.first},\n    lastLine: function() {return this.first + this.size - 1},\n\n    clipPos: function(pos) {return clipPos(this, pos)},\n\n    getCursor: function(start) {\n      var range$$1 = this.sel.primary(), pos;\n      if (start == null || start == \"head\") { pos = range$$1.head; }\n      else if (start == \"anchor\") { pos = range$$1.anchor; }\n      else if (start == \"end\" || start == \"to\" || start === false) { pos = range$$1.to(); }\n      else { pos = range$$1.from(); }\n      return pos\n    },\n    listSelections: function() { return this.sel.ranges },\n    somethingSelected: function() {return this.sel.somethingSelected()},\n\n    setCursor: docMethodOp(function(line, ch, options) {\n      setSimpleSelection(this, clipPos(this, typeof line == \"number\" ? Pos(line, ch || 0) : line), null, options);\n    }),\n    setSelection: docMethodOp(function(anchor, head, options) {\n      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);\n    }),\n    extendSelection: docMethodOp(function(head, other, options) {\n      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);\n    }),\n    extendSelections: docMethodOp(function(heads, options) {\n      extendSelections(this, clipPosArray(this, heads), options);\n    }),\n    extendSelectionsBy: docMethodOp(function(f, options) {\n      var heads = map(this.sel.ranges, f);\n      extendSelections(this, clipPosArray(this, heads), options);\n    }),\n    setSelections: docMethodOp(function(ranges, primary, options) {\n      var this$1 = this;\n\n      if (!ranges.length) { return }\n      var out = [];\n      for (var i = 0; i < ranges.length; i++)\n        { out[i] = new Range(clipPos(this$1, ranges[i].anchor),\n                           clipPos(this$1, ranges[i].head)); }\n      if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }\n      setSelection(this, normalizeSelection(this.cm, out, primary), options);\n    }),\n    addSelection: docMethodOp(function(anchor, head, options) {\n      var ranges = this.sel.ranges.slice(0);\n      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));\n      setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);\n    }),\n\n    getSelection: function(lineSep) {\n      var this$1 = this;\n\n      var ranges = this.sel.ranges, lines;\n      for (var i = 0; i < ranges.length; i++) {\n        var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());\n        lines = lines ? lines.concat(sel) : sel;\n      }\n      if (lineSep === false) { return lines }\n      else { return lines.join(lineSep || this.lineSeparator()) }\n    },\n    getSelections: function(lineSep) {\n      var this$1 = this;\n\n      var parts = [], ranges = this.sel.ranges;\n      for (var i = 0; i < ranges.length; i++) {\n        var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());\n        if (lineSep !== false) { sel = sel.join(lineSep || this$1.lineSeparator()); }\n        parts[i] = sel;\n      }\n      return parts\n    },\n    replaceSelection: function(code, collapse, origin) {\n      var dup = [];\n      for (var i = 0; i < this.sel.ranges.length; i++)\n        { dup[i] = code; }\n      this.replaceSelections(dup, collapse, origin || \"+input\");\n    },\n    replaceSelections: docMethodOp(function(code, collapse, origin) {\n      var this$1 = this;\n\n      var changes = [], sel = this.sel;\n      for (var i = 0; i < sel.ranges.length; i++) {\n        var range$$1 = sel.ranges[i];\n        changes[i] = {from: range$$1.from(), to: range$$1.to(), text: this$1.splitLines(code[i]), origin: origin};\n      }\n      var newSel = collapse && collapse != \"end\" && computeReplacedSel(this, changes, collapse);\n      for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)\n        { makeChange(this$1, changes[i$1]); }\n      if (newSel) { setSelectionReplaceHistory(this, newSel); }\n      else if (this.cm) { ensureCursorVisible(this.cm); }\n    }),\n    undo: docMethodOp(function() {makeChangeFromHistory(this, \"undo\");}),\n    redo: docMethodOp(function() {makeChangeFromHistory(this, \"redo\");}),\n    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"undo\", true);}),\n    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, \"redo\", true);}),\n\n    setExtending: function(val) {this.extend = val;},\n    getExtending: function() {return this.extend},\n\n    historySize: function() {\n      var hist = this.history, done = 0, undone = 0;\n      for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }\n      for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }\n      return {undo: done, redo: undone}\n    },\n    clearHistory: function() {this.history = new History(this.history.maxGeneration);},\n\n    markClean: function() {\n      this.cleanGeneration = this.changeGeneration(true);\n    },\n    changeGeneration: function(forceSplit) {\n      if (forceSplit)\n        { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }\n      return this.history.generation\n    },\n    isClean: function (gen) {\n      return this.history.generation == (gen || this.cleanGeneration)\n    },\n\n    getHistory: function() {\n      return {done: copyHistoryArray(this.history.done),\n              undone: copyHistoryArray(this.history.undone)}\n    },\n    setHistory: function(histData) {\n      var hist = this.history = new History(this.history.maxGeneration);\n      hist.done = copyHistoryArray(histData.done.slice(0), null, true);\n      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);\n    },\n\n    setGutterMarker: docMethodOp(function(line, gutterID, value) {\n      return changeLine(this, line, \"gutter\", function (line) {\n        var markers = line.gutterMarkers || (line.gutterMarkers = {});\n        markers[gutterID] = value;\n        if (!value && isEmpty(markers)) { line.gutterMarkers = null; }\n        return true\n      })\n    }),\n\n    clearGutter: docMethodOp(function(gutterID) {\n      var this$1 = this;\n\n      this.iter(function (line) {\n        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {\n          changeLine(this$1, line, \"gutter\", function () {\n            line.gutterMarkers[gutterID] = null;\n            if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }\n            return true\n          });\n        }\n      });\n    }),\n\n    lineInfo: function(line) {\n      var n;\n      if (typeof line == \"number\") {\n        if (!isLine(this, line)) { return null }\n        n = line;\n        line = getLine(this, line);\n        if (!line) { return null }\n      } else {\n        n = lineNo(line);\n        if (n == null) { return null }\n      }\n      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,\n              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,\n              widgets: line.widgets}\n    },\n\n    addLineClass: docMethodOp(function(handle, where, cls) {\n      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\n        var prop = where == \"text\" ? \"textClass\"\n                 : where == \"background\" ? \"bgClass\"\n                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n        if (!line[prop]) { line[prop] = cls; }\n        else if (classTest(cls).test(line[prop])) { return false }\n        else { line[prop] += \" \" + cls; }\n        return true\n      })\n    }),\n    removeLineClass: docMethodOp(function(handle, where, cls) {\n      return changeLine(this, handle, where == \"gutter\" ? \"gutter\" : \"class\", function (line) {\n        var prop = where == \"text\" ? \"textClass\"\n                 : where == \"background\" ? \"bgClass\"\n                 : where == \"gutter\" ? \"gutterClass\" : \"wrapClass\";\n        var cur = line[prop];\n        if (!cur) { return false }\n        else if (cls == null) { line[prop] = null; }\n        else {\n          var found = cur.match(classTest(cls));\n          if (!found) { return false }\n          var end = found.index + found[0].length;\n          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? \"\" : \" \") + cur.slice(end) || null;\n        }\n        return true\n      })\n    }),\n\n    addLineWidget: docMethodOp(function(handle, node, options) {\n      return addLineWidget(this, handle, node, options)\n    }),\n    removeLineWidget: function(widget) { widget.clear(); },\n\n    markText: function(from, to, options) {\n      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || \"range\")\n    },\n    setBookmark: function(pos, options) {\n      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),\n                      insertLeft: options && options.insertLeft,\n                      clearWhenEmpty: false, shared: options && options.shared,\n                      handleMouseEvents: options && options.handleMouseEvents};\n      pos = clipPos(this, pos);\n      return markText(this, pos, pos, realOpts, \"bookmark\")\n    },\n    findMarksAt: function(pos) {\n      pos = clipPos(this, pos);\n      var markers = [], spans = getLine(this, pos.line).markedSpans;\n      if (spans) { for (var i = 0; i < spans.length; ++i) {\n        var span = spans[i];\n        if ((span.from == null || span.from <= pos.ch) &&\n            (span.to == null || span.to >= pos.ch))\n          { markers.push(span.marker.parent || span.marker); }\n      } }\n      return markers\n    },\n    findMarks: function(from, to, filter) {\n      from = clipPos(this, from); to = clipPos(this, to);\n      var found = [], lineNo$$1 = from.line;\n      this.iter(from.line, to.line + 1, function (line) {\n        var spans = line.markedSpans;\n        if (spans) { for (var i = 0; i < spans.length; i++) {\n          var span = spans[i];\n          if (!(span.to != null && lineNo$$1 == from.line && from.ch >= span.to ||\n                span.from == null && lineNo$$1 != from.line ||\n                span.from != null && lineNo$$1 == to.line && span.from >= to.ch) &&\n              (!filter || filter(span.marker)))\n            { found.push(span.marker.parent || span.marker); }\n        } }\n        ++lineNo$$1;\n      });\n      return found\n    },\n    getAllMarks: function() {\n      var markers = [];\n      this.iter(function (line) {\n        var sps = line.markedSpans;\n        if (sps) { for (var i = 0; i < sps.length; ++i)\n          { if (sps[i].from != null) { markers.push(sps[i].marker); } } }\n      });\n      return markers\n    },\n\n    posFromIndex: function(off) {\n      var ch, lineNo$$1 = this.first, sepSize = this.lineSeparator().length;\n      this.iter(function (line) {\n        var sz = line.text.length + sepSize;\n        if (sz > off) { ch = off; return true }\n        off -= sz;\n        ++lineNo$$1;\n      });\n      return clipPos(this, Pos(lineNo$$1, ch))\n    },\n    indexFromPos: function (coords) {\n      coords = clipPos(this, coords);\n      var index = coords.ch;\n      if (coords.line < this.first || coords.ch < 0) { return 0 }\n      var sepSize = this.lineSeparator().length;\n      this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value\n        index += line.text.length + sepSize;\n      });\n      return index\n    },\n\n    copy: function(copyHistory) {\n      var doc = new Doc(getLines(this, this.first, this.first + this.size),\n                        this.modeOption, this.first, this.lineSep, this.direction);\n      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;\n      doc.sel = this.sel;\n      doc.extend = false;\n      if (copyHistory) {\n        doc.history.undoDepth = this.history.undoDepth;\n        doc.setHistory(this.getHistory());\n      }\n      return doc\n    },\n\n    linkedDoc: function(options) {\n      if (!options) { options = {}; }\n      var from = this.first, to = this.first + this.size;\n      if (options.from != null && options.from > from) { from = options.from; }\n      if (options.to != null && options.to < to) { to = options.to; }\n      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);\n      if (options.sharedHist) { copy.history = this.history\n      ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});\n      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];\n      copySharedMarkers(copy, findSharedMarkers(this));\n      return copy\n    },\n    unlinkDoc: function(other) {\n      var this$1 = this;\n\n      if (other instanceof CodeMirror) { other = other.doc; }\n      if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {\n        var link = this$1.linked[i];\n        if (link.doc != other) { continue }\n        this$1.linked.splice(i, 1);\n        other.unlinkDoc(this$1);\n        detachSharedMarkers(findSharedMarkers(this$1));\n        break\n      } }\n      // If the histories were shared, split them again\n      if (other.history == this.history) {\n        var splitIds = [other.id];\n        linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);\n        other.history = new History(null);\n        other.history.done = copyHistoryArray(this.history.done, splitIds);\n        other.history.undone = copyHistoryArray(this.history.undone, splitIds);\n      }\n    },\n    iterLinkedDocs: function(f) {linkedDocs(this, f);},\n\n    getMode: function() {return this.mode},\n    getEditor: function() {return this.cm},\n\n    splitLines: function(str) {\n      if (this.lineSep) { return str.split(this.lineSep) }\n      return splitLinesAuto(str)\n    },\n    lineSeparator: function() { return this.lineSep || \"\\n\" },\n\n    setDirection: docMethodOp(function (dir) {\n      if (dir != \"rtl\") { dir = \"ltr\"; }\n      if (dir == this.direction) { return }\n      this.direction = dir;\n      this.iter(function (line) { return line.order = null; });\n      if (this.cm) { directionChanged(this.cm); }\n    })\n  });\n\n  // Public alias.\n  Doc.prototype.eachLine = Doc.prototype.iter;\n\n  // Kludge to work around strange IE behavior where it'll sometimes\n  // re-fire a series of drag-related events right after the drop (#1551)\n  var lastDrop = 0;\n\n  function onDrop(e) {\n    var cm = this;\n    clearDragCursor(cm);\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))\n      { return }\n    e_preventDefault(e);\n    if (ie) { lastDrop = +new Date; }\n    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;\n    if (!pos || cm.isReadOnly()) { return }\n    // Might be a file drop, in which case we simply extract the text\n    // and insert it.\n    if (files && files.length && window.FileReader && window.File) {\n      var n = files.length, text = Array(n), read = 0;\n      var loadFile = function (file, i) {\n        if (cm.options.allowDropFileTypes &&\n            indexOf(cm.options.allowDropFileTypes, file.type) == -1)\n          { return }\n\n        var reader = new FileReader;\n        reader.onload = operation(cm, function () {\n          var content = reader.result;\n          if (/[\\x00-\\x08\\x0e-\\x1f]{2}/.test(content)) { content = \"\"; }\n          text[i] = content;\n          if (++read == n) {\n            pos = clipPos(cm.doc, pos);\n            var change = {from: pos, to: pos,\n                          text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),\n                          origin: \"paste\"};\n            makeChange(cm.doc, change);\n            setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)));\n          }\n        });\n        reader.readAsText(file);\n      };\n      for (var i = 0; i < n; ++i) { loadFile(files[i], i); }\n    } else { // Normal drop\n      // Don't do a replace if the drop happened inside of the selected text.\n      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {\n        cm.state.draggingText(e);\n        // Ensure the editor is re-focused\n        setTimeout(function () { return cm.display.input.focus(); }, 20);\n        return\n      }\n      try {\n        var text$1 = e.dataTransfer.getData(\"Text\");\n        if (text$1) {\n          var selected;\n          if (cm.state.draggingText && !cm.state.draggingText.copy)\n            { selected = cm.listSelections(); }\n          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));\n          if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)\n            { replaceRange(cm.doc, \"\", selected[i$1].anchor, selected[i$1].head, \"drag\"); } }\n          cm.replaceSelection(text$1, \"around\", \"paste\");\n          cm.display.input.focus();\n        }\n      }\n      catch(e){}\n    }\n  }\n\n  function onDragStart(cm, e) {\n    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }\n    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }\n\n    e.dataTransfer.setData(\"Text\", cm.getSelection());\n    e.dataTransfer.effectAllowed = \"copyMove\";\n\n    // Use dummy image instead of default browsers image.\n    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.\n    if (e.dataTransfer.setDragImage && !safari) {\n      var img = elt(\"img\", null, null, \"position: fixed; left: 0; top: 0;\");\n      img.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n      if (presto) {\n        img.width = img.height = 1;\n        cm.display.wrapper.appendChild(img);\n        // Force a relayout, or Opera won't use our image for some obscure reason\n        img._top = img.offsetTop;\n      }\n      e.dataTransfer.setDragImage(img, 0, 0);\n      if (presto) { img.parentNode.removeChild(img); }\n    }\n  }\n\n  function onDragOver(cm, e) {\n    var pos = posFromMouse(cm, e);\n    if (!pos) { return }\n    var frag = document.createDocumentFragment();\n    drawSelectionCursor(cm, pos, frag);\n    if (!cm.display.dragCursor) {\n      cm.display.dragCursor = elt(\"div\", null, \"CodeMirror-cursors CodeMirror-dragcursors\");\n      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);\n    }\n    removeChildrenAndAdd(cm.display.dragCursor, frag);\n  }\n\n  function clearDragCursor(cm) {\n    if (cm.display.dragCursor) {\n      cm.display.lineSpace.removeChild(cm.display.dragCursor);\n      cm.display.dragCursor = null;\n    }\n  }\n\n  // These must be handled carefully, because naively registering a\n  // handler for each editor will cause the editors to never be\n  // garbage collected.\n\n  function forEachCodeMirror(f) {\n    if (!document.getElementsByClassName) { return }\n    var byClass = document.getElementsByClassName(\"CodeMirror\"), editors = [];\n    for (var i = 0; i < byClass.length; i++) {\n      var cm = byClass[i].CodeMirror;\n      if (cm) { editors.push(cm); }\n    }\n    if (editors.length) { editors[0].operation(function () {\n      for (var i = 0; i < editors.length; i++) { f(editors[i]); }\n    }); }\n  }\n\n  var globalsRegistered = false;\n  function ensureGlobalHandlers() {\n    if (globalsRegistered) { return }\n    registerGlobalHandlers();\n    globalsRegistered = true;\n  }\n  function registerGlobalHandlers() {\n    // When the window resizes, we need to refresh active editors.\n    var resizeTimer;\n    on(window, \"resize\", function () {\n      if (resizeTimer == null) { resizeTimer = setTimeout(function () {\n        resizeTimer = null;\n        forEachCodeMirror(onResize);\n      }, 100); }\n    });\n    // When the window loses focus, we want to show the editor as blurred\n    on(window, \"blur\", function () { return forEachCodeMirror(onBlur); });\n  }\n  // Called when the window resizes\n  function onResize(cm) {\n    var d = cm.display;\n    // Might be a text scaling operation, clear size caches.\n    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;\n    d.scrollbarsClipped = false;\n    cm.setSize();\n  }\n\n  var keyNames = {\n    3: \"Pause\", 8: \"Backspace\", 9: \"Tab\", 13: \"Enter\", 16: \"Shift\", 17: \"Ctrl\", 18: \"Alt\",\n    19: \"Pause\", 20: \"CapsLock\", 27: \"Esc\", 32: \"Space\", 33: \"PageUp\", 34: \"PageDown\", 35: \"End\",\n    36: \"Home\", 37: \"Left\", 38: \"Up\", 39: \"Right\", 40: \"Down\", 44: \"PrintScrn\", 45: \"Insert\",\n    46: \"Delete\", 59: \";\", 61: \"=\", 91: \"Mod\", 92: \"Mod\", 93: \"Mod\",\n    106: \"*\", 107: \"=\", 109: \"-\", 110: \".\", 111: \"/\", 127: \"Delete\", 145: \"ScrollLock\",\n    173: \"-\", 186: \";\", 187: \"=\", 188: \",\", 189: \"-\", 190: \".\", 191: \"/\", 192: \"`\", 219: \"[\", 220: \"\\\\\",\n    221: \"]\", 222: \"'\", 63232: \"Up\", 63233: \"Down\", 63234: \"Left\", 63235: \"Right\", 63272: \"Delete\",\n    63273: \"Home\", 63275: \"End\", 63276: \"PageUp\", 63277: \"PageDown\", 63302: \"Insert\"\n  };\n\n  // Number keys\n  for (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }\n  // Alphabetic keys\n  for (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }\n  // Function keys\n  for (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = \"F\" + i$2; }\n\n  var keyMap = {};\n\n  keyMap.basic = {\n    \"Left\": \"goCharLeft\", \"Right\": \"goCharRight\", \"Up\": \"goLineUp\", \"Down\": \"goLineDown\",\n    \"End\": \"goLineEnd\", \"Home\": \"goLineStartSmart\", \"PageUp\": \"goPageUp\", \"PageDown\": \"goPageDown\",\n    \"Delete\": \"delCharAfter\", \"Backspace\": \"delCharBefore\", \"Shift-Backspace\": \"delCharBefore\",\n    \"Tab\": \"defaultTab\", \"Shift-Tab\": \"indentAuto\",\n    \"Enter\": \"newlineAndIndent\", \"Insert\": \"toggleOverwrite\",\n    \"Esc\": \"singleSelection\"\n  };\n  // Note that the save and find-related commands aren't defined by\n  // default. User code or addons can define them. Unknown commands\n  // are simply ignored.\n  keyMap.pcDefault = {\n    \"Ctrl-A\": \"selectAll\", \"Ctrl-D\": \"deleteLine\", \"Ctrl-Z\": \"undo\", \"Shift-Ctrl-Z\": \"redo\", \"Ctrl-Y\": \"redo\",\n    \"Ctrl-Home\": \"goDocStart\", \"Ctrl-End\": \"goDocEnd\", \"Ctrl-Up\": \"goLineUp\", \"Ctrl-Down\": \"goLineDown\",\n    \"Ctrl-Left\": \"goGroupLeft\", \"Ctrl-Right\": \"goGroupRight\", \"Alt-Left\": \"goLineStart\", \"Alt-Right\": \"goLineEnd\",\n    \"Ctrl-Backspace\": \"delGroupBefore\", \"Ctrl-Delete\": \"delGroupAfter\", \"Ctrl-S\": \"save\", \"Ctrl-F\": \"find\",\n    \"Ctrl-G\": \"findNext\", \"Shift-Ctrl-G\": \"findPrev\", \"Shift-Ctrl-F\": \"replace\", \"Shift-Ctrl-R\": \"replaceAll\",\n    \"Ctrl-[\": \"indentLess\", \"Ctrl-]\": \"indentMore\",\n    \"Ctrl-U\": \"undoSelection\", \"Shift-Ctrl-U\": \"redoSelection\", \"Alt-U\": \"redoSelection\",\n    \"fallthrough\": \"basic\"\n  };\n  // Very basic readline/emacs-style bindings, which are standard on Mac.\n  keyMap.emacsy = {\n    \"Ctrl-F\": \"goCharRight\", \"Ctrl-B\": \"goCharLeft\", \"Ctrl-P\": \"goLineUp\", \"Ctrl-N\": \"goLineDown\",\n    \"Alt-F\": \"goWordRight\", \"Alt-B\": \"goWordLeft\", \"Ctrl-A\": \"goLineStart\", \"Ctrl-E\": \"goLineEnd\",\n    \"Ctrl-V\": \"goPageDown\", \"Shift-Ctrl-V\": \"goPageUp\", \"Ctrl-D\": \"delCharAfter\", \"Ctrl-H\": \"delCharBefore\",\n    \"Alt-D\": \"delWordAfter\", \"Alt-Backspace\": \"delWordBefore\", \"Ctrl-K\": \"killLine\", \"Ctrl-T\": \"transposeChars\",\n    \"Ctrl-O\": \"openLine\"\n  };\n  keyMap.macDefault = {\n    \"Cmd-A\": \"selectAll\", \"Cmd-D\": \"deleteLine\", \"Cmd-Z\": \"undo\", \"Shift-Cmd-Z\": \"redo\", \"Cmd-Y\": \"redo\",\n    \"Cmd-Home\": \"goDocStart\", \"Cmd-Up\": \"goDocStart\", \"Cmd-End\": \"goDocEnd\", \"Cmd-Down\": \"goDocEnd\", \"Alt-Left\": \"goGroupLeft\",\n    \"Alt-Right\": \"goGroupRight\", \"Cmd-Left\": \"goLineLeft\", \"Cmd-Right\": \"goLineRight\", \"Alt-Backspace\": \"delGroupBefore\",\n    \"Ctrl-Alt-Backspace\": \"delGroupAfter\", \"Alt-Delete\": \"delGroupAfter\", \"Cmd-S\": \"save\", \"Cmd-F\": \"find\",\n    \"Cmd-G\": \"findNext\", \"Shift-Cmd-G\": \"findPrev\", \"Cmd-Alt-F\": \"replace\", \"Shift-Cmd-Alt-F\": \"replaceAll\",\n    \"Cmd-[\": \"indentLess\", \"Cmd-]\": \"indentMore\", \"Cmd-Backspace\": \"delWrappedLineLeft\", \"Cmd-Delete\": \"delWrappedLineRight\",\n    \"Cmd-U\": \"undoSelection\", \"Shift-Cmd-U\": \"redoSelection\", \"Ctrl-Up\": \"goDocStart\", \"Ctrl-Down\": \"goDocEnd\",\n    \"fallthrough\": [\"basic\", \"emacsy\"]\n  };\n  keyMap[\"default\"] = mac ? keyMap.macDefault : keyMap.pcDefault;\n\n  // KEYMAP DISPATCH\n\n  function normalizeKeyName(name) {\n    var parts = name.split(/-(?!$)/);\n    name = parts[parts.length - 1];\n    var alt, ctrl, shift, cmd;\n    for (var i = 0; i < parts.length - 1; i++) {\n      var mod = parts[i];\n      if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }\n      else if (/^a(lt)?$/i.test(mod)) { alt = true; }\n      else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }\n      else if (/^s(hift)?$/i.test(mod)) { shift = true; }\n      else { throw new Error(\"Unrecognized modifier name: \" + mod) }\n    }\n    if (alt) { name = \"Alt-\" + name; }\n    if (ctrl) { name = \"Ctrl-\" + name; }\n    if (cmd) { name = \"Cmd-\" + name; }\n    if (shift) { name = \"Shift-\" + name; }\n    return name\n  }\n\n  // This is a kludge to keep keymaps mostly working as raw objects\n  // (backwards compatibility) while at the same time support features\n  // like normalization and multi-stroke key bindings. It compiles a\n  // new normalized keymap, and then updates the old object to reflect\n  // this.\n  function normalizeKeyMap(keymap) {\n    var copy = {};\n    for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {\n      var value = keymap[keyname];\n      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }\n      if (value == \"...\") { delete keymap[keyname]; continue }\n\n      var keys = map(keyname.split(\" \"), normalizeKeyName);\n      for (var i = 0; i < keys.length; i++) {\n        var val = (void 0), name = (void 0);\n        if (i == keys.length - 1) {\n          name = keys.join(\" \");\n          val = value;\n        } else {\n          name = keys.slice(0, i + 1).join(\" \");\n          val = \"...\";\n        }\n        var prev = copy[name];\n        if (!prev) { copy[name] = val; }\n        else if (prev != val) { throw new Error(\"Inconsistent bindings for \" + name) }\n      }\n      delete keymap[keyname];\n    } }\n    for (var prop in copy) { keymap[prop] = copy[prop]; }\n    return keymap\n  }\n\n  function lookupKey(key, map$$1, handle, context) {\n    map$$1 = getKeyMap(map$$1);\n    var found = map$$1.call ? map$$1.call(key, context) : map$$1[key];\n    if (found === false) { return \"nothing\" }\n    if (found === \"...\") { return \"multi\" }\n    if (found != null && handle(found)) { return \"handled\" }\n\n    if (map$$1.fallthrough) {\n      if (Object.prototype.toString.call(map$$1.fallthrough) != \"[object Array]\")\n        { return lookupKey(key, map$$1.fallthrough, handle, context) }\n      for (var i = 0; i < map$$1.fallthrough.length; i++) {\n        var result = lookupKey(key, map$$1.fallthrough[i], handle, context);\n        if (result) { return result }\n      }\n    }\n  }\n\n  // Modifier key presses don't count as 'real' key presses for the\n  // purpose of keymap fallthrough.\n  function isModifierKey(value) {\n    var name = typeof value == \"string\" ? value : keyNames[value.keyCode];\n    return name == \"Ctrl\" || name == \"Alt\" || name == \"Shift\" || name == \"Mod\"\n  }\n\n  function addModifierNames(name, event, noShift) {\n    var base = name;\n    if (event.altKey && base != \"Alt\") { name = \"Alt-\" + name; }\n    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != \"Ctrl\") { name = \"Ctrl-\" + name; }\n    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != \"Cmd\") { name = \"Cmd-\" + name; }\n    if (!noShift && event.shiftKey && base != \"Shift\") { name = \"Shift-\" + name; }\n    return name\n  }\n\n  // Look up the name of a key as indicated by an event object.\n  function keyName(event, noShift) {\n    if (presto && event.keyCode == 34 && event[\"char\"]) { return false }\n    var name = keyNames[event.keyCode];\n    if (name == null || event.altGraphKey) { return false }\n    // Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,\n    // so we'll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)\n    if (event.keyCode == 3 && event.code) { name = event.code; }\n    return addModifierNames(name, event, noShift)\n  }\n\n  function getKeyMap(val) {\n    return typeof val == \"string\" ? keyMap[val] : val\n  }\n\n  // Helper for deleting text near the selection(s), used to implement\n  // backspace, delete, and similar functionality.\n  function deleteNearSelection(cm, compute) {\n    var ranges = cm.doc.sel.ranges, kill = [];\n    // Build up a set of ranges to kill first, merging overlapping\n    // ranges.\n    for (var i = 0; i < ranges.length; i++) {\n      var toKill = compute(ranges[i]);\n      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {\n        var replaced = kill.pop();\n        if (cmp(replaced.from, toKill.from) < 0) {\n          toKill.from = replaced.from;\n          break\n        }\n      }\n      kill.push(toKill);\n    }\n    // Next, remove those actual ranges.\n    runInOp(cm, function () {\n      for (var i = kill.length - 1; i >= 0; i--)\n        { replaceRange(cm.doc, \"\", kill[i].from, kill[i].to, \"+delete\"); }\n      ensureCursorVisible(cm);\n    });\n  }\n\n  function moveCharLogically(line, ch, dir) {\n    var target = skipExtendingChars(line.text, ch + dir, dir);\n    return target < 0 || target > line.text.length ? null : target\n  }\n\n  function moveLogically(line, start, dir) {\n    var ch = moveCharLogically(line, start.ch, dir);\n    return ch == null ? null : new Pos(start.line, ch, dir < 0 ? \"after\" : \"before\")\n  }\n\n  function endOfLine(visually, cm, lineObj, lineNo, dir) {\n    if (visually) {\n      var order = getOrder(lineObj, cm.doc.direction);\n      if (order) {\n        var part = dir < 0 ? lst(order) : order[0];\n        var moveInStorageOrder = (dir < 0) == (part.level == 1);\n        var sticky = moveInStorageOrder ? \"after\" : \"before\";\n        var ch;\n        // With a wrapped rtl chunk (possibly spanning multiple bidi parts),\n        // it could be that the last bidi part is not on the last visual line,\n        // since visual lines contain content order-consecutive chunks.\n        // Thus, in rtl, we are looking for the first (content-order) character\n        // in the rtl chunk that is on the last line (that is, the same line\n        // as the last (content-order) character).\n        if (part.level > 0 || cm.doc.direction == \"rtl\") {\n          var prep = prepareMeasureForLine(cm, lineObj);\n          ch = dir < 0 ? lineObj.text.length - 1 : 0;\n          var targetTop = measureCharPrepared(cm, prep, ch).top;\n          ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch);\n          if (sticky == \"before\") { ch = moveCharLogically(lineObj, ch, 1); }\n        } else { ch = dir < 0 ? part.to : part.from; }\n        return new Pos(lineNo, ch, sticky)\n      }\n    }\n    return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? \"before\" : \"after\")\n  }\n\n  function moveVisually(cm, line, start, dir) {\n    var bidi = getOrder(line, cm.doc.direction);\n    if (!bidi) { return moveLogically(line, start, dir) }\n    if (start.ch >= line.text.length) {\n      start.ch = line.text.length;\n      start.sticky = \"before\";\n    } else if (start.ch <= 0) {\n      start.ch = 0;\n      start.sticky = \"after\";\n    }\n    var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];\n    if (cm.doc.direction == \"ltr\" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {\n      // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,\n      // nothing interesting happens.\n      return moveLogically(line, start, dir)\n    }\n\n    var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };\n    var prep;\n    var getWrappedLineExtent = function (ch) {\n      if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }\n      prep = prep || prepareMeasureForLine(cm, line);\n      return wrappedLineExtentChar(cm, line, prep, ch)\n    };\n    var wrappedLineExtent = getWrappedLineExtent(start.sticky == \"before\" ? mv(start, -1) : start.ch);\n\n    if (cm.doc.direction == \"rtl\" || part.level == 1) {\n      var moveInStorageOrder = (part.level == 1) == (dir < 0);\n      var ch = mv(start, moveInStorageOrder ? 1 : -1);\n      if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {\n        // Case 2: We move within an rtl part or in an rtl editor on the same visual line\n        var sticky = moveInStorageOrder ? \"before\" : \"after\";\n        return new Pos(start.line, ch, sticky)\n      }\n    }\n\n    // Case 3: Could not move within this bidi part in this visual line, so leave\n    // the current bidi part\n\n    var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {\n      var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder\n        ? new Pos(start.line, mv(ch, 1), \"before\")\n        : new Pos(start.line, ch, \"after\"); };\n\n      for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {\n        var part = bidi[partPos];\n        var moveInStorageOrder = (dir > 0) == (part.level != 1);\n        var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);\n        if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }\n        ch = moveInStorageOrder ? part.from : mv(part.to, -1);\n        if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }\n      }\n    };\n\n    // Case 3a: Look for other bidi parts on the same visual line\n    var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);\n    if (res) { return res }\n\n    // Case 3b: Look for other bidi parts on the next visual line\n    var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);\n    if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {\n      res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));\n      if (res) { return res }\n    }\n\n    // Case 4: Nowhere to move\n    return null\n  }\n\n  // Commands are parameter-less actions that can be performed on an\n  // editor, mostly used for keybindings.\n  var commands = {\n    selectAll: selectAll,\n    singleSelection: function (cm) { return cm.setSelection(cm.getCursor(\"anchor\"), cm.getCursor(\"head\"), sel_dontScroll); },\n    killLine: function (cm) { return deleteNearSelection(cm, function (range) {\n      if (range.empty()) {\n        var len = getLine(cm.doc, range.head.line).text.length;\n        if (range.head.ch == len && range.head.line < cm.lastLine())\n          { return {from: range.head, to: Pos(range.head.line + 1, 0)} }\n        else\n          { return {from: range.head, to: Pos(range.head.line, len)} }\n      } else {\n        return {from: range.from(), to: range.to()}\n      }\n    }); },\n    deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({\n      from: Pos(range.from().line, 0),\n      to: clipPos(cm.doc, Pos(range.to().line + 1, 0))\n    }); }); },\n    delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({\n      from: Pos(range.from().line, 0), to: range.from()\n    }); }); },\n    delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {\n      var top = cm.charCoords(range.head, \"div\").top + 5;\n      var leftPos = cm.coordsChar({left: 0, top: top}, \"div\");\n      return {from: leftPos, to: range.from()}\n    }); },\n    delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {\n      var top = cm.charCoords(range.head, \"div\").top + 5;\n      var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\");\n      return {from: range.from(), to: rightPos }\n    }); },\n    undo: function (cm) { return cm.undo(); },\n    redo: function (cm) { return cm.redo(); },\n    undoSelection: function (cm) { return cm.undoSelection(); },\n    redoSelection: function (cm) { return cm.redoSelection(); },\n    goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },\n    goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },\n    goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },\n      {origin: \"+move\", bias: 1}\n    ); },\n    goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },\n      {origin: \"+move\", bias: 1}\n    ); },\n    goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },\n      {origin: \"+move\", bias: -1}\n    ); },\n    goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {\n      var top = cm.cursorCoords(range.head, \"div\").top + 5;\n      return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, \"div\")\n    }, sel_move); },\n    goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {\n      var top = cm.cursorCoords(range.head, \"div\").top + 5;\n      return cm.coordsChar({left: 0, top: top}, \"div\")\n    }, sel_move); },\n    goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {\n      var top = cm.cursorCoords(range.head, \"div\").top + 5;\n      var pos = cm.coordsChar({left: 0, top: top}, \"div\");\n      if (pos.ch < cm.getLine(pos.line).search(/\\S/)) { return lineStartSmart(cm, range.head) }\n      return pos\n    }, sel_move); },\n    goLineUp: function (cm) { return cm.moveV(-1, \"line\"); },\n    goLineDown: function (cm) { return cm.moveV(1, \"line\"); },\n    goPageUp: function (cm) { return cm.moveV(-1, \"page\"); },\n    goPageDown: function (cm) { return cm.moveV(1, \"page\"); },\n    goCharLeft: function (cm) { return cm.moveH(-1, \"char\"); },\n    goCharRight: function (cm) { return cm.moveH(1, \"char\"); },\n    goColumnLeft: function (cm) { return cm.moveH(-1, \"column\"); },\n    goColumnRight: function (cm) { return cm.moveH(1, \"column\"); },\n    goWordLeft: function (cm) { return cm.moveH(-1, \"word\"); },\n    goGroupRight: function (cm) { return cm.moveH(1, \"group\"); },\n    goGroupLeft: function (cm) { return cm.moveH(-1, \"group\"); },\n    goWordRight: function (cm) { return cm.moveH(1, \"word\"); },\n    delCharBefore: function (cm) { return cm.deleteH(-1, \"char\"); },\n    delCharAfter: function (cm) { return cm.deleteH(1, \"char\"); },\n    delWordBefore: function (cm) { return cm.deleteH(-1, \"word\"); },\n    delWordAfter: function (cm) { return cm.deleteH(1, \"word\"); },\n    delGroupBefore: function (cm) { return cm.deleteH(-1, \"group\"); },\n    delGroupAfter: function (cm) { return cm.deleteH(1, \"group\"); },\n    indentAuto: function (cm) { return cm.indentSelection(\"smart\"); },\n    indentMore: function (cm) { return cm.indentSelection(\"add\"); },\n    indentLess: function (cm) { return cm.indentSelection(\"subtract\"); },\n    insertTab: function (cm) { return cm.replaceSelection(\"\\t\"); },\n    insertSoftTab: function (cm) {\n      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;\n      for (var i = 0; i < ranges.length; i++) {\n        var pos = ranges[i].from();\n        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);\n        spaces.push(spaceStr(tabSize - col % tabSize));\n      }\n      cm.replaceSelections(spaces);\n    },\n    defaultTab: function (cm) {\n      if (cm.somethingSelected()) { cm.indentSelection(\"add\"); }\n      else { cm.execCommand(\"insertTab\"); }\n    },\n    // Swap the two chars left and right of each selection's head.\n    // Move cursor behind the two swapped characters afterwards.\n    //\n    // Doesn't consider line feeds a character.\n    // Doesn't scan more than one line above to find a character.\n    // Doesn't do anything on an empty line.\n    // Doesn't do anything with non-empty selections.\n    transposeChars: function (cm) { return runInOp(cm, function () {\n      var ranges = cm.listSelections(), newSel = [];\n      for (var i = 0; i < ranges.length; i++) {\n        if (!ranges[i].empty()) { continue }\n        var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;\n        if (line) {\n          if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }\n          if (cur.ch > 0) {\n            cur = new Pos(cur.line, cur.ch + 1);\n            cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),\n                            Pos(cur.line, cur.ch - 2), cur, \"+transpose\");\n          } else if (cur.line > cm.doc.first) {\n            var prev = getLine(cm.doc, cur.line - 1).text;\n            if (prev) {\n              cur = new Pos(cur.line, 1);\n              cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +\n                              prev.charAt(prev.length - 1),\n                              Pos(cur.line - 1, prev.length - 1), cur, \"+transpose\");\n            }\n          }\n        }\n        newSel.push(new Range(cur, cur));\n      }\n      cm.setSelections(newSel);\n    }); },\n    newlineAndIndent: function (cm) { return runInOp(cm, function () {\n      var sels = cm.listSelections();\n      for (var i = sels.length - 1; i >= 0; i--)\n        { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, \"+input\"); }\n      sels = cm.listSelections();\n      for (var i$1 = 0; i$1 < sels.length; i$1++)\n        { cm.indentLine(sels[i$1].from().line, null, true); }\n      ensureCursorVisible(cm);\n    }); },\n    openLine: function (cm) { return cm.replaceSelection(\"\\n\", \"start\"); },\n    toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }\n  };\n\n\n  function lineStart(cm, lineN) {\n    var line = getLine(cm.doc, lineN);\n    var visual = visualLine(line);\n    if (visual != line) { lineN = lineNo(visual); }\n    return endOfLine(true, cm, visual, lineN, 1)\n  }\n  function lineEnd(cm, lineN) {\n    var line = getLine(cm.doc, lineN);\n    var visual = visualLineEnd(line);\n    if (visual != line) { lineN = lineNo(visual); }\n    return endOfLine(true, cm, line, lineN, -1)\n  }\n  function lineStartSmart(cm, pos) {\n    var start = lineStart(cm, pos.line);\n    var line = getLine(cm.doc, start.line);\n    var order = getOrder(line, cm.doc.direction);\n    if (!order || order[0].level == 0) {\n      var firstNonWS = Math.max(0, line.text.search(/\\S/));\n      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;\n      return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)\n    }\n    return start\n  }\n\n  // Run a handler that was bound to a key.\n  function doHandleBinding(cm, bound, dropShift) {\n    if (typeof bound == \"string\") {\n      bound = commands[bound];\n      if (!bound) { return false }\n    }\n    // Ensure previous input has been read, so that the handler sees a\n    // consistent view of the document\n    cm.display.input.ensurePolled();\n    var prevShift = cm.display.shift, done = false;\n    try {\n      if (cm.isReadOnly()) { cm.state.suppressEdits = true; }\n      if (dropShift) { cm.display.shift = false; }\n      done = bound(cm) != Pass;\n    } finally {\n      cm.display.shift = prevShift;\n      cm.state.suppressEdits = false;\n    }\n    return done\n  }\n\n  function lookupKeyForEditor(cm, name, handle) {\n    for (var i = 0; i < cm.state.keyMaps.length; i++) {\n      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);\n      if (result) { return result }\n    }\n    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))\n      || lookupKey(name, cm.options.keyMap, handle, cm)\n  }\n\n  // Note that, despite the name, this function is also used to check\n  // for bound mouse clicks.\n\n  var stopSeq = new Delayed;\n\n  function dispatchKey(cm, name, e, handle) {\n    var seq = cm.state.keySeq;\n    if (seq) {\n      if (isModifierKey(name)) { return \"handled\" }\n      if (/\\'$/.test(name))\n        { cm.state.keySeq = null; }\n      else\n        { stopSeq.set(50, function () {\n          if (cm.state.keySeq == seq) {\n            cm.state.keySeq = null;\n            cm.display.input.reset();\n          }\n        }); }\n      if (dispatchKeyInner(cm, seq + \" \" + name, e, handle)) { return true }\n    }\n    return dispatchKeyInner(cm, name, e, handle)\n  }\n\n  function dispatchKeyInner(cm, name, e, handle) {\n    var result = lookupKeyForEditor(cm, name, handle);\n\n    if (result == \"multi\")\n      { cm.state.keySeq = name; }\n    if (result == \"handled\")\n      { signalLater(cm, \"keyHandled\", cm, name, e); }\n\n    if (result == \"handled\" || result == \"multi\") {\n      e_preventDefault(e);\n      restartBlink(cm);\n    }\n\n    return !!result\n  }\n\n  // Handle a key from the keydown event.\n  function handleKeyBinding(cm, e) {\n    var name = keyName(e, true);\n    if (!name) { return false }\n\n    if (e.shiftKey && !cm.state.keySeq) {\n      // First try to resolve full name (including 'Shift-'). Failing\n      // that, see if there is a cursor-motion command (starting with\n      // 'go') bound to the keyname without 'Shift-'.\n      return dispatchKey(cm, \"Shift-\" + name, e, function (b) { return doHandleBinding(cm, b, true); })\n          || dispatchKey(cm, name, e, function (b) {\n               if (typeof b == \"string\" ? /^go[A-Z]/.test(b) : b.motion)\n                 { return doHandleBinding(cm, b) }\n             })\n    } else {\n      return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })\n    }\n  }\n\n  // Handle a key from the keypress event\n  function handleCharBinding(cm, e, ch) {\n    return dispatchKey(cm, \"'\" + ch + \"'\", e, function (b) { return doHandleBinding(cm, b, true); })\n  }\n\n  var lastStoppedKey = null;\n  function onKeyDown(e) {\n    var cm = this;\n    cm.curOp.focus = activeElt();\n    if (signalDOMEvent(cm, e)) { return }\n    // IE does strange things with escape.\n    if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false; }\n    var code = e.keyCode;\n    cm.display.shift = code == 16 || e.shiftKey;\n    var handled = handleKeyBinding(cm, e);\n    if (presto) {\n      lastStoppedKey = handled ? code : null;\n      // Opera has no cut event... we try to at least catch the key combo\n      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))\n        { cm.replaceSelection(\"\", null, \"cut\"); }\n    }\n\n    // Turn mouse into crosshair when Alt is held on Mac.\n    if (code == 18 && !/\\bCodeMirror-crosshair\\b/.test(cm.display.lineDiv.className))\n      { showCrossHair(cm); }\n  }\n\n  function showCrossHair(cm) {\n    var lineDiv = cm.display.lineDiv;\n    addClass(lineDiv, \"CodeMirror-crosshair\");\n\n    function up(e) {\n      if (e.keyCode == 18 || !e.altKey) {\n        rmClass(lineDiv, \"CodeMirror-crosshair\");\n        off(document, \"keyup\", up);\n        off(document, \"mouseover\", up);\n      }\n    }\n    on(document, \"keyup\", up);\n    on(document, \"mouseover\", up);\n  }\n\n  function onKeyUp(e) {\n    if (e.keyCode == 16) { this.doc.sel.shift = false; }\n    signalDOMEvent(this, e);\n  }\n\n  function onKeyPress(e) {\n    var cm = this;\n    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }\n    var keyCode = e.keyCode, charCode = e.charCode;\n    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}\n    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }\n    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);\n    // Some browsers fire keypress events for backspace\n    if (ch == \"\\x08\") { return }\n    if (handleCharBinding(cm, e, ch)) { return }\n    cm.display.input.onKeyPress(e);\n  }\n\n  var DOUBLECLICK_DELAY = 400;\n\n  var PastClick = function(time, pos, button) {\n    this.time = time;\n    this.pos = pos;\n    this.button = button;\n  };\n\n  PastClick.prototype.compare = function (time, pos, button) {\n    return this.time + DOUBLECLICK_DELAY > time &&\n      cmp(pos, this.pos) == 0 && button == this.button\n  };\n\n  var lastClick, lastDoubleClick;\n  function clickRepeat(pos, button) {\n    var now = +new Date;\n    if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {\n      lastClick = lastDoubleClick = null;\n      return \"triple\"\n    } else if (lastClick && lastClick.compare(now, pos, button)) {\n      lastDoubleClick = new PastClick(now, pos, button);\n      lastClick = null;\n      return \"double\"\n    } else {\n      lastClick = new PastClick(now, pos, button);\n      lastDoubleClick = null;\n      return \"single\"\n    }\n  }\n\n  // A mouse down can be a single click, double click, triple click,\n  // start of selection drag, start of text drag, new cursor\n  // (ctrl-click), rectangle drag (alt-drag), or xwin\n  // middle-click-paste. Or it might be a click on something we should\n  // not interfere with, such as a scrollbar or widget.\n  function onMouseDown(e) {\n    var cm = this, display = cm.display;\n    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }\n    display.input.ensurePolled();\n    display.shift = e.shiftKey;\n\n    if (eventInWidget(display, e)) {\n      if (!webkit) {\n        // Briefly turn off draggability, to allow widgets to do\n        // normal dragging things.\n        display.scroller.draggable = false;\n        setTimeout(function () { return display.scroller.draggable = true; }, 100);\n      }\n      return\n    }\n    if (clickInGutter(cm, e)) { return }\n    var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : \"single\";\n    window.focus();\n\n    // #3261: make sure, that we're not starting a second selection\n    if (button == 1 && cm.state.selectingText)\n      { cm.state.selectingText(e); }\n\n    if (pos && handleMappedButton(cm, button, pos, repeat, e)) { return }\n\n    if (button == 1) {\n      if (pos) { leftButtonDown(cm, pos, repeat, e); }\n      else if (e_target(e) == display.scroller) { e_preventDefault(e); }\n    } else if (button == 2) {\n      if (pos) { extendSelection(cm.doc, pos); }\n      setTimeout(function () { return display.input.focus(); }, 20);\n    } else if (button == 3) {\n      if (captureRightClick) { cm.display.input.onContextMenu(e); }\n      else { delayBlurEvent(cm); }\n    }\n  }\n\n  function handleMappedButton(cm, button, pos, repeat, event) {\n    var name = \"Click\";\n    if (repeat == \"double\") { name = \"Double\" + name; }\n    else if (repeat == \"triple\") { name = \"Triple\" + name; }\n    name = (button == 1 ? \"Left\" : button == 2 ? \"Middle\" : \"Right\") + name;\n\n    return dispatchKey(cm,  addModifierNames(name, event), event, function (bound) {\n      if (typeof bound == \"string\") { bound = commands[bound]; }\n      if (!bound) { return false }\n      var done = false;\n      try {\n        if (cm.isReadOnly()) { cm.state.suppressEdits = true; }\n        done = bound(cm, pos) != Pass;\n      } finally {\n        cm.state.suppressEdits = false;\n      }\n      return done\n    })\n  }\n\n  function configureMouse(cm, repeat, event) {\n    var option = cm.getOption(\"configureMouse\");\n    var value = option ? option(cm, repeat, event) : {};\n    if (value.unit == null) {\n      var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;\n      value.unit = rect ? \"rectangle\" : repeat == \"single\" ? \"char\" : repeat == \"double\" ? \"word\" : \"line\";\n    }\n    if (value.extend == null || cm.doc.extend) { value.extend = cm.doc.extend || event.shiftKey; }\n    if (value.addNew == null) { value.addNew = mac ? event.metaKey : event.ctrlKey; }\n    if (value.moveOnDrag == null) { value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey); }\n    return value\n  }\n\n  function leftButtonDown(cm, pos, repeat, event) {\n    if (ie) { setTimeout(bind(ensureFocus, cm), 0); }\n    else { cm.curOp.focus = activeElt(); }\n\n    var behavior = configureMouse(cm, repeat, event);\n\n    var sel = cm.doc.sel, contained;\n    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&\n        repeat == \"single\" && (contained = sel.contains(pos)) > -1 &&\n        (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) &&\n        (cmp(contained.to(), pos) > 0 || pos.xRel < 0))\n      { leftButtonStartDrag(cm, event, pos, behavior); }\n    else\n      { leftButtonSelect(cm, event, pos, behavior); }\n  }\n\n  // Start a text drag. When it ends, see if any dragging actually\n  // happen, and treat as a click if it didn't.\n  function leftButtonStartDrag(cm, event, pos, behavior) {\n    var display = cm.display, moved = false;\n    var dragEnd = operation(cm, function (e) {\n      if (webkit) { display.scroller.draggable = false; }\n      cm.state.draggingText = false;\n      off(display.wrapper.ownerDocument, \"mouseup\", dragEnd);\n      off(display.wrapper.ownerDocument, \"mousemove\", mouseMove);\n      off(display.scroller, \"dragstart\", dragStart);\n      off(display.scroller, \"drop\", dragEnd);\n      if (!moved) {\n        e_preventDefault(e);\n        if (!behavior.addNew)\n          { extendSelection(cm.doc, pos, null, null, behavior.extend); }\n        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)\n        if (webkit || ie && ie_version == 9)\n          { setTimeout(function () {display.wrapper.ownerDocument.body.focus(); display.input.focus();}, 20); }\n        else\n          { display.input.focus(); }\n      }\n    });\n    var mouseMove = function(e2) {\n      moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;\n    };\n    var dragStart = function () { return moved = true; };\n    // Let the drag handler handle this.\n    if (webkit) { display.scroller.draggable = true; }\n    cm.state.draggingText = dragEnd;\n    dragEnd.copy = !behavior.moveOnDrag;\n    // IE's approach to draggable\n    if (display.scroller.dragDrop) { display.scroller.dragDrop(); }\n    on(display.wrapper.ownerDocument, \"mouseup\", dragEnd);\n    on(display.wrapper.ownerDocument, \"mousemove\", mouseMove);\n    on(display.scroller, \"dragstart\", dragStart);\n    on(display.scroller, \"drop\", dragEnd);\n\n    delayBlurEvent(cm);\n    setTimeout(function () { return display.input.focus(); }, 20);\n  }\n\n  function rangeForUnit(cm, pos, unit) {\n    if (unit == \"char\") { return new Range(pos, pos) }\n    if (unit == \"word\") { return cm.findWordAt(pos) }\n    if (unit == \"line\") { return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }\n    var result = unit(cm, pos);\n    return new Range(result.from, result.to)\n  }\n\n  // Normal selection, as opposed to text dragging.\n  function leftButtonSelect(cm, event, start, behavior) {\n    var display = cm.display, doc = cm.doc;\n    e_preventDefault(event);\n\n    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;\n    if (behavior.addNew && !behavior.extend) {\n      ourIndex = doc.sel.contains(start);\n      if (ourIndex > -1)\n        { ourRange = ranges[ourIndex]; }\n      else\n        { ourRange = new Range(start, start); }\n    } else {\n      ourRange = doc.sel.primary();\n      ourIndex = doc.sel.primIndex;\n    }\n\n    if (behavior.unit == \"rectangle\") {\n      if (!behavior.addNew) { ourRange = new Range(start, start); }\n      start = posFromMouse(cm, event, true, true);\n      ourIndex = -1;\n    } else {\n      var range$$1 = rangeForUnit(cm, start, behavior.unit);\n      if (behavior.extend)\n        { ourRange = extendRange(ourRange, range$$1.anchor, range$$1.head, behavior.extend); }\n      else\n        { ourRange = range$$1; }\n    }\n\n    if (!behavior.addNew) {\n      ourIndex = 0;\n      setSelection(doc, new Selection([ourRange], 0), sel_mouse);\n      startSel = doc.sel;\n    } else if (ourIndex == -1) {\n      ourIndex = ranges.length;\n      setSelection(doc, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex),\n                   {scroll: false, origin: \"*mouse\"});\n    } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == \"char\" && !behavior.extend) {\n      setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),\n                   {scroll: false, origin: \"*mouse\"});\n      startSel = doc.sel;\n    } else {\n      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);\n    }\n\n    var lastPos = start;\n    function extendTo(pos) {\n      if (cmp(lastPos, pos) == 0) { return }\n      lastPos = pos;\n\n      if (behavior.unit == \"rectangle\") {\n        var ranges = [], tabSize = cm.options.tabSize;\n        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);\n        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);\n        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);\n        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));\n             line <= end; line++) {\n          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);\n          if (left == right)\n            { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }\n          else if (text.length > leftPos)\n            { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }\n        }\n        if (!ranges.length) { ranges.push(new Range(start, start)); }\n        setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),\n                     {origin: \"*mouse\", scroll: false});\n        cm.scrollIntoView(pos);\n      } else {\n        var oldRange = ourRange;\n        var range$$1 = rangeForUnit(cm, pos, behavior.unit);\n        var anchor = oldRange.anchor, head;\n        if (cmp(range$$1.anchor, anchor) > 0) {\n          head = range$$1.head;\n          anchor = minPos(oldRange.from(), range$$1.anchor);\n        } else {\n          head = range$$1.anchor;\n          anchor = maxPos(oldRange.to(), range$$1.head);\n        }\n        var ranges$1 = startSel.ranges.slice(0);\n        ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));\n        setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);\n      }\n    }\n\n    var editorSize = display.wrapper.getBoundingClientRect();\n    // Used to ensure timeout re-tries don't fire when another extend\n    // happened in the meantime (clearTimeout isn't reliable -- at\n    // least on Chrome, the timeouts still happen even when cleared,\n    // if the clear happens after their scheduled firing time).\n    var counter = 0;\n\n    function extend(e) {\n      var curCount = ++counter;\n      var cur = posFromMouse(cm, e, true, behavior.unit == \"rectangle\");\n      if (!cur) { return }\n      if (cmp(cur, lastPos) != 0) {\n        cm.curOp.focus = activeElt();\n        extendTo(cur);\n        var visible = visibleLines(display, doc);\n        if (cur.line >= visible.to || cur.line < visible.from)\n          { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }\n      } else {\n        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;\n        if (outside) { setTimeout(operation(cm, function () {\n          if (counter != curCount) { return }\n          display.scroller.scrollTop += outside;\n          extend(e);\n        }), 50); }\n      }\n    }\n\n    function done(e) {\n      cm.state.selectingText = false;\n      counter = Infinity;\n      e_preventDefault(e);\n      display.input.focus();\n      off(display.wrapper.ownerDocument, \"mousemove\", move);\n      off(display.wrapper.ownerDocument, \"mouseup\", up);\n      doc.history.lastSelOrigin = null;\n    }\n\n    var move = operation(cm, function (e) {\n      if (e.buttons === 0 || !e_button(e)) { done(e); }\n      else { extend(e); }\n    });\n    var up = operation(cm, done);\n    cm.state.selectingText = up;\n    on(display.wrapper.ownerDocument, \"mousemove\", move);\n    on(display.wrapper.ownerDocument, \"mouseup\", up);\n  }\n\n  // Used when mouse-selecting to adjust the anchor to the proper side\n  // of a bidi jump depending on the visual position of the head.\n  function bidiSimplify(cm, range$$1) {\n    var anchor = range$$1.anchor;\n    var head = range$$1.head;\n    var anchorLine = getLine(cm.doc, anchor.line);\n    if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) { return range$$1 }\n    var order = getOrder(anchorLine);\n    if (!order) { return range$$1 }\n    var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];\n    if (part.from != anchor.ch && part.to != anchor.ch) { return range$$1 }\n    var boundary = index + ((part.from == anchor.ch) == (part.level != 1) ? 0 : 1);\n    if (boundary == 0 || boundary == order.length) { return range$$1 }\n\n    // Compute the relative visual position of the head compared to the\n    // anchor (<0 is to the left, >0 to the right)\n    var leftSide;\n    if (head.line != anchor.line) {\n      leftSide = (head.line - anchor.line) * (cm.doc.direction == \"ltr\" ? 1 : -1) > 0;\n    } else {\n      var headIndex = getBidiPartAt(order, head.ch, head.sticky);\n      var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);\n      if (headIndex == boundary - 1 || headIndex == boundary)\n        { leftSide = dir < 0; }\n      else\n        { leftSide = dir > 0; }\n    }\n\n    var usePart = order[boundary + (leftSide ? -1 : 0)];\n    var from = leftSide == (usePart.level == 1);\n    var ch = from ? usePart.from : usePart.to, sticky = from ? \"after\" : \"before\";\n    return anchor.ch == ch && anchor.sticky == sticky ? range$$1 : new Range(new Pos(anchor.line, ch, sticky), head)\n  }\n\n\n  // Determines whether an event happened in the gutter, and fires the\n  // handlers for the corresponding event.\n  function gutterEvent(cm, e, type, prevent) {\n    var mX, mY;\n    if (e.touches) {\n      mX = e.touches[0].clientX;\n      mY = e.touches[0].clientY;\n    } else {\n      try { mX = e.clientX; mY = e.clientY; }\n      catch(e) { return false }\n    }\n    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }\n    if (prevent) { e_preventDefault(e); }\n\n    var display = cm.display;\n    var lineBox = display.lineDiv.getBoundingClientRect();\n\n    if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }\n    mY -= lineBox.top - display.viewOffset;\n\n    for (var i = 0; i < cm.options.gutters.length; ++i) {\n      var g = display.gutters.childNodes[i];\n      if (g && g.getBoundingClientRect().right >= mX) {\n        var line = lineAtHeight(cm.doc, mY);\n        var gutter = cm.options.gutters[i];\n        signal(cm, type, cm, line, gutter, e);\n        return e_defaultPrevented(e)\n      }\n    }\n  }\n\n  function clickInGutter(cm, e) {\n    return gutterEvent(cm, e, \"gutterClick\", true)\n  }\n\n  // CONTEXT MENU HANDLING\n\n  // To make the context menu work, we need to briefly unhide the\n  // textarea (making it as unobtrusive as possible) to let the\n  // right-click take effect on it.\n  function onContextMenu(cm, e) {\n    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }\n    if (signalDOMEvent(cm, e, \"contextmenu\")) { return }\n    if (!captureRightClick) { cm.display.input.onContextMenu(e); }\n  }\n\n  function contextMenuInGutter(cm, e) {\n    if (!hasHandler(cm, \"gutterContextMenu\")) { return false }\n    return gutterEvent(cm, e, \"gutterContextMenu\", false)\n  }\n\n  function themeChanged(cm) {\n    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\\s*cm-s-\\S+/g, \"\") +\n      cm.options.theme.replace(/(^|\\s)\\s*/g, \" cm-s-\");\n    clearCaches(cm);\n  }\n\n  var Init = {toString: function(){return \"CodeMirror.Init\"}};\n\n  var defaults = {};\n  var optionHandlers = {};\n\n  function defineOptions(CodeMirror) {\n    var optionHandlers = CodeMirror.optionHandlers;\n\n    function option(name, deflt, handle, notOnInit) {\n      CodeMirror.defaults[name] = deflt;\n      if (handle) { optionHandlers[name] =\n        notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }\n    }\n\n    CodeMirror.defineOption = option;\n\n    // Passed to option handlers when there is no old value.\n    CodeMirror.Init = Init;\n\n    // These two are, on init, called from the constructor because they\n    // have to be initialized before the editor can start at all.\n    option(\"value\", \"\", function (cm, val) { return cm.setValue(val); }, true);\n    option(\"mode\", null, function (cm, val) {\n      cm.doc.modeOption = val;\n      loadMode(cm);\n    }, true);\n\n    option(\"indentUnit\", 2, loadMode, true);\n    option(\"indentWithTabs\", false);\n    option(\"smartIndent\", true);\n    option(\"tabSize\", 4, function (cm) {\n      resetModeState(cm);\n      clearCaches(cm);\n      regChange(cm);\n    }, true);\n\n    option(\"lineSeparator\", null, function (cm, val) {\n      cm.doc.lineSep = val;\n      if (!val) { return }\n      var newBreaks = [], lineNo = cm.doc.first;\n      cm.doc.iter(function (line) {\n        for (var pos = 0;;) {\n          var found = line.text.indexOf(val, pos);\n          if (found == -1) { break }\n          pos = found + val.length;\n          newBreaks.push(Pos(lineNo, found));\n        }\n        lineNo++;\n      });\n      for (var i = newBreaks.length - 1; i >= 0; i--)\n        { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }\n    });\n    option(\"specialChars\", /[\\u0000-\\u001f\\u007f-\\u009f\\u00ad\\u061c\\u200b-\\u200f\\u2028\\u2029\\ufeff]/g, function (cm, val, old) {\n      cm.state.specialChars = new RegExp(val.source + (val.test(\"\\t\") ? \"\" : \"|\\t\"), \"g\");\n      if (old != Init) { cm.refresh(); }\n    });\n    option(\"specialCharPlaceholder\", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);\n    option(\"electricChars\", true);\n    option(\"inputStyle\", mobile ? \"contenteditable\" : \"textarea\", function () {\n      throw new Error(\"inputStyle can not (yet) be changed in a running editor\") // FIXME\n    }, true);\n    option(\"spellcheck\", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);\n    option(\"autocorrect\", false, function (cm, val) { return cm.getInputField().autocorrect = val; }, true);\n    option(\"autocapitalize\", false, function (cm, val) { return cm.getInputField().autocapitalize = val; }, true);\n    option(\"rtlMoveVisually\", !windows);\n    option(\"wholeLineUpdateBefore\", true);\n\n    option(\"theme\", \"default\", function (cm) {\n      themeChanged(cm);\n      guttersChanged(cm);\n    }, true);\n    option(\"keyMap\", \"default\", function (cm, val, old) {\n      var next = getKeyMap(val);\n      var prev = old != Init && getKeyMap(old);\n      if (prev && prev.detach) { prev.detach(cm, next); }\n      if (next.attach) { next.attach(cm, prev || null); }\n    });\n    option(\"extraKeys\", null);\n    option(\"configureMouse\", null);\n\n    option(\"lineWrapping\", false, wrappingChanged, true);\n    option(\"gutters\", [], function (cm) {\n      setGuttersForLineNumbers(cm.options);\n      guttersChanged(cm);\n    }, true);\n    option(\"fixedGutter\", true, function (cm, val) {\n      cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + \"px\" : \"0\";\n      cm.refresh();\n    }, true);\n    option(\"coverGutterNextToScrollbar\", false, function (cm) { return updateScrollbars(cm); }, true);\n    option(\"scrollbarStyle\", \"native\", function (cm) {\n      initScrollbars(cm);\n      updateScrollbars(cm);\n      cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);\n      cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);\n    }, true);\n    option(\"lineNumbers\", false, function (cm) {\n      setGuttersForLineNumbers(cm.options);\n      guttersChanged(cm);\n    }, true);\n    option(\"firstLineNumber\", 1, guttersChanged, true);\n    option(\"lineNumberFormatter\", function (integer) { return integer; }, guttersChanged, true);\n    option(\"showCursorWhenSelecting\", false, updateSelection, true);\n\n    option(\"resetSelectionOnContextMenu\", true);\n    option(\"lineWiseCopyCut\", true);\n    option(\"pasteLinesPerSelection\", true);\n    option(\"selectionsMayTouch\", false);\n\n    option(\"readOnly\", false, function (cm, val) {\n      if (val == \"nocursor\") {\n        onBlur(cm);\n        cm.display.input.blur();\n      }\n      cm.display.input.readOnlyChanged(val);\n    });\n    option(\"disableInput\", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);\n    option(\"dragDrop\", true, dragDropChanged);\n    option(\"allowDropFileTypes\", null);\n\n    option(\"cursorBlinkRate\", 530);\n    option(\"cursorScrollMargin\", 0);\n    option(\"cursorHeight\", 1, updateSelection, true);\n    option(\"singleCursorHeightPerLine\", true, updateSelection, true);\n    option(\"workTime\", 100);\n    option(\"workDelay\", 100);\n    option(\"flattenSpans\", true, resetModeState, true);\n    option(\"addModeClass\", false, resetModeState, true);\n    option(\"pollInterval\", 100);\n    option(\"undoDepth\", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });\n    option(\"historyEventDelay\", 1250);\n    option(\"viewportMargin\", 10, function (cm) { return cm.refresh(); }, true);\n    option(\"maxHighlightLength\", 10000, resetModeState, true);\n    option(\"moveInputWithCursor\", true, function (cm, val) {\n      if (!val) { cm.display.input.resetPosition(); }\n    });\n\n    option(\"tabindex\", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || \"\"; });\n    option(\"autofocus\", null);\n    option(\"direction\", \"ltr\", function (cm, val) { return cm.doc.setDirection(val); }, true);\n    option(\"phrases\", null);\n  }\n\n  function guttersChanged(cm) {\n    updateGutters(cm);\n    regChange(cm);\n    alignHorizontally(cm);\n  }\n\n  function dragDropChanged(cm, value, old) {\n    var wasOn = old && old != Init;\n    if (!value != !wasOn) {\n      var funcs = cm.display.dragFunctions;\n      var toggle = value ? on : off;\n      toggle(cm.display.scroller, \"dragstart\", funcs.start);\n      toggle(cm.display.scroller, \"dragenter\", funcs.enter);\n      toggle(cm.display.scroller, \"dragover\", funcs.over);\n      toggle(cm.display.scroller, \"dragleave\", funcs.leave);\n      toggle(cm.display.scroller, \"drop\", funcs.drop);\n    }\n  }\n\n  function wrappingChanged(cm) {\n    if (cm.options.lineWrapping) {\n      addClass(cm.display.wrapper, \"CodeMirror-wrap\");\n      cm.display.sizer.style.minWidth = \"\";\n      cm.display.sizerWidth = null;\n    } else {\n      rmClass(cm.display.wrapper, \"CodeMirror-wrap\");\n      findMaxLine(cm);\n    }\n    estimateLineHeights(cm);\n    regChange(cm);\n    clearCaches(cm);\n    setTimeout(function () { return updateScrollbars(cm); }, 100);\n  }\n\n  // A CodeMirror instance represents an editor. This is the object\n  // that user code is usually dealing with.\n\n  function CodeMirror(place, options) {\n    var this$1 = this;\n\n    if (!(this instanceof CodeMirror)) { return new CodeMirror(place, options) }\n\n    this.options = options = options ? copyObj(options) : {};\n    // Determine effective options based on given values and defaults.\n    copyObj(defaults, options, false);\n    setGuttersForLineNumbers(options);\n\n    var doc = options.value;\n    if (typeof doc == \"string\") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }\n    else if (options.mode) { doc.modeOption = options.mode; }\n    this.doc = doc;\n\n    var input = new CodeMirror.inputStyles[options.inputStyle](this);\n    var display = this.display = new Display(place, doc, input);\n    display.wrapper.CodeMirror = this;\n    updateGutters(this);\n    themeChanged(this);\n    if (options.lineWrapping)\n      { this.display.wrapper.className += \" CodeMirror-wrap\"; }\n    initScrollbars(this);\n\n    this.state = {\n      keyMaps: [],  // stores maps added by addKeyMap\n      overlays: [], // highlighting overlays, as added by addOverlay\n      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info\n      overwrite: false,\n      delayingBlurEvent: false,\n      focused: false,\n      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode\n      pasteIncoming: -1, cutIncoming: -1, // help recognize paste/cut edits in input.poll\n      selectingText: false,\n      draggingText: false,\n      highlight: new Delayed(), // stores highlight worker timeout\n      keySeq: null,  // Unfinished key sequence\n      specialChars: null\n    };\n\n    if (options.autofocus && !mobile) { display.input.focus(); }\n\n    // Override magic textarea content restore that IE sometimes does\n    // on our hidden textarea on reload\n    if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }\n\n    registerEventHandlers(this);\n    ensureGlobalHandlers();\n\n    startOperation(this);\n    this.curOp.forceUpdate = true;\n    attachDoc(this, doc);\n\n    if ((options.autofocus && !mobile) || this.hasFocus())\n      { setTimeout(bind(onFocus, this), 20); }\n    else\n      { onBlur(this); }\n\n    for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))\n      { optionHandlers[opt](this$1, options[opt], Init); } }\n    maybeUpdateLineNumberWidth(this);\n    if (options.finishInit) { options.finishInit(this); }\n    for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this$1); }\n    endOperation(this);\n    // Suppress optimizelegibility in Webkit, since it breaks text\n    // measuring on line wrapping boundaries.\n    if (webkit && options.lineWrapping &&\n        getComputedStyle(display.lineDiv).textRendering == \"optimizelegibility\")\n      { display.lineDiv.style.textRendering = \"auto\"; }\n  }\n\n  // The default configuration options.\n  CodeMirror.defaults = defaults;\n  // Functions to run when options are changed.\n  CodeMirror.optionHandlers = optionHandlers;\n\n  // Attach the necessary event handlers when initializing the editor\n  function registerEventHandlers(cm) {\n    var d = cm.display;\n    on(d.scroller, \"mousedown\", operation(cm, onMouseDown));\n    // Older IE's will not fire a second mousedown for a double click\n    if (ie && ie_version < 11)\n      { on(d.scroller, \"dblclick\", operation(cm, function (e) {\n        if (signalDOMEvent(cm, e)) { return }\n        var pos = posFromMouse(cm, e);\n        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }\n        e_preventDefault(e);\n        var word = cm.findWordAt(pos);\n        extendSelection(cm.doc, word.anchor, word.head);\n      })); }\n    else\n      { on(d.scroller, \"dblclick\", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }\n    // Some browsers fire contextmenu *after* opening the menu, at\n    // which point we can't mess with it anymore. Context menu is\n    // handled in onMouseDown for these browsers.\n    on(d.scroller, \"contextmenu\", function (e) { return onContextMenu(cm, e); });\n\n    // Used to suppress mouse event handling when a touch happens\n    var touchFinished, prevTouch = {end: 0};\n    function finishTouch() {\n      if (d.activeTouch) {\n        touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);\n        prevTouch = d.activeTouch;\n        prevTouch.end = +new Date;\n      }\n    }\n    function isMouseLikeTouchEvent(e) {\n      if (e.touches.length != 1) { return false }\n      var touch = e.touches[0];\n      return touch.radiusX <= 1 && touch.radiusY <= 1\n    }\n    function farAway(touch, other) {\n      if (other.left == null) { return true }\n      var dx = other.left - touch.left, dy = other.top - touch.top;\n      return dx * dx + dy * dy > 20 * 20\n    }\n    on(d.scroller, \"touchstart\", function (e) {\n      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {\n        d.input.ensurePolled();\n        clearTimeout(touchFinished);\n        var now = +new Date;\n        d.activeTouch = {start: now, moved: false,\n                         prev: now - prevTouch.end <= 300 ? prevTouch : null};\n        if (e.touches.length == 1) {\n          d.activeTouch.left = e.touches[0].pageX;\n          d.activeTouch.top = e.touches[0].pageY;\n        }\n      }\n    });\n    on(d.scroller, \"touchmove\", function () {\n      if (d.activeTouch) { d.activeTouch.moved = true; }\n    });\n    on(d.scroller, \"touchend\", function (e) {\n      var touch = d.activeTouch;\n      if (touch && !eventInWidget(d, e) && touch.left != null &&\n          !touch.moved && new Date - touch.start < 300) {\n        var pos = cm.coordsChar(d.activeTouch, \"page\"), range;\n        if (!touch.prev || farAway(touch, touch.prev)) // Single tap\n          { range = new Range(pos, pos); }\n        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap\n          { range = cm.findWordAt(pos); }\n        else // Triple tap\n          { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }\n        cm.setSelection(range.anchor, range.head);\n        cm.focus();\n        e_preventDefault(e);\n      }\n      finishTouch();\n    });\n    on(d.scroller, \"touchcancel\", finishTouch);\n\n    // Sync scrolling between fake scrollbars and real scrollable\n    // area, ensure viewport is updated when scrolling.\n    on(d.scroller, \"scroll\", function () {\n      if (d.scroller.clientHeight) {\n        updateScrollTop(cm, d.scroller.scrollTop);\n        setScrollLeft(cm, d.scroller.scrollLeft, true);\n        signal(cm, \"scroll\", cm);\n      }\n    });\n\n    // Listen to wheel events in order to try and update the viewport on time.\n    on(d.scroller, \"mousewheel\", function (e) { return onScrollWheel(cm, e); });\n    on(d.scroller, \"DOMMouseScroll\", function (e) { return onScrollWheel(cm, e); });\n\n    // Prevent wrapper from ever scrolling\n    on(d.wrapper, \"scroll\", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });\n\n    d.dragFunctions = {\n      enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},\n      over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},\n      start: function (e) { return onDragStart(cm, e); },\n      drop: operation(cm, onDrop),\n      leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}\n    };\n\n    var inp = d.input.getField();\n    on(inp, \"keyup\", function (e) { return onKeyUp.call(cm, e); });\n    on(inp, \"keydown\", operation(cm, onKeyDown));\n    on(inp, \"keypress\", operation(cm, onKeyPress));\n    on(inp, \"focus\", function (e) { return onFocus(cm, e); });\n    on(inp, \"blur\", function (e) { return onBlur(cm, e); });\n  }\n\n  var initHooks = [];\n  CodeMirror.defineInitHook = function (f) { return initHooks.push(f); };\n\n  // Indent the given line. The how parameter can be \"smart\",\n  // \"add\"/null, \"subtract\", or \"prev\". When aggressive is false\n  // (typically set to true for forced single-line indents), empty\n  // lines are not indented, and places where the mode returns Pass\n  // are left alone.\n  function indentLine(cm, n, how, aggressive) {\n    var doc = cm.doc, state;\n    if (how == null) { how = \"add\"; }\n    if (how == \"smart\") {\n      // Fall back to \"prev\" when the mode doesn't have an indentation\n      // method.\n      if (!doc.mode.indent) { how = \"prev\"; }\n      else { state = getContextBefore(cm, n).state; }\n    }\n\n    var tabSize = cm.options.tabSize;\n    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);\n    if (line.stateAfter) { line.stateAfter = null; }\n    var curSpaceString = line.text.match(/^\\s*/)[0], indentation;\n    if (!aggressive && !/\\S/.test(line.text)) {\n      indentation = 0;\n      how = \"not\";\n    } else if (how == \"smart\") {\n      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);\n      if (indentation == Pass || indentation > 150) {\n        if (!aggressive) { return }\n        how = \"prev\";\n      }\n    }\n    if (how == \"prev\") {\n      if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }\n      else { indentation = 0; }\n    } else if (how == \"add\") {\n      indentation = curSpace + cm.options.indentUnit;\n    } else if (how == \"subtract\") {\n      indentation = curSpace - cm.options.indentUnit;\n    } else if (typeof how == \"number\") {\n      indentation = curSpace + how;\n    }\n    indentation = Math.max(0, indentation);\n\n    var indentString = \"\", pos = 0;\n    if (cm.options.indentWithTabs)\n      { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += \"\\t\";} }\n    if (pos < indentation) { indentString += spaceStr(indentation - pos); }\n\n    if (indentString != curSpaceString) {\n      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), \"+input\");\n      line.stateAfter = null;\n      return true\n    } else {\n      // Ensure that, if the cursor was in the whitespace at the start\n      // of the line, it is moved to the end of that space.\n      for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {\n        var range = doc.sel.ranges[i$1];\n        if (range.head.line == n && range.head.ch < curSpaceString.length) {\n          var pos$1 = Pos(n, curSpaceString.length);\n          replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));\n          break\n        }\n      }\n    }\n  }\n\n  // This will be set to a {lineWise: bool, text: [string]} object, so\n  // that, when pasting, we know what kind of selections the copied\n  // text was made out of.\n  var lastCopied = null;\n\n  function setLastCopied(newLastCopied) {\n    lastCopied = newLastCopied;\n  }\n\n  function applyTextInput(cm, inserted, deleted, sel, origin) {\n    var doc = cm.doc;\n    cm.display.shift = false;\n    if (!sel) { sel = doc.sel; }\n\n    var recent = +new Date - 200;\n    var paste = origin == \"paste\" || cm.state.pasteIncoming > recent;\n    var textLines = splitLinesAuto(inserted), multiPaste = null;\n    // When pasting N lines into N selections, insert one line per selection\n    if (paste && sel.ranges.length > 1) {\n      if (lastCopied && lastCopied.text.join(\"\\n\") == inserted) {\n        if (sel.ranges.length % lastCopied.text.length == 0) {\n          multiPaste = [];\n          for (var i = 0; i < lastCopied.text.length; i++)\n            { multiPaste.push(doc.splitLines(lastCopied.text[i])); }\n        }\n      } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {\n        multiPaste = map(textLines, function (l) { return [l]; });\n      }\n    }\n\n    var updateInput = cm.curOp.updateInput;\n    // Normal behavior is to insert the new text into every selection\n    for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {\n      var range$$1 = sel.ranges[i$1];\n      var from = range$$1.from(), to = range$$1.to();\n      if (range$$1.empty()) {\n        if (deleted && deleted > 0) // Handle deletion\n          { from = Pos(from.line, from.ch - deleted); }\n        else if (cm.state.overwrite && !paste) // Handle overwrite\n          { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }\n        else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join(\"\\n\") == inserted)\n          { from = to = Pos(from.line, 0); }\n      }\n      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,\n                         origin: origin || (paste ? \"paste\" : cm.state.cutIncoming > recent ? \"cut\" : \"+input\")};\n      makeChange(cm.doc, changeEvent);\n      signalLater(cm, \"inputRead\", cm, changeEvent);\n    }\n    if (inserted && !paste)\n      { triggerElectric(cm, inserted); }\n\n    ensureCursorVisible(cm);\n    if (cm.curOp.updateInput < 2) { cm.curOp.updateInput = updateInput; }\n    cm.curOp.typing = true;\n    cm.state.pasteIncoming = cm.state.cutIncoming = -1;\n  }\n\n  function handlePaste(e, cm) {\n    var pasted = e.clipboardData && e.clipboardData.getData(\"Text\");\n    if (pasted) {\n      e.preventDefault();\n      if (!cm.isReadOnly() && !cm.options.disableInput)\n        { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, \"paste\"); }); }\n      return true\n    }\n  }\n\n  function triggerElectric(cm, inserted) {\n    // When an 'electric' character is inserted, immediately trigger a reindent\n    if (!cm.options.electricChars || !cm.options.smartIndent) { return }\n    var sel = cm.doc.sel;\n\n    for (var i = sel.ranges.length - 1; i >= 0; i--) {\n      var range$$1 = sel.ranges[i];\n      if (range$$1.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range$$1.head.line)) { continue }\n      var mode = cm.getModeAt(range$$1.head);\n      var indented = false;\n      if (mode.electricChars) {\n        for (var j = 0; j < mode.electricChars.length; j++)\n          { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {\n            indented = indentLine(cm, range$$1.head.line, \"smart\");\n            break\n          } }\n      } else if (mode.electricInput) {\n        if (mode.electricInput.test(getLine(cm.doc, range$$1.head.line).text.slice(0, range$$1.head.ch)))\n          { indented = indentLine(cm, range$$1.head.line, \"smart\"); }\n      }\n      if (indented) { signalLater(cm, \"electricInput\", cm, range$$1.head.line); }\n    }\n  }\n\n  function copyableRanges(cm) {\n    var text = [], ranges = [];\n    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {\n      var line = cm.doc.sel.ranges[i].head.line;\n      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};\n      ranges.push(lineRange);\n      text.push(cm.getRange(lineRange.anchor, lineRange.head));\n    }\n    return {text: text, ranges: ranges}\n  }\n\n  function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {\n    field.setAttribute(\"autocorrect\", !!autocorrect);\n    field.setAttribute(\"autocapitalize\", !!autocapitalize);\n    field.setAttribute(\"spellcheck\", !!spellcheck);\n  }\n\n  function hiddenTextarea() {\n    var te = elt(\"textarea\", null, null, \"position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none\");\n    var div = elt(\"div\", [te], null, \"overflow: hidden; position: relative; width: 3px; height: 0px;\");\n    // The textarea is kept positioned near the cursor to prevent the\n    // fact that it'll be scrolled into view on input from scrolling\n    // our fake cursor out of view. On webkit, when wrap=off, paste is\n    // very slow. So make the area wide instead.\n    if (webkit) { te.style.width = \"1000px\"; }\n    else { te.setAttribute(\"wrap\", \"off\"); }\n    // If border: 0; -- iOS fails to open keyboard (issue #1287)\n    if (ios) { te.style.border = \"1px solid black\"; }\n    disableBrowserMagic(te);\n    return div\n  }\n\n  // The publicly visible API. Note that methodOp(f) means\n  // 'wrap f in an operation, performed on its `this` parameter'.\n\n  // This is not the complete set of editor methods. Most of the\n  // methods defined on the Doc type are also injected into\n  // CodeMirror.prototype, for backwards compatibility and\n  // convenience.\n\n  function addEditorMethods(CodeMirror) {\n    var optionHandlers = CodeMirror.optionHandlers;\n\n    var helpers = CodeMirror.helpers = {};\n\n    CodeMirror.prototype = {\n      constructor: CodeMirror,\n      focus: function(){window.focus(); this.display.input.focus();},\n\n      setOption: function(option, value) {\n        var options = this.options, old = options[option];\n        if (options[option] == value && option != \"mode\") { return }\n        options[option] = value;\n        if (optionHandlers.hasOwnProperty(option))\n          { operation(this, optionHandlers[option])(this, value, old); }\n        signal(this, \"optionChange\", this, option);\n      },\n\n      getOption: function(option) {return this.options[option]},\n      getDoc: function() {return this.doc},\n\n      addKeyMap: function(map$$1, bottom) {\n        this.state.keyMaps[bottom ? \"push\" : \"unshift\"](getKeyMap(map$$1));\n      },\n      removeKeyMap: function(map$$1) {\n        var maps = this.state.keyMaps;\n        for (var i = 0; i < maps.length; ++i)\n          { if (maps[i] == map$$1 || maps[i].name == map$$1) {\n            maps.splice(i, 1);\n            return true\n          } }\n      },\n\n      addOverlay: methodOp(function(spec, options) {\n        var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);\n        if (mode.startState) { throw new Error(\"Overlays may not be stateful.\") }\n        insertSorted(this.state.overlays,\n                     {mode: mode, modeSpec: spec, opaque: options && options.opaque,\n                      priority: (options && options.priority) || 0},\n                     function (overlay) { return overlay.priority; });\n        this.state.modeGen++;\n        regChange(this);\n      }),\n      removeOverlay: methodOp(function(spec) {\n        var this$1 = this;\n\n        var overlays = this.state.overlays;\n        for (var i = 0; i < overlays.length; ++i) {\n          var cur = overlays[i].modeSpec;\n          if (cur == spec || typeof spec == \"string\" && cur.name == spec) {\n            overlays.splice(i, 1);\n            this$1.state.modeGen++;\n            regChange(this$1);\n            return\n          }\n        }\n      }),\n\n      indentLine: methodOp(function(n, dir, aggressive) {\n        if (typeof dir != \"string\" && typeof dir != \"number\") {\n          if (dir == null) { dir = this.options.smartIndent ? \"smart\" : \"prev\"; }\n          else { dir = dir ? \"add\" : \"subtract\"; }\n        }\n        if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }\n      }),\n      indentSelection: methodOp(function(how) {\n        var this$1 = this;\n\n        var ranges = this.doc.sel.ranges, end = -1;\n        for (var i = 0; i < ranges.length; i++) {\n          var range$$1 = ranges[i];\n          if (!range$$1.empty()) {\n            var from = range$$1.from(), to = range$$1.to();\n            var start = Math.max(end, from.line);\n            end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;\n            for (var j = start; j < end; ++j)\n              { indentLine(this$1, j, how); }\n            var newRanges = this$1.doc.sel.ranges;\n            if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)\n              { replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }\n          } else if (range$$1.head.line > end) {\n            indentLine(this$1, range$$1.head.line, how, true);\n            end = range$$1.head.line;\n            if (i == this$1.doc.sel.primIndex) { ensureCursorVisible(this$1); }\n          }\n        }\n      }),\n\n      // Fetch the parser token for a given character. Useful for hacks\n      // that want to inspect the mode state (say, for completion).\n      getTokenAt: function(pos, precise) {\n        return takeToken(this, pos, precise)\n      },\n\n      getLineTokens: function(line, precise) {\n        return takeToken(this, Pos(line), precise, true)\n      },\n\n      getTokenTypeAt: function(pos) {\n        pos = clipPos(this.doc, pos);\n        var styles = getLineStyles(this, getLine(this.doc, pos.line));\n        var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;\n        var type;\n        if (ch == 0) { type = styles[2]; }\n        else { for (;;) {\n          var mid = (before + after) >> 1;\n          if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid; }\n          else if (styles[mid * 2 + 1] < ch) { before = mid + 1; }\n          else { type = styles[mid * 2 + 2]; break }\n        } }\n        var cut = type ? type.indexOf(\"overlay \") : -1;\n        return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)\n      },\n\n      getModeAt: function(pos) {\n        var mode = this.doc.mode;\n        if (!mode.innerMode) { return mode }\n        return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode\n      },\n\n      getHelper: function(pos, type) {\n        return this.getHelpers(pos, type)[0]\n      },\n\n      getHelpers: function(pos, type) {\n        var this$1 = this;\n\n        var found = [];\n        if (!helpers.hasOwnProperty(type)) { return found }\n        var help = helpers[type], mode = this.getModeAt(pos);\n        if (typeof mode[type] == \"string\") {\n          if (help[mode[type]]) { found.push(help[mode[type]]); }\n        } else if (mode[type]) {\n          for (var i = 0; i < mode[type].length; i++) {\n            var val = help[mode[type][i]];\n            if (val) { found.push(val); }\n          }\n        } else if (mode.helperType && help[mode.helperType]) {\n          found.push(help[mode.helperType]);\n        } else if (help[mode.name]) {\n          found.push(help[mode.name]);\n        }\n        for (var i$1 = 0; i$1 < help._global.length; i$1++) {\n          var cur = help._global[i$1];\n          if (cur.pred(mode, this$1) && indexOf(found, cur.val) == -1)\n            { found.push(cur.val); }\n        }\n        return found\n      },\n\n      getStateAfter: function(line, precise) {\n        var doc = this.doc;\n        line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);\n        return getContextBefore(this, line + 1, precise).state\n      },\n\n      cursorCoords: function(start, mode) {\n        var pos, range$$1 = this.doc.sel.primary();\n        if (start == null) { pos = range$$1.head; }\n        else if (typeof start == \"object\") { pos = clipPos(this.doc, start); }\n        else { pos = start ? range$$1.from() : range$$1.to(); }\n        return cursorCoords(this, pos, mode || \"page\")\n      },\n\n      charCoords: function(pos, mode) {\n        return charCoords(this, clipPos(this.doc, pos), mode || \"page\")\n      },\n\n      coordsChar: function(coords, mode) {\n        coords = fromCoordSystem(this, coords, mode || \"page\");\n        return coordsChar(this, coords.left, coords.top)\n      },\n\n      lineAtHeight: function(height, mode) {\n        height = fromCoordSystem(this, {top: height, left: 0}, mode || \"page\").top;\n        return lineAtHeight(this.doc, height + this.display.viewOffset)\n      },\n      heightAtLine: function(line, mode, includeWidgets) {\n        var end = false, lineObj;\n        if (typeof line == \"number\") {\n          var last = this.doc.first + this.doc.size - 1;\n          if (line < this.doc.first) { line = this.doc.first; }\n          else if (line > last) { line = last; end = true; }\n          lineObj = getLine(this.doc, line);\n        } else {\n          lineObj = line;\n        }\n        return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || \"page\", includeWidgets || end).top +\n          (end ? this.doc.height - heightAtLine(lineObj) : 0)\n      },\n\n      defaultTextHeight: function() { return textHeight(this.display) },\n      defaultCharWidth: function() { return charWidth(this.display) },\n\n      getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},\n\n      addWidget: function(pos, node, scroll, vert, horiz) {\n        var display = this.display;\n        pos = cursorCoords(this, clipPos(this.doc, pos));\n        var top = pos.bottom, left = pos.left;\n        node.style.position = \"absolute\";\n        node.setAttribute(\"cm-ignore-events\", \"true\");\n        this.display.input.setUneditable(node);\n        display.sizer.appendChild(node);\n        if (vert == \"over\") {\n          top = pos.top;\n        } else if (vert == \"above\" || vert == \"near\") {\n          var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),\n          hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);\n          // Default to positioning above (if specified and possible); otherwise default to positioning below\n          if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)\n            { top = pos.top - node.offsetHeight; }\n          else if (pos.bottom + node.offsetHeight <= vspace)\n            { top = pos.bottom; }\n          if (left + node.offsetWidth > hspace)\n            { left = hspace - node.offsetWidth; }\n        }\n        node.style.top = top + \"px\";\n        node.style.left = node.style.right = \"\";\n        if (horiz == \"right\") {\n          left = display.sizer.clientWidth - node.offsetWidth;\n          node.style.right = \"0px\";\n        } else {\n          if (horiz == \"left\") { left = 0; }\n          else if (horiz == \"middle\") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }\n          node.style.left = left + \"px\";\n        }\n        if (scroll)\n          { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }\n      },\n\n      triggerOnKeyDown: methodOp(onKeyDown),\n      triggerOnKeyPress: methodOp(onKeyPress),\n      triggerOnKeyUp: onKeyUp,\n      triggerOnMouseDown: methodOp(onMouseDown),\n\n      execCommand: function(cmd) {\n        if (commands.hasOwnProperty(cmd))\n          { return commands[cmd].call(null, this) }\n      },\n\n      triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),\n\n      findPosH: function(from, amount, unit, visually) {\n        var this$1 = this;\n\n        var dir = 1;\n        if (amount < 0) { dir = -1; amount = -amount; }\n        var cur = clipPos(this.doc, from);\n        for (var i = 0; i < amount; ++i) {\n          cur = findPosH(this$1.doc, cur, dir, unit, visually);\n          if (cur.hitSide) { break }\n        }\n        return cur\n      },\n\n      moveH: methodOp(function(dir, unit) {\n        var this$1 = this;\n\n        this.extendSelectionsBy(function (range$$1) {\n          if (this$1.display.shift || this$1.doc.extend || range$$1.empty())\n            { return findPosH(this$1.doc, range$$1.head, dir, unit, this$1.options.rtlMoveVisually) }\n          else\n            { return dir < 0 ? range$$1.from() : range$$1.to() }\n        }, sel_move);\n      }),\n\n      deleteH: methodOp(function(dir, unit) {\n        var sel = this.doc.sel, doc = this.doc;\n        if (sel.somethingSelected())\n          { doc.replaceSelection(\"\", null, \"+delete\"); }\n        else\n          { deleteNearSelection(this, function (range$$1) {\n            var other = findPosH(doc, range$$1.head, dir, unit, false);\n            return dir < 0 ? {from: other, to: range$$1.head} : {from: range$$1.head, to: other}\n          }); }\n      }),\n\n      findPosV: function(from, amount, unit, goalColumn) {\n        var this$1 = this;\n\n        var dir = 1, x = goalColumn;\n        if (amount < 0) { dir = -1; amount = -amount; }\n        var cur = clipPos(this.doc, from);\n        for (var i = 0; i < amount; ++i) {\n          var coords = cursorCoords(this$1, cur, \"div\");\n          if (x == null) { x = coords.left; }\n          else { coords.left = x; }\n          cur = findPosV(this$1, coords, dir, unit);\n          if (cur.hitSide) { break }\n        }\n        return cur\n      },\n\n      moveV: methodOp(function(dir, unit) {\n        var this$1 = this;\n\n        var doc = this.doc, goals = [];\n        var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();\n        doc.extendSelectionsBy(function (range$$1) {\n          if (collapse)\n            { return dir < 0 ? range$$1.from() : range$$1.to() }\n          var headPos = cursorCoords(this$1, range$$1.head, \"div\");\n          if (range$$1.goalColumn != null) { headPos.left = range$$1.goalColumn; }\n          goals.push(headPos.left);\n          var pos = findPosV(this$1, headPos, dir, unit);\n          if (unit == \"page\" && range$$1 == doc.sel.primary())\n            { addToScrollTop(this$1, charCoords(this$1, pos, \"div\").top - headPos.top); }\n          return pos\n        }, sel_move);\n        if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)\n          { doc.sel.ranges[i].goalColumn = goals[i]; } }\n      }),\n\n      // Find the word at the given position (as returned by coordsChar).\n      findWordAt: function(pos) {\n        var doc = this.doc, line = getLine(doc, pos.line).text;\n        var start = pos.ch, end = pos.ch;\n        if (line) {\n          var helper = this.getHelper(pos, \"wordChars\");\n          if ((pos.sticky == \"before\" || end == line.length) && start) { --start; } else { ++end; }\n          var startChar = line.charAt(start);\n          var check = isWordChar(startChar, helper)\n            ? function (ch) { return isWordChar(ch, helper); }\n            : /\\s/.test(startChar) ? function (ch) { return /\\s/.test(ch); }\n            : function (ch) { return (!/\\s/.test(ch) && !isWordChar(ch)); };\n          while (start > 0 && check(line.charAt(start - 1))) { --start; }\n          while (end < line.length && check(line.charAt(end))) { ++end; }\n        }\n        return new Range(Pos(pos.line, start), Pos(pos.line, end))\n      },\n\n      toggleOverwrite: function(value) {\n        if (value != null && value == this.state.overwrite) { return }\n        if (this.state.overwrite = !this.state.overwrite)\n          { addClass(this.display.cursorDiv, \"CodeMirror-overwrite\"); }\n        else\n          { rmClass(this.display.cursorDiv, \"CodeMirror-overwrite\"); }\n\n        signal(this, \"overwriteToggle\", this, this.state.overwrite);\n      },\n      hasFocus: function() { return this.display.input.getField() == activeElt() },\n      isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },\n\n      scrollTo: methodOp(function (x, y) { scrollToCoords(this, x, y); }),\n      getScrollInfo: function() {\n        var scroller = this.display.scroller;\n        return {left: scroller.scrollLeft, top: scroller.scrollTop,\n                height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,\n                width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,\n                clientHeight: displayHeight(this), clientWidth: displayWidth(this)}\n      },\n\n      scrollIntoView: methodOp(function(range$$1, margin) {\n        if (range$$1 == null) {\n          range$$1 = {from: this.doc.sel.primary().head, to: null};\n          if (margin == null) { margin = this.options.cursorScrollMargin; }\n        } else if (typeof range$$1 == \"number\") {\n          range$$1 = {from: Pos(range$$1, 0), to: null};\n        } else if (range$$1.from == null) {\n          range$$1 = {from: range$$1, to: null};\n        }\n        if (!range$$1.to) { range$$1.to = range$$1.from; }\n        range$$1.margin = margin || 0;\n\n        if (range$$1.from.line != null) {\n          scrollToRange(this, range$$1);\n        } else {\n          scrollToCoordsRange(this, range$$1.from, range$$1.to, range$$1.margin);\n        }\n      }),\n\n      setSize: methodOp(function(width, height) {\n        var this$1 = this;\n\n        var interpret = function (val) { return typeof val == \"number\" || /^\\d+$/.test(String(val)) ? val + \"px\" : val; };\n        if (width != null) { this.display.wrapper.style.width = interpret(width); }\n        if (height != null) { this.display.wrapper.style.height = interpret(height); }\n        if (this.options.lineWrapping) { clearLineMeasurementCache(this); }\n        var lineNo$$1 = this.display.viewFrom;\n        this.doc.iter(lineNo$$1, this.display.viewTo, function (line) {\n          if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)\n            { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo$$1, \"widget\"); break } } }\n          ++lineNo$$1;\n        });\n        this.curOp.forceUpdate = true;\n        signal(this, \"refresh\", this);\n      }),\n\n      operation: function(f){return runInOp(this, f)},\n      startOperation: function(){return startOperation(this)},\n      endOperation: function(){return endOperation(this)},\n\n      refresh: methodOp(function() {\n        var oldHeight = this.display.cachedTextHeight;\n        regChange(this);\n        this.curOp.forceUpdate = true;\n        clearCaches(this);\n        scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);\n        updateGutterSpace(this);\n        if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5)\n          { estimateLineHeights(this); }\n        signal(this, \"refresh\", this);\n      }),\n\n      swapDoc: methodOp(function(doc) {\n        var old = this.doc;\n        old.cm = null;\n        attachDoc(this, doc);\n        clearCaches(this);\n        this.display.input.reset();\n        scrollToCoords(this, doc.scrollLeft, doc.scrollTop);\n        this.curOp.forceScroll = true;\n        signalLater(this, \"swapDoc\", this, old);\n        return old\n      }),\n\n      phrase: function(phraseText) {\n        var phrases = this.options.phrases;\n        return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText\n      },\n\n      getInputField: function(){return this.display.input.getField()},\n      getWrapperElement: function(){return this.display.wrapper},\n      getScrollerElement: function(){return this.display.scroller},\n      getGutterElement: function(){return this.display.gutters}\n    };\n    eventMixin(CodeMirror);\n\n    CodeMirror.registerHelper = function(type, name, value) {\n      if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }\n      helpers[type][name] = value;\n    };\n    CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {\n      CodeMirror.registerHelper(type, name, value);\n      helpers[type]._global.push({pred: predicate, val: value});\n    };\n  }\n\n  // Used for horizontal relative motion. Dir is -1 or 1 (left or\n  // right), unit can be \"char\", \"column\" (like char, but doesn't\n  // cross line boundaries), \"word\" (across next word), or \"group\" (to\n  // the start of next group of word or non-word-non-whitespace\n  // chars). The visually param controls whether, in right-to-left\n  // text, direction 1 means to move towards the next index in the\n  // string, or towards the character to the right of the current\n  // position. The resulting position will have a hitSide=true\n  // property if it reached the end of the document.\n  function findPosH(doc, pos, dir, unit, visually) {\n    var oldPos = pos;\n    var origDir = dir;\n    var lineObj = getLine(doc, pos.line);\n    function findNextLine() {\n      var l = pos.line + dir;\n      if (l < doc.first || l >= doc.first + doc.size) { return false }\n      pos = new Pos(l, pos.ch, pos.sticky);\n      return lineObj = getLine(doc, l)\n    }\n    function moveOnce(boundToLine) {\n      var next;\n      if (visually) {\n        next = moveVisually(doc.cm, lineObj, pos, dir);\n      } else {\n        next = moveLogically(lineObj, pos, dir);\n      }\n      if (next == null) {\n        if (!boundToLine && findNextLine())\n          { pos = endOfLine(visually, doc.cm, lineObj, pos.line, dir); }\n        else\n          { return false }\n      } else {\n        pos = next;\n      }\n      return true\n    }\n\n    if (unit == \"char\") {\n      moveOnce();\n    } else if (unit == \"column\") {\n      moveOnce(true);\n    } else if (unit == \"word\" || unit == \"group\") {\n      var sawType = null, group = unit == \"group\";\n      var helper = doc.cm && doc.cm.getHelper(pos, \"wordChars\");\n      for (var first = true;; first = false) {\n        if (dir < 0 && !moveOnce(!first)) { break }\n        var cur = lineObj.text.charAt(pos.ch) || \"\\n\";\n        var type = isWordChar(cur, helper) ? \"w\"\n          : group && cur == \"\\n\" ? \"n\"\n          : !group || /\\s/.test(cur) ? null\n          : \"p\";\n        if (group && !first && !type) { type = \"s\"; }\n        if (sawType && sawType != type) {\n          if (dir < 0) {dir = 1; moveOnce(); pos.sticky = \"after\";}\n          break\n        }\n\n        if (type) { sawType = type; }\n        if (dir > 0 && !moveOnce(!first)) { break }\n      }\n    }\n    var result = skipAtomic(doc, pos, oldPos, origDir, true);\n    if (equalCursorPos(oldPos, result)) { result.hitSide = true; }\n    return result\n  }\n\n  // For relative vertical movement. Dir may be -1 or 1. Unit can be\n  // \"page\" or \"line\". The resulting position will have a hitSide=true\n  // property if it reached the end of the document.\n  function findPosV(cm, pos, dir, unit) {\n    var doc = cm.doc, x = pos.left, y;\n    if (unit == \"page\") {\n      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);\n      var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);\n      y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;\n\n    } else if (unit == \"line\") {\n      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;\n    }\n    var target;\n    for (;;) {\n      target = coordsChar(cm, x, y);\n      if (!target.outside) { break }\n      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }\n      y += dir * 5;\n    }\n    return target\n  }\n\n  // CONTENTEDITABLE INPUT STYLE\n\n  var ContentEditableInput = function(cm) {\n    this.cm = cm;\n    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;\n    this.polling = new Delayed();\n    this.composing = null;\n    this.gracePeriod = false;\n    this.readDOMTimeout = null;\n  };\n\n  ContentEditableInput.prototype.init = function (display) {\n      var this$1 = this;\n\n    var input = this, cm = input.cm;\n    var div = input.div = display.lineDiv;\n    disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);\n\n    on(div, \"paste\", function (e) {\n      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\n      // IE doesn't fire input events, so we schedule a read for the pasted content in this way\n      if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }\n    });\n\n    on(div, \"compositionstart\", function (e) {\n      this$1.composing = {data: e.data, done: false};\n    });\n    on(div, \"compositionupdate\", function (e) {\n      if (!this$1.composing) { this$1.composing = {data: e.data, done: false}; }\n    });\n    on(div, \"compositionend\", function (e) {\n      if (this$1.composing) {\n        if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }\n        this$1.composing.done = true;\n      }\n    });\n\n    on(div, \"touchstart\", function () { return input.forceCompositionEnd(); });\n\n    on(div, \"input\", function () {\n      if (!this$1.composing) { this$1.readFromDOMSoon(); }\n    });\n\n    function onCopyCut(e) {\n      if (signalDOMEvent(cm, e)) { return }\n      if (cm.somethingSelected()) {\n        setLastCopied({lineWise: false, text: cm.getSelections()});\n        if (e.type == \"cut\") { cm.replaceSelection(\"\", null, \"cut\"); }\n      } else if (!cm.options.lineWiseCopyCut) {\n        return\n      } else {\n        var ranges = copyableRanges(cm);\n        setLastCopied({lineWise: true, text: ranges.text});\n        if (e.type == \"cut\") {\n          cm.operation(function () {\n            cm.setSelections(ranges.ranges, 0, sel_dontScroll);\n            cm.replaceSelection(\"\", null, \"cut\");\n          });\n        }\n      }\n      if (e.clipboardData) {\n        e.clipboardData.clearData();\n        var content = lastCopied.text.join(\"\\n\");\n        // iOS exposes the clipboard API, but seems to discard content inserted into it\n        e.clipboardData.setData(\"Text\", content);\n        if (e.clipboardData.getData(\"Text\") == content) {\n          e.preventDefault();\n          return\n        }\n      }\n      // Old-fashioned briefly-focus-a-textarea hack\n      var kludge = hiddenTextarea(), te = kludge.firstChild;\n      cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);\n      te.value = lastCopied.text.join(\"\\n\");\n      var hadFocus = document.activeElement;\n      selectInput(te);\n      setTimeout(function () {\n        cm.display.lineSpace.removeChild(kludge);\n        hadFocus.focus();\n        if (hadFocus == div) { input.showPrimarySelection(); }\n      }, 50);\n    }\n    on(div, \"copy\", onCopyCut);\n    on(div, \"cut\", onCopyCut);\n  };\n\n  ContentEditableInput.prototype.prepareSelection = function () {\n    var result = prepareSelection(this.cm, false);\n    result.focus = this.cm.state.focused;\n    return result\n  };\n\n  ContentEditableInput.prototype.showSelection = function (info, takeFocus) {\n    if (!info || !this.cm.display.view.length) { return }\n    if (info.focus || takeFocus) { this.showPrimarySelection(); }\n    this.showMultipleSelections(info);\n  };\n\n  ContentEditableInput.prototype.getSelection = function () {\n    return this.cm.display.wrapper.ownerDocument.getSelection()\n  };\n\n  ContentEditableInput.prototype.showPrimarySelection = function () {\n    var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();\n    var from = prim.from(), to = prim.to();\n\n    if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {\n      sel.removeAllRanges();\n      return\n    }\n\n    var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n    var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);\n    if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&\n        cmp(minPos(curAnchor, curFocus), from) == 0 &&\n        cmp(maxPos(curAnchor, curFocus), to) == 0)\n      { return }\n\n    var view = cm.display.view;\n    var start = (from.line >= cm.display.viewFrom && posToDOM(cm, from)) ||\n        {node: view[0].measure.map[2], offset: 0};\n    var end = to.line < cm.display.viewTo && posToDOM(cm, to);\n    if (!end) {\n      var measure = view[view.length - 1].measure;\n      var map$$1 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;\n      end = {node: map$$1[map$$1.length - 1], offset: map$$1[map$$1.length - 2] - map$$1[map$$1.length - 3]};\n    }\n\n    if (!start || !end) {\n      sel.removeAllRanges();\n      return\n    }\n\n    var old = sel.rangeCount && sel.getRangeAt(0), rng;\n    try { rng = range(start.node, start.offset, end.offset, end.node); }\n    catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible\n    if (rng) {\n      if (!gecko && cm.state.focused) {\n        sel.collapse(start.node, start.offset);\n        if (!rng.collapsed) {\n          sel.removeAllRanges();\n          sel.addRange(rng);\n        }\n      } else {\n        sel.removeAllRanges();\n        sel.addRange(rng);\n      }\n      if (old && sel.anchorNode == null) { sel.addRange(old); }\n      else if (gecko) { this.startGracePeriod(); }\n    }\n    this.rememberSelection();\n  };\n\n  ContentEditableInput.prototype.startGracePeriod = function () {\n      var this$1 = this;\n\n    clearTimeout(this.gracePeriod);\n    this.gracePeriod = setTimeout(function () {\n      this$1.gracePeriod = false;\n      if (this$1.selectionChanged())\n        { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }\n    }, 20);\n  };\n\n  ContentEditableInput.prototype.showMultipleSelections = function (info) {\n    removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);\n    removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);\n  };\n\n  ContentEditableInput.prototype.rememberSelection = function () {\n    var sel = this.getSelection();\n    this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;\n    this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;\n  };\n\n  ContentEditableInput.prototype.selectionInEditor = function () {\n    var sel = this.getSelection();\n    if (!sel.rangeCount) { return false }\n    var node = sel.getRangeAt(0).commonAncestorContainer;\n    return contains(this.div, node)\n  };\n\n  ContentEditableInput.prototype.focus = function () {\n    if (this.cm.options.readOnly != \"nocursor\") {\n      if (!this.selectionInEditor())\n        { this.showSelection(this.prepareSelection(), true); }\n      this.div.focus();\n    }\n  };\n  ContentEditableInput.prototype.blur = function () { this.div.blur(); };\n  ContentEditableInput.prototype.getField = function () { return this.div };\n\n  ContentEditableInput.prototype.supportsTouch = function () { return true };\n\n  ContentEditableInput.prototype.receivedFocus = function () {\n    var input = this;\n    if (this.selectionInEditor())\n      { this.pollSelection(); }\n    else\n      { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }\n\n    function poll() {\n      if (input.cm.state.focused) {\n        input.pollSelection();\n        input.polling.set(input.cm.options.pollInterval, poll);\n      }\n    }\n    this.polling.set(this.cm.options.pollInterval, poll);\n  };\n\n  ContentEditableInput.prototype.selectionChanged = function () {\n    var sel = this.getSelection();\n    return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||\n      sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset\n  };\n\n  ContentEditableInput.prototype.pollSelection = function () {\n    if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }\n    var sel = this.getSelection(), cm = this.cm;\n    // On Android Chrome (version 56, at least), backspacing into an\n    // uneditable block element will put the cursor in that element,\n    // and then, because it's not editable, hide the virtual keyboard.\n    // Because Android doesn't allow us to actually detect backspace\n    // presses in a sane way, this code checks for when that happens\n    // and simulates a backspace press in this case.\n    if (android && chrome && this.cm.options.gutters.length && isInGutter(sel.anchorNode)) {\n      this.cm.triggerOnKeyDown({type: \"keydown\", keyCode: 8, preventDefault: Math.abs});\n      this.blur();\n      this.focus();\n      return\n    }\n    if (this.composing) { return }\n    this.rememberSelection();\n    var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);\n    var head = domToPos(cm, sel.focusNode, sel.focusOffset);\n    if (anchor && head) { runInOp(cm, function () {\n      setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);\n      if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }\n    }); }\n  };\n\n  ContentEditableInput.prototype.pollContent = function () {\n    if (this.readDOMTimeout != null) {\n      clearTimeout(this.readDOMTimeout);\n      this.readDOMTimeout = null;\n    }\n\n    var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();\n    var from = sel.from(), to = sel.to();\n    if (from.ch == 0 && from.line > cm.firstLine())\n      { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }\n    if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())\n      { to = Pos(to.line + 1, 0); }\n    if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }\n\n    var fromIndex, fromLine, fromNode;\n    if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {\n      fromLine = lineNo(display.view[0].line);\n      fromNode = display.view[0].node;\n    } else {\n      fromLine = lineNo(display.view[fromIndex].line);\n      fromNode = display.view[fromIndex - 1].node.nextSibling;\n    }\n    var toIndex = findViewIndex(cm, to.line);\n    var toLine, toNode;\n    if (toIndex == display.view.length - 1) {\n      toLine = display.viewTo - 1;\n      toNode = display.lineDiv.lastChild;\n    } else {\n      toLine = lineNo(display.view[toIndex + 1].line) - 1;\n      toNode = display.view[toIndex + 1].node.previousSibling;\n    }\n\n    if (!fromNode) { return false }\n    var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));\n    var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));\n    while (newText.length > 1 && oldText.length > 1) {\n      if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }\n      else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }\n      else { break }\n    }\n\n    var cutFront = 0, cutEnd = 0;\n    var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);\n    while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))\n      { ++cutFront; }\n    var newBot = lst(newText), oldBot = lst(oldText);\n    var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),\n                             oldBot.length - (oldText.length == 1 ? cutFront : 0));\n    while (cutEnd < maxCutEnd &&\n           newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))\n      { ++cutEnd; }\n    // Try to move start of change to start of selection if ambiguous\n    if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {\n      while (cutFront && cutFront > from.ch &&\n             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {\n        cutFront--;\n        cutEnd++;\n      }\n    }\n\n    newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\\u200b+/, \"\");\n    newText[0] = newText[0].slice(cutFront).replace(/\\u200b+$/, \"\");\n\n    var chFrom = Pos(fromLine, cutFront);\n    var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);\n    if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {\n      replaceRange(cm.doc, newText, chFrom, chTo, \"+input\");\n      return true\n    }\n  };\n\n  ContentEditableInput.prototype.ensurePolled = function () {\n    this.forceCompositionEnd();\n  };\n  ContentEditableInput.prototype.reset = function () {\n    this.forceCompositionEnd();\n  };\n  ContentEditableInput.prototype.forceCompositionEnd = function () {\n    if (!this.composing) { return }\n    clearTimeout(this.readDOMTimeout);\n    this.composing = null;\n    this.updateFromDOM();\n    this.div.blur();\n    this.div.focus();\n  };\n  ContentEditableInput.prototype.readFromDOMSoon = function () {\n      var this$1 = this;\n\n    if (this.readDOMTimeout != null) { return }\n    this.readDOMTimeout = setTimeout(function () {\n      this$1.readDOMTimeout = null;\n      if (this$1.composing) {\n        if (this$1.composing.done) { this$1.composing = null; }\n        else { return }\n      }\n      this$1.updateFromDOM();\n    }, 80);\n  };\n\n  ContentEditableInput.prototype.updateFromDOM = function () {\n      var this$1 = this;\n\n    if (this.cm.isReadOnly() || !this.pollContent())\n      { runInOp(this.cm, function () { return regChange(this$1.cm); }); }\n  };\n\n  ContentEditableInput.prototype.setUneditable = function (node) {\n    node.contentEditable = \"false\";\n  };\n\n  ContentEditableInput.prototype.onKeyPress = function (e) {\n    if (e.charCode == 0 || this.composing) { return }\n    e.preventDefault();\n    if (!this.cm.isReadOnly())\n      { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }\n  };\n\n  ContentEditableInput.prototype.readOnlyChanged = function (val) {\n    this.div.contentEditable = String(val != \"nocursor\");\n  };\n\n  ContentEditableInput.prototype.onContextMenu = function () {};\n  ContentEditableInput.prototype.resetPosition = function () {};\n\n  ContentEditableInput.prototype.needsContentAttribute = true;\n\n  function posToDOM(cm, pos) {\n    var view = findViewForLine(cm, pos.line);\n    if (!view || view.hidden) { return null }\n    var line = getLine(cm.doc, pos.line);\n    var info = mapFromLineView(view, line, pos.line);\n\n    var order = getOrder(line, cm.doc.direction), side = \"left\";\n    if (order) {\n      var partPos = getBidiPartAt(order, pos.ch);\n      side = partPos % 2 ? \"right\" : \"left\";\n    }\n    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);\n    result.offset = result.collapse == \"right\" ? result.end : result.start;\n    return result\n  }\n\n  function isInGutter(node) {\n    for (var scan = node; scan; scan = scan.parentNode)\n      { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }\n    return false\n  }\n\n  function badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }\n\n  function domTextBetween(cm, from, to, fromLine, toLine) {\n    var text = \"\", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;\n    function recognizeMarker(id) { return function (marker) { return marker.id == id; } }\n    function close() {\n      if (closing) {\n        text += lineSep;\n        if (extraLinebreak) { text += lineSep; }\n        closing = extraLinebreak = false;\n      }\n    }\n    function addText(str) {\n      if (str) {\n        close();\n        text += str;\n      }\n    }\n    function walk(node) {\n      if (node.nodeType == 1) {\n        var cmText = node.getAttribute(\"cm-text\");\n        if (cmText) {\n          addText(cmText);\n          return\n        }\n        var markerID = node.getAttribute(\"cm-marker\"), range$$1;\n        if (markerID) {\n          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));\n          if (found.length && (range$$1 = found[0].find(0)))\n            { addText(getBetween(cm.doc, range$$1.from, range$$1.to).join(lineSep)); }\n          return\n        }\n        if (node.getAttribute(\"contenteditable\") == \"false\") { return }\n        var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);\n        if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) { return }\n\n        if (isBlock) { close(); }\n        for (var i = 0; i < node.childNodes.length; i++)\n          { walk(node.childNodes[i]); }\n\n        if (/^(pre|p)$/i.test(node.nodeName)) { extraLinebreak = true; }\n        if (isBlock) { closing = true; }\n      } else if (node.nodeType == 3) {\n        addText(node.nodeValue.replace(/\\u200b/g, \"\").replace(/\\u00a0/g, \" \"));\n      }\n    }\n    for (;;) {\n      walk(from);\n      if (from == to) { break }\n      from = from.nextSibling;\n      extraLinebreak = false;\n    }\n    return text\n  }\n\n  function domToPos(cm, node, offset) {\n    var lineNode;\n    if (node == cm.display.lineDiv) {\n      lineNode = cm.display.lineDiv.childNodes[offset];\n      if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }\n      node = null; offset = 0;\n    } else {\n      for (lineNode = node;; lineNode = lineNode.parentNode) {\n        if (!lineNode || lineNode == cm.display.lineDiv) { return null }\n        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }\n      }\n    }\n    for (var i = 0; i < cm.display.view.length; i++) {\n      var lineView = cm.display.view[i];\n      if (lineView.node == lineNode)\n        { return locateNodeInLineView(lineView, node, offset) }\n    }\n  }\n\n  function locateNodeInLineView(lineView, node, offset) {\n    var wrapper = lineView.text.firstChild, bad = false;\n    if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }\n    if (node == wrapper) {\n      bad = true;\n      node = wrapper.childNodes[offset];\n      offset = 0;\n      if (!node) {\n        var line = lineView.rest ? lst(lineView.rest) : lineView.line;\n        return badPos(Pos(lineNo(line), line.text.length), bad)\n      }\n    }\n\n    var textNode = node.nodeType == 3 ? node : null, topNode = node;\n    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {\n      textNode = node.firstChild;\n      if (offset) { offset = textNode.nodeValue.length; }\n    }\n    while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }\n    var measure = lineView.measure, maps = measure.maps;\n\n    function find(textNode, topNode, offset) {\n      for (var i = -1; i < (maps ? maps.length : 0); i++) {\n        var map$$1 = i < 0 ? measure.map : maps[i];\n        for (var j = 0; j < map$$1.length; j += 3) {\n          var curNode = map$$1[j + 2];\n          if (curNode == textNode || curNode == topNode) {\n            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);\n            var ch = map$$1[j] + offset;\n            if (offset < 0 || curNode != textNode) { ch = map$$1[j + (offset ? 1 : 0)]; }\n            return Pos(line, ch)\n          }\n        }\n      }\n    }\n    var found = find(textNode, topNode, offset);\n    if (found) { return badPos(found, bad) }\n\n    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems\n    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {\n      found = find(after, after.firstChild, 0);\n      if (found)\n        { return badPos(Pos(found.line, found.ch - dist), bad) }\n      else\n        { dist += after.textContent.length; }\n    }\n    for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {\n      found = find(before, before.firstChild, -1);\n      if (found)\n        { return badPos(Pos(found.line, found.ch + dist$1), bad) }\n      else\n        { dist$1 += before.textContent.length; }\n    }\n  }\n\n  // TEXTAREA INPUT STYLE\n\n  var TextareaInput = function(cm) {\n    this.cm = cm;\n    // See input.poll and input.reset\n    this.prevInput = \"\";\n\n    // Flag that indicates whether we expect input to appear real soon\n    // now (after some event like 'keypress' or 'input') and are\n    // polling intensively.\n    this.pollingFast = false;\n    // Self-resetting timeout for the poller\n    this.polling = new Delayed();\n    // Used to work around IE issue with selection being forgotten when focus moves away from textarea\n    this.hasSelection = false;\n    this.composing = null;\n  };\n\n  TextareaInput.prototype.init = function (display) {\n      var this$1 = this;\n\n    var input = this, cm = this.cm;\n    this.createField(display);\n    var te = this.textarea;\n\n    display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);\n\n    // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)\n    if (ios) { te.style.width = \"0px\"; }\n\n    on(te, \"input\", function () {\n      if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null; }\n      input.poll();\n    });\n\n    on(te, \"paste\", function (e) {\n      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }\n\n      cm.state.pasteIncoming = +new Date;\n      input.fastPoll();\n    });\n\n    function prepareCopyCut(e) {\n      if (signalDOMEvent(cm, e)) { return }\n      if (cm.somethingSelected()) {\n        setLastCopied({lineWise: false, text: cm.getSelections()});\n      } else if (!cm.options.lineWiseCopyCut) {\n        return\n      } else {\n        var ranges = copyableRanges(cm);\n        setLastCopied({lineWise: true, text: ranges.text});\n        if (e.type == \"cut\") {\n          cm.setSelections(ranges.ranges, null, sel_dontScroll);\n        } else {\n          input.prevInput = \"\";\n          te.value = ranges.text.join(\"\\n\");\n          selectInput(te);\n        }\n      }\n      if (e.type == \"cut\") { cm.state.cutIncoming = +new Date; }\n    }\n    on(te, \"cut\", prepareCopyCut);\n    on(te, \"copy\", prepareCopyCut);\n\n    on(display.scroller, \"paste\", function (e) {\n      if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }\n      if (!te.dispatchEvent) {\n        cm.state.pasteIncoming = +new Date;\n        input.focus();\n        return\n      }\n\n      // Pass the `paste` event to the textarea so it's handled by its event listener.\n      var event = new Event(\"paste\");\n      event.clipboardData = e.clipboardData;\n      te.dispatchEvent(event);\n    });\n\n    // Prevent normal selection in the editor (we handle our own)\n    on(display.lineSpace, \"selectstart\", function (e) {\n      if (!eventInWidget(display, e)) { e_preventDefault(e); }\n    });\n\n    on(te, \"compositionstart\", function () {\n      var start = cm.getCursor(\"from\");\n      if (input.composing) { input.composing.range.clear(); }\n      input.composing = {\n        start: start,\n        range: cm.markText(start, cm.getCursor(\"to\"), {className: \"CodeMirror-composing\"})\n      };\n    });\n    on(te, \"compositionend\", function () {\n      if (input.composing) {\n        input.poll();\n        input.composing.range.clear();\n        input.composing = null;\n      }\n    });\n  };\n\n  TextareaInput.prototype.createField = function (_display) {\n    // Wraps and hides input textarea\n    this.wrapper = hiddenTextarea();\n    // The semihidden textarea that is focused when the editor is\n    // focused, and receives input.\n    this.textarea = this.wrapper.firstChild;\n  };\n\n  TextareaInput.prototype.prepareSelection = function () {\n    // Redraw the selection and/or cursor\n    var cm = this.cm, display = cm.display, doc = cm.doc;\n    var result = prepareSelection(cm);\n\n    // Move the hidden textarea near the cursor to prevent scrolling artifacts\n    if (cm.options.moveInputWithCursor) {\n      var headPos = cursorCoords(cm, doc.sel.primary().head, \"div\");\n      var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();\n      result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,\n                                          headPos.top + lineOff.top - wrapOff.top));\n      result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,\n                                           headPos.left + lineOff.left - wrapOff.left));\n    }\n\n    return result\n  };\n\n  TextareaInput.prototype.showSelection = function (drawn) {\n    var cm = this.cm, display = cm.display;\n    removeChildrenAndAdd(display.cursorDiv, drawn.cursors);\n    removeChildrenAndAdd(display.selectionDiv, drawn.selection);\n    if (drawn.teTop != null) {\n      this.wrapper.style.top = drawn.teTop + \"px\";\n      this.wrapper.style.left = drawn.teLeft + \"px\";\n    }\n  };\n\n  // Reset the input to correspond to the selection (or to be empty,\n  // when not typing and nothing is selected)\n  TextareaInput.prototype.reset = function (typing) {\n    if (this.contextMenuPending || this.composing) { return }\n    var cm = this.cm;\n    if (cm.somethingSelected()) {\n      this.prevInput = \"\";\n      var content = cm.getSelection();\n      this.textarea.value = content;\n      if (cm.state.focused) { selectInput(this.textarea); }\n      if (ie && ie_version >= 9) { this.hasSelection = content; }\n    } else if (!typing) {\n      this.prevInput = this.textarea.value = \"\";\n      if (ie && ie_version >= 9) { this.hasSelection = null; }\n    }\n  };\n\n  TextareaInput.prototype.getField = function () { return this.textarea };\n\n  TextareaInput.prototype.supportsTouch = function () { return false };\n\n  TextareaInput.prototype.focus = function () {\n    if (this.cm.options.readOnly != \"nocursor\" && (!mobile || activeElt() != this.textarea)) {\n      try { this.textarea.focus(); }\n      catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM\n    }\n  };\n\n  TextareaInput.prototype.blur = function () { this.textarea.blur(); };\n\n  TextareaInput.prototype.resetPosition = function () {\n    this.wrapper.style.top = this.wrapper.style.left = 0;\n  };\n\n  TextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };\n\n  // Poll for input changes, using the normal rate of polling. This\n  // runs as long as the editor is focused.\n  TextareaInput.prototype.slowPoll = function () {\n      var this$1 = this;\n\n    if (this.pollingFast) { return }\n    this.polling.set(this.cm.options.pollInterval, function () {\n      this$1.poll();\n      if (this$1.cm.state.focused) { this$1.slowPoll(); }\n    });\n  };\n\n  // When an event has just come in that is likely to add or change\n  // something in the input textarea, we poll faster, to ensure that\n  // the change appears on the screen quickly.\n  TextareaInput.prototype.fastPoll = function () {\n    var missed = false, input = this;\n    input.pollingFast = true;\n    function p() {\n      var changed = input.poll();\n      if (!changed && !missed) {missed = true; input.polling.set(60, p);}\n      else {input.pollingFast = false; input.slowPoll();}\n    }\n    input.polling.set(20, p);\n  };\n\n  // Read input from the textarea, and update the document to match.\n  // When something is selected, it is present in the textarea, and\n  // selected (unless it is huge, in which case a placeholder is\n  // used). When nothing is selected, the cursor sits after previously\n  // seen text (can be empty), which is stored in prevInput (we must\n  // not reset the textarea when typing, because that breaks IME).\n  TextareaInput.prototype.poll = function () {\n      var this$1 = this;\n\n    var cm = this.cm, input = this.textarea, prevInput = this.prevInput;\n    // Since this is called a *lot*, try to bail out as cheaply as\n    // possible when it is clear that nothing happened. hasSelection\n    // will be the case when there is a lot of text in the textarea,\n    // in which case reading its value would be expensive.\n    if (this.contextMenuPending || !cm.state.focused ||\n        (hasSelection(input) && !prevInput && !this.composing) ||\n        cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)\n      { return false }\n\n    var text = input.value;\n    // If nothing changed, bail.\n    if (text == prevInput && !cm.somethingSelected()) { return false }\n    // Work around nonsensical selection resetting in IE9/10, and\n    // inexplicable appearance of private area unicode characters on\n    // some key combos in Mac (#2689).\n    if (ie && ie_version >= 9 && this.hasSelection === text ||\n        mac && /[\\uf700-\\uf7ff]/.test(text)) {\n      cm.display.input.reset();\n      return false\n    }\n\n    if (cm.doc.sel == cm.display.selForContextMenu) {\n      var first = text.charCodeAt(0);\n      if (first == 0x200b && !prevInput) { prevInput = \"\\u200b\"; }\n      if (first == 0x21da) { this.reset(); return this.cm.execCommand(\"undo\") }\n    }\n    // Find the part of the input that is actually new\n    var same = 0, l = Math.min(prevInput.length, text.length);\n    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }\n\n    runInOp(cm, function () {\n      applyTextInput(cm, text.slice(same), prevInput.length - same,\n                     null, this$1.composing ? \"*compose\" : null);\n\n      // Don't leave long text in the textarea, since it makes further polling slow\n      if (text.length > 1000 || text.indexOf(\"\\n\") > -1) { input.value = this$1.prevInput = \"\"; }\n      else { this$1.prevInput = text; }\n\n      if (this$1.composing) {\n        this$1.composing.range.clear();\n        this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor(\"to\"),\n                                           {className: \"CodeMirror-composing\"});\n      }\n    });\n    return true\n  };\n\n  TextareaInput.prototype.ensurePolled = function () {\n    if (this.pollingFast && this.poll()) { this.pollingFast = false; }\n  };\n\n  TextareaInput.prototype.onKeyPress = function () {\n    if (ie && ie_version >= 9) { this.hasSelection = null; }\n    this.fastPoll();\n  };\n\n  TextareaInput.prototype.onContextMenu = function (e) {\n    var input = this, cm = input.cm, display = cm.display, te = input.textarea;\n    if (input.contextMenuPending) { input.contextMenuPending(); }\n    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;\n    if (!pos || presto) { return } // Opera is difficult.\n\n    // Reset the current text selection only if the click is done outside of the selection\n    // and 'resetSelectionOnContextMenu' option is true.\n    var reset = cm.options.resetSelectionOnContextMenu;\n    if (reset && cm.doc.sel.contains(pos) == -1)\n      { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }\n\n    var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;\n    var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();\n    input.wrapper.style.cssText = \"position: static\";\n    te.style.cssText = \"position: absolute; width: 30px; height: 30px;\\n      top: \" + (e.clientY - wrapperBox.top - 5) + \"px; left: \" + (e.clientX - wrapperBox.left - 5) + \"px;\\n      z-index: 1000; background: \" + (ie ? \"rgba(255, 255, 255, .05)\" : \"transparent\") + \";\\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);\";\n    var oldScrollY;\n    if (webkit) { oldScrollY = window.scrollY; } // Work around Chrome issue (#2712)\n    display.input.focus();\n    if (webkit) { window.scrollTo(null, oldScrollY); }\n    display.input.reset();\n    // Adds \"Select all\" to context menu in FF\n    if (!cm.somethingSelected()) { te.value = input.prevInput = \" \"; }\n    input.contextMenuPending = rehide;\n    display.selForContextMenu = cm.doc.sel;\n    clearTimeout(display.detectingSelectAll);\n\n    // Select-all will be greyed out if there's nothing to select, so\n    // this adds a zero-width space so that we can later check whether\n    // it got selected.\n    function prepareSelectAllHack() {\n      if (te.selectionStart != null) {\n        var selected = cm.somethingSelected();\n        var extval = \"\\u200b\" + (selected ? te.value : \"\");\n        te.value = \"\\u21da\"; // Used to catch context-menu undo\n        te.value = extval;\n        input.prevInput = selected ? \"\" : \"\\u200b\";\n        te.selectionStart = 1; te.selectionEnd = extval.length;\n        // Re-set this, in case some other handler touched the\n        // selection in the meantime.\n        display.selForContextMenu = cm.doc.sel;\n      }\n    }\n    function rehide() {\n      if (input.contextMenuPending != rehide) { return }\n      input.contextMenuPending = false;\n      input.wrapper.style.cssText = oldWrapperCSS;\n      te.style.cssText = oldCSS;\n      if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }\n\n      // Try to detect the user choosing select-all\n      if (te.selectionStart != null) {\n        if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack(); }\n        var i = 0, poll = function () {\n          if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&\n              te.selectionEnd > 0 && input.prevInput == \"\\u200b\") {\n            operation(cm, selectAll)(cm);\n          } else if (i++ < 10) {\n            display.detectingSelectAll = setTimeout(poll, 500);\n          } else {\n            display.selForContextMenu = null;\n            display.input.reset();\n          }\n        };\n        display.detectingSelectAll = setTimeout(poll, 200);\n      }\n    }\n\n    if (ie && ie_version >= 9) { prepareSelectAllHack(); }\n    if (captureRightClick) {\n      e_stop(e);\n      var mouseup = function () {\n        off(window, \"mouseup\", mouseup);\n        setTimeout(rehide, 20);\n      };\n      on(window, \"mouseup\", mouseup);\n    } else {\n      setTimeout(rehide, 50);\n    }\n  };\n\n  TextareaInput.prototype.readOnlyChanged = function (val) {\n    if (!val) { this.reset(); }\n    this.textarea.disabled = val == \"nocursor\";\n  };\n\n  TextareaInput.prototype.setUneditable = function () {};\n\n  TextareaInput.prototype.needsContentAttribute = false;\n\n  function fromTextArea(textarea, options) {\n    options = options ? copyObj(options) : {};\n    options.value = textarea.value;\n    if (!options.tabindex && textarea.tabIndex)\n      { options.tabindex = textarea.tabIndex; }\n    if (!options.placeholder && textarea.placeholder)\n      { options.placeholder = textarea.placeholder; }\n    // Set autofocus to true if this textarea is focused, or if it has\n    // autofocus and no other element is focused.\n    if (options.autofocus == null) {\n      var hasFocus = activeElt();\n      options.autofocus = hasFocus == textarea ||\n        textarea.getAttribute(\"autofocus\") != null && hasFocus == document.body;\n    }\n\n    function save() {textarea.value = cm.getValue();}\n\n    var realSubmit;\n    if (textarea.form) {\n      on(textarea.form, \"submit\", save);\n      // Deplorable hack to make the submit method do the right thing.\n      if (!options.leaveSubmitMethodAlone) {\n        var form = textarea.form;\n        realSubmit = form.submit;\n        try {\n          var wrappedSubmit = form.submit = function () {\n            save();\n            form.submit = realSubmit;\n            form.submit();\n            form.submit = wrappedSubmit;\n          };\n        } catch(e) {}\n      }\n    }\n\n    options.finishInit = function (cm) {\n      cm.save = save;\n      cm.getTextArea = function () { return textarea; };\n      cm.toTextArea = function () {\n        cm.toTextArea = isNaN; // Prevent this from being ran twice\n        save();\n        textarea.parentNode.removeChild(cm.getWrapperElement());\n        textarea.style.display = \"\";\n        if (textarea.form) {\n          off(textarea.form, \"submit\", save);\n          if (typeof textarea.form.submit == \"function\")\n            { textarea.form.submit = realSubmit; }\n        }\n      };\n    };\n\n    textarea.style.display = \"none\";\n    var cm = CodeMirror(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },\n      options);\n    return cm\n  }\n\n  function addLegacyProps(CodeMirror) {\n    CodeMirror.off = off;\n    CodeMirror.on = on;\n    CodeMirror.wheelEventPixels = wheelEventPixels;\n    CodeMirror.Doc = Doc;\n    CodeMirror.splitLines = splitLinesAuto;\n    CodeMirror.countColumn = countColumn;\n    CodeMirror.findColumn = findColumn;\n    CodeMirror.isWordChar = isWordCharBasic;\n    CodeMirror.Pass = Pass;\n    CodeMirror.signal = signal;\n    CodeMirror.Line = Line;\n    CodeMirror.changeEnd = changeEnd;\n    CodeMirror.scrollbarModel = scrollbarModel;\n    CodeMirror.Pos = Pos;\n    CodeMirror.cmpPos = cmp;\n    CodeMirror.modes = modes;\n    CodeMirror.mimeModes = mimeModes;\n    CodeMirror.resolveMode = resolveMode;\n    CodeMirror.getMode = getMode;\n    CodeMirror.modeExtensions = modeExtensions;\n    CodeMirror.extendMode = extendMode;\n    CodeMirror.copyState = copyState;\n    CodeMirror.startState = startState;\n    CodeMirror.innerMode = innerMode;\n    CodeMirror.commands = commands;\n    CodeMirror.keyMap = keyMap;\n    CodeMirror.keyName = keyName;\n    CodeMirror.isModifierKey = isModifierKey;\n    CodeMirror.lookupKey = lookupKey;\n    CodeMirror.normalizeKeyMap = normalizeKeyMap;\n    CodeMirror.StringStream = StringStream;\n    CodeMirror.SharedTextMarker = SharedTextMarker;\n    CodeMirror.TextMarker = TextMarker;\n    CodeMirror.LineWidget = LineWidget;\n    CodeMirror.e_preventDefault = e_preventDefault;\n    CodeMirror.e_stopPropagation = e_stopPropagation;\n    CodeMirror.e_stop = e_stop;\n    CodeMirror.addClass = addClass;\n    CodeMirror.contains = contains;\n    CodeMirror.rmClass = rmClass;\n    CodeMirror.keyNames = keyNames;\n  }\n\n  // EDITOR CONSTRUCTOR\n\n  defineOptions(CodeMirror);\n\n  addEditorMethods(CodeMirror);\n\n  // Set up methods on CodeMirror's prototype to redirect to the editor's document.\n  var dontDelegate = \"iter insert remove copy getEditor constructor\".split(\" \");\n  for (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)\n    { CodeMirror.prototype[prop] = (function(method) {\n      return function() {return method.apply(this.doc, arguments)}\n    })(Doc.prototype[prop]); } }\n\n  eventMixin(Doc);\n  CodeMirror.inputStyles = {\"textarea\": TextareaInput, \"contenteditable\": ContentEditableInput};\n\n  // Extra arguments are stored as the mode's dependencies, which is\n  // used by (legacy) mechanisms like loadmode.js to automatically\n  // load a mode. (Preferred mechanism is the require/define calls.)\n  CodeMirror.defineMode = function(name/*, mode, */) {\n    if (!CodeMirror.defaults.mode && name != \"null\") { CodeMirror.defaults.mode = name; }\n    defineMode.apply(this, arguments);\n  };\n\n  CodeMirror.defineMIME = defineMIME;\n\n  // Minimal default mode.\n  CodeMirror.defineMode(\"null\", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });\n  CodeMirror.defineMIME(\"text/plain\", \"null\");\n\n  // EXTENSIONS\n\n  CodeMirror.defineExtension = function (name, func) {\n    CodeMirror.prototype[name] = func;\n  };\n  CodeMirror.defineDocExtension = function (name, func) {\n    Doc.prototype[name] = func;\n  };\n\n  CodeMirror.fromTextArea = fromTextArea;\n\n  addLegacyProps(CodeMirror);\n\n  CodeMirror.version = \"5.44.0\";\n\n  return CodeMirror;\n\n})));\n","import { Vector2d, Degrees, Radians, deg2rad } from \"./geometry\";\nimport { Stroke } from \"./scene\";\n\ntype FrameMutations = {\n    position?: Vector2d;\n    facing?: Degrees;\n    height?: number;\n    opacity?: number;\n    newStrokes?: Stroke[];\n    foreground?: string;\n    background?: string;\n}\nexport class Frame {\n    static new() {\n        return new Frame;\n    }\n\n    private constructor(\n        readonly position: Vector2d = Vector2d.ORIGIN,\n        readonly facing: Degrees = 0,\n        readonly height: number = 0,\n        readonly opacity: number = 1,\n        readonly strokes: Stroke[] = [],\n        readonly foreground: string = \"\",\n        readonly background: string = \"\") { }\n\n    get facingRadians(): Radians {\n        return deg2rad(this.facing);\n    }\n\n    with(properties: FrameMutations): Frame {\n        return new Frame(\n            properties.position || this.position,\n            \"facing\" in properties ? properties.facing : this.facing,\n            \"height\" in properties ? properties.height : this.height,\n            \"opacity\" in properties ? properties.opacity : this.opacity,\n            \"newStrokes\" in properties ? this.strokes.concat(properties.newStrokes) : this.strokes,\n            \"foreground\" in properties ? properties.foreground : this.foreground,\n            \"background\" in properties ? properties.background : this.background);\n    }\n}\n\nexport class Animation {\n    keyFrame: Frame;\n    elapsed = 0;\n\n    constructor(\n        readonly duration: number,\n        readonly update: (delta: number, keyFrame: Frame) => Frame) { }\n\n    get currentFrame(): Frame {\n        return this.update(this.elapsed / this.duration, this.keyFrame);\n    }\n    get lastFrame(): Frame {\n        return this.update(1, this.keyFrame);\n    }\n\n    withKeyFrame(keyFrame: Frame): Animation {\n        this.keyFrame = keyFrame;\n        return this;\n    }\n}","import * as MainLoop from \"mainloop.js\"\n\nimport * as CodeMirror from \"codemirror\";\nimport \"codemirror/lib/codemirror.css\";\nimport \"codemirror/mode/javascript/javascript\";\n\nimport { Animation, Frame } from \"./frames\";\nimport { Interpreter, Instruction } from \"./interpreter\";\nimport { nextTick } from \"./scheduler\";\nimport { Painter } from \"./gui\";\n\nclass PainterStudio {\n    private animation: Animation;\n    private frame: Frame;\n    private painter: Painter;\n\n    private isFreezing = false;\n\n    constructor(private ctx: CanvasRenderingContext2D) {\n        MainLoop.setDraw(() => this.draw());\n        this.reset();\n    }\n\n    reset() {\n        if (MainLoop.isRunning()) {\n            MainLoop.stop();\n        }\n\n        this.animation = null;\n        this.frame = Frame.new();\n        this.painter = new Painter;\n\n        this.draw();\n    }\n\n    animate() {\n        this.isFreezing = false;\n\n        if (!MainLoop.isRunning()) {\n            MainLoop.start();\n        }\n    }\n    freeze() {\n        this.isFreezing = true;\n    }\n\n    setAnimation(animation: Animation): Animation {\n        return animation === null ? null : this.animation = animation.withKeyFrame(this.frame);\n    }\n\n    update(delta: number): boolean {\n        if (this.isFreezing) {\n            if (this.animation) {\n                this.frame = this.animation.lastFrame;\n                this.animation = null;\n            }\n\n            MainLoop.stop();\n\n        } else {\n            if (!this.animation && !getNextAnimation()) {\n                return false;\n            }\n\n            while (this.animation) {\n                this.animation.elapsed += delta / 1000 * speed;\n                if (this.animation.elapsed < this.animation.duration) {\n                    this.frame = this.animation.currentFrame;\n                    break;\n                }\n\n                this.frame = this.animation.lastFrame;\n                delta = (this.animation.elapsed - this.animation.duration) * 1000 / speed;\n                this.animation.elapsed = this.animation.duration;\n\n                if (!getNextAnimation()) {\n                    return false;\n                }\n            }\n        }\n\n        this.painter.update(this.frame);\n\n        return true;\n    }\n\n    draw() {\n        this.drawPaper(this.ctx);\n        this.frame.strokes.forEach(stroke => stroke.defaultColor(this.frame.foreground).draw(ctx, 3.2));\n        this.painter.draw(this.ctx);\n    }\n\n    private drawPaper(ctx: CanvasRenderingContext2D, scale = 3.2) {\n        const WIDTH = ctx.canvas.width;\n        const HEIGHT = ctx.canvas.height;\n        const X = WIDTH / 2;\n        const Y = HEIGHT / 2;\n\n        ctx.save();\n\n        if (!this.frame.background || this.frame.background === \"none\" || this.frame.background === \"transparent\") {\n            ctx.fillStyle = \"#DAEAFF\";\n            ctx.fillRect(-X, -Y, WIDTH, HEIGHT);\n            ctx.strokeStyle = \"white\";\n            ctx.beginPath();\n            ctx.moveTo(0, -Y);\n            ctx.lineTo(0, Y);\n            ctx.moveTo(-X, 0);\n            ctx.lineTo(X, 0);\n            ctx.stroke();\n\n            const STEP = 5 * scale;\n\n            ctx.lineWidth = 0.5;\n            ctx.beginPath();\n            for (let x = STEP; x <= X; x += STEP) {\n                ctx.moveTo(x, -Y);\n                ctx.lineTo(x, Y);\n            }\n            for (let x = -STEP; x >= -X; x -= STEP) {\n                ctx.moveTo(x, -Y);\n                ctx.lineTo(x, Y);\n            }\n            for (let y = STEP; y <= Y; y += STEP) {\n                ctx.moveTo(-X, y);\n                ctx.lineTo(X, y);\n            }\n            for (let y = -STEP; y >= -Y; y -= STEP) {\n                ctx.moveTo(-X, y);\n                ctx.lineTo(X, y);\n            }\n            ctx.stroke();\n\n        } else {\n            ctx.fillStyle = this.frame.background;\n            ctx.fillRect(-X, -Y, WIDTH, HEIGHT);\n        }\n\n        ctx.restore();\n    }\n}\n\nlet canvasHolder = document.getElementById(\"canvas_holder\");\nlet canvas = document.getElementById(\"canvas\") as HTMLCanvasElement;\nlet ctx: CanvasRenderingContext2D = canvas.getContext(\"2d\");\n\nlet studio = new PainterStudio(ctx);\n\nwindow.addEventListener(\"resize\", setCanvasSize);\nsetCanvasSize();\nfunction setCanvasSize() {\n    canvas.width = canvasHolder.offsetWidth;\n    canvas.height = canvasHolder.offsetHeight;\n\n    ctx.restore();\n    ctx.save();\n    ctx.scale(1, -1);\n    ctx.translate(canvas.width / 2, -canvas.height / 2);\n    ctx.lineWidth = 2;\n    ctx.lineCap = \"round\";\n    ctx.lineJoin = \"round\";\n\n    studio.draw();\n}\n\nlet txtCode = document.getElementById(\"code\") as HTMLTextAreaElement;\nlet editor = CodeMirror.fromTextArea(txtCode, {\n    lineNumbers: true,\n    mode: \"javascript\",\n    tabSize: 2,\n    extraKeys: {\n        \"Ctrl-Alt-Enter\": () => setState(\"step-fwd\"),\n        \"Ctrl-Enter\": () => setState(\"playing\"),\n        \"Shift-Ctrl-Enter\": () => setState(\"fast-fwd\")\n    }\n});\n\nlet txtOut = document.getElementById(\"out\");\n\nlet btnPause = document.getElementById(\"pause\") as HTMLButtonElement;\nlet btnSfwd = document.getElementById(\"sfwd\") as HTMLButtonElement;\nlet btnPlay = document.getElementById(\"play\") as HTMLButtonElement;\nlet btnFfwd = document.getElementById(\"ffwd\") as HTMLButtonElement;\nlet btnStop = document.getElementById(\"stop\") as HTMLButtonElement;\n\nlet chkTrace = document.getElementById(\"trace\") as HTMLInputElement;\nchkTrace.addEventListener(\"change\", () => clearEditorMarks());\n\ntype TransportState = \"ready\" | \"playing\" | \"paused\" | \"step-fwd\" | \"fast-fwd\" | \"done\";\nlet state: TransportState;\nsetState(\"ready\");\n\nbtnPause.addEventListener(\"click\", () => {\n    setState(\"paused\");\n});\nbtnSfwd.addEventListener(\"click\", () => {\n    setState(\"step-fwd\");\n});\nbtnPlay.addEventListener(\"click\", () => {\n    setState(\"playing\");\n});\nbtnFfwd.addEventListener(\"click\", () => {\n    setState(\"fast-fwd\");\n});\nbtnStop.addEventListener(\"click\", () => {\n    setState(\"ready\");\n});\n\nconst MAX_LOOP_COUNT = 10000;\n\nlet interpreter: Interpreter;\nfunction getNextAnimation(loopCount = 0): Animation {\n    try {\n        let instruction: Instruction = interpreter.stepToNextInstruction();\n\n        if (instruction) {\n            if (chkTrace.checked) {\n                clearEditorMarks();\n                let start = editor.findPosH(CodeMirror.Pos(0, 0), instruction.node.start, \"char\", true);\n                let end = editor.findPosH(CodeMirror.Pos(0, 0), instruction.node.end, \"char\", true);\n                editor.getDoc().markText(start, end, { css: \"background: rgba(128,255,128,0.4)\" })\n\n                return studio.setAnimation(instruction.animation || new Animation(10, (_, keyFrame) => keyFrame)); // FIXME:\n\n            } else {\n                if (instruction.animation) {\n                    return studio.setAnimation(instruction.animation);\n                } else {\n                    if (loopCount < MAX_LOOP_COUNT) {\n                        return getNextAnimation(loopCount + 1);\n                    } else {\n                        clearEditorMarks();\n                        markError(instruction.node.start, instruction.node.end);\n                        txtOut.innerHTML = \"<span style=color:red>WARNING: Possible infinite loop!</span>\\n\";\n                        return studio.setAnimation(new Animation(state === \"fast-fwd\" ? 20000 : 20, (_, keyFrame) => keyFrame));\n                    }\n                }\n            }\n        }\n    } catch (err) {\n        setState(\"done\");\n        markError(err.state.node.start, err.state.node.end, err.message);\n        throw err;\n    }\n\n    return studio.setAnimation(null);\n}\n\nfunction clearEditorMarks() {\n    editor.getDoc().getAllMarks().forEach(mark => mark.clear());\n}\nfunction markError(start: number, end: number, message?: string) {\n    let startPos = editor.findPosH(CodeMirror.Pos(0, 0), start, \"char\", true);\n    let endPos = editor.findPosH(CodeMirror.Pos(0, 0), end, \"char\", true);\n    editor.getDoc().markText(startPos, endPos, { css: \"background: rgba(255,128,128,0.4)\" })\n\n    if (message) {\n        txtOut.innerHTML += `<span style=color:red>${message}</span>\\n`;\n    }\n}\n\nsetupMainLoop();\n\nfunction setState(nextState: TransportState) {\n    switch (nextState) {\n        case \"ready\":\n            hide(btnPause, btnStop);\n            show(btnSfwd, btnFfwd, btnPlay);\n\n            clearEditorMarks();\n            txtOut.textContent = \"\";\n            studio.reset();\n            break;\n\n        case \"playing\":\n            hide(btnPlay);\n            show(btnSfwd, btnPause, btnFfwd, btnStop);\n            disable(btnSfwd);\n\n            ensureRunning();\n\n            studio.animate();\n            break;\n\n        case \"step-fwd\":\n            hide(btnSfwd, btnPause, btnPlay, btnFfwd, btnStop);\n\n            ensureRunning();\n\n            studio.animate();\n\n            if (getNextAnimation()) {\n                setState(\"paused\");\n            } else {\n                setState(\"done\");\n            }\n\n            return;\n\n        case \"paused\":\n            hide(btnPause);\n            show(btnSfwd, btnPlay, btnFfwd, btnStop);\n\n            studio.freeze();\n            break;\n\n        case \"fast-fwd\":\n            hide(btnFfwd);\n            show(btnSfwd, btnPlay, btnPause, btnStop);\n            disable(btnSfwd);\n\n            ensureRunning();\n\n            studio.animate();\n            break;\n\n        case \"done\":\n            hide(btnPause);\n            show(btnSfwd, btnPlay, btnFfwd, btnStop);\n            disable()\n\n            clearEditorMarks();\n            studio.freeze();\n            break;\n    }\n\n    state = nextState;\n}\n\nfunction ensureRunning() {\n    if (state === \"ready\" || state === \"done\") {\n        editor.save();\n        try {\n            interpreter = new Interpreter(txtCode.value);\n        } catch (err) {\n\n            setState(\"done\");\n\n            let message = /(.*)\\((\\d+):(\\d+)\\)\\s*$/.exec(err.message);\n            let startPos = CodeMirror.Pos(+message[2], +message[3]);\n            let token = editor.getTokenAt(startPos);\n            markError(token.start, token.end, message[1] + `'${token.string}'`);\n\n            throw err;\n        }\n\n        txtOut.textContent = \"\";\n        studio.reset();\n    }\n}\n\nfunction disable(...elements: HTMLButtonElement[]) {\n    elements.forEach(element => {\n        element.disabled = true;\n        element.classList.add(\"disabled\");\n    });\n}\nfunction enable(...elements: HTMLButtonElement[]) {\n    elements.forEach(element => {\n        element.disabled = false;\n        element.classList.remove(\"disabled\");\n    });\n}\nfunction hide(...elements: HTMLButtonElement[]) {\n    elements.forEach(element => element.style.display = \"none\");\n}\nfunction show(...elements: HTMLButtonElement[]) {\n    elements.forEach(element => element.style.display = \"inline-block\");\n    enable(...elements);\n}\n\nlet speed = 100;\n\nfunction setupMainLoop() {\n    MainLoop\n        .setUpdate(delta => {\n            if (state === \"step-fwd\") {\n                return;\n            }\n            if (state === \"fast-fwd\") {\n                delta *= 1000;\n            }\n            if (!studio.update(delta)) {\n                setState(\"done\");\n            }\n        });\n}\n\n","\nvar content = require(\"!!../../css-loader/dist/cjs.js!./codemirror.css\");\n\nif(typeof content === 'string') content = [[module.id, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = require(\"!../../style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(module.hot) {\n\tmodule.hot.accept(\"!!../../css-loader/dist/cjs.js!./codemirror.css\", function() {\n\t\tvar newContent = require(\"!!../../css-loader/dist/cjs.js!./codemirror.css\");\n\n\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\n\t\tvar locals = (function(a, b) {\n\t\t\tvar key, idx = 0;\n\n\t\t\tfor(key in a) {\n\t\t\t\tif(!b || a[key] !== b[key]) return false;\n\t\t\t\tidx++;\n\t\t\t}\n\n\t\t\tfor(key in b) idx--;\n\n\t\t\treturn idx === 0;\n\t\t}(content.locals, newContent.locals));\n\n\t\tif(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');\n\n\t\tupdate(newContent);\n\t});\n\n\tmodule.hot.dispose(function() { update(); });\n}","exports = module.exports = require(\"../../css-loader/dist/runtime/api.js\")(false);\n// Module\nexports.push([module.id, \"/* BASICS */\\n\\n.CodeMirror {\\n  /* Set height, width, borders, and global font properties here */\\n  font-family: monospace;\\n  height: 300px;\\n  color: black;\\n  direction: ltr;\\n}\\n\\n/* PADDING */\\n\\n.CodeMirror-lines {\\n  padding: 4px 0; /* Vertical padding around content */\\n}\\n.CodeMirror pre {\\n  padding: 0 4px; /* Horizontal padding of content */\\n}\\n\\n.CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {\\n  background-color: white; /* The little square between H and V scrollbars */\\n}\\n\\n/* GUTTER */\\n\\n.CodeMirror-gutters {\\n  border-right: 1px solid #ddd;\\n  background-color: #f7f7f7;\\n  white-space: nowrap;\\n}\\n.CodeMirror-linenumbers {}\\n.CodeMirror-linenumber {\\n  padding: 0 3px 0 5px;\\n  min-width: 20px;\\n  text-align: right;\\n  color: #999;\\n  white-space: nowrap;\\n}\\n\\n.CodeMirror-guttermarker { color: black; }\\n.CodeMirror-guttermarker-subtle { color: #999; }\\n\\n/* CURSOR */\\n\\n.CodeMirror-cursor {\\n  border-left: 1px solid black;\\n  border-right: none;\\n  width: 0;\\n}\\n/* Shown when moving in bi-directional text */\\n.CodeMirror div.CodeMirror-secondarycursor {\\n  border-left: 1px solid silver;\\n}\\n.cm-fat-cursor .CodeMirror-cursor {\\n  width: auto;\\n  border: 0 !important;\\n  background: #7e7;\\n}\\n.cm-fat-cursor div.CodeMirror-cursors {\\n  z-index: 1;\\n}\\n.cm-fat-cursor-mark {\\n  background-color: rgba(20, 255, 20, 0.5);\\n  -webkit-animation: blink 1.06s steps(1) infinite;\\n  -moz-animation: blink 1.06s steps(1) infinite;\\n  animation: blink 1.06s steps(1) infinite;\\n}\\n.cm-animate-fat-cursor {\\n  width: auto;\\n  border: 0;\\n  -webkit-animation: blink 1.06s steps(1) infinite;\\n  -moz-animation: blink 1.06s steps(1) infinite;\\n  animation: blink 1.06s steps(1) infinite;\\n  background-color: #7e7;\\n}\\n@-moz-keyframes blink {\\n  0% {}\\n  50% { background-color: transparent; }\\n  100% {}\\n}\\n@-webkit-keyframes blink {\\n  0% {}\\n  50% { background-color: transparent; }\\n  100% {}\\n}\\n@keyframes blink {\\n  0% {}\\n  50% { background-color: transparent; }\\n  100% {}\\n}\\n\\n/* Can style cursor different in overwrite (non-insert) mode */\\n.CodeMirror-overwrite .CodeMirror-cursor {}\\n\\n.cm-tab { display: inline-block; text-decoration: inherit; }\\n\\n.CodeMirror-rulers {\\n  position: absolute;\\n  left: 0; right: 0; top: -50px; bottom: -20px;\\n  overflow: hidden;\\n}\\n.CodeMirror-ruler {\\n  border-left: 1px solid #ccc;\\n  top: 0; bottom: 0;\\n  position: absolute;\\n}\\n\\n/* DEFAULT THEME */\\n\\n.cm-s-default .cm-header {color: blue;}\\n.cm-s-default .cm-quote {color: #090;}\\n.cm-negative {color: #d44;}\\n.cm-positive {color: #292;}\\n.cm-header, .cm-strong {font-weight: bold;}\\n.cm-em {font-style: italic;}\\n.cm-link {text-decoration: underline;}\\n.cm-strikethrough {text-decoration: line-through;}\\n\\n.cm-s-default .cm-keyword {color: #708;}\\n.cm-s-default .cm-atom {color: #219;}\\n.cm-s-default .cm-number {color: #164;}\\n.cm-s-default .cm-def {color: #00f;}\\n.cm-s-default .cm-variable,\\n.cm-s-default .cm-punctuation,\\n.cm-s-default .cm-property,\\n.cm-s-default .cm-operator {}\\n.cm-s-default .cm-variable-2 {color: #05a;}\\n.cm-s-default .cm-variable-3, .cm-s-default .cm-type {color: #085;}\\n.cm-s-default .cm-comment {color: #a50;}\\n.cm-s-default .cm-string {color: #a11;}\\n.cm-s-default .cm-string-2 {color: #f50;}\\n.cm-s-default .cm-meta {color: #555;}\\n.cm-s-default .cm-qualifier {color: #555;}\\n.cm-s-default .cm-builtin {color: #30a;}\\n.cm-s-default .cm-bracket {color: #997;}\\n.cm-s-default .cm-tag {color: #170;}\\n.cm-s-default .cm-attribute {color: #00c;}\\n.cm-s-default .cm-hr {color: #999;}\\n.cm-s-default .cm-link {color: #00c;}\\n\\n.cm-s-default .cm-error {color: #f00;}\\n.cm-invalidchar {color: #f00;}\\n\\n.CodeMirror-composing { border-bottom: 2px solid; }\\n\\n/* Default styles for common addons */\\n\\ndiv.CodeMirror span.CodeMirror-matchingbracket {color: #0b0;}\\ndiv.CodeMirror span.CodeMirror-nonmatchingbracket {color: #a22;}\\n.CodeMirror-matchingtag { background: rgba(255, 150, 0, .3); }\\n.CodeMirror-activeline-background {background: #e8f2ff;}\\n\\n/* STOP */\\n\\n/* The rest of this file contains styles related to the mechanics of\\n   the editor. You probably shouldn't touch them. */\\n\\n.CodeMirror {\\n  position: relative;\\n  overflow: hidden;\\n  background: white;\\n}\\n\\n.CodeMirror-scroll {\\n  overflow: scroll !important; /* Things will break if this is overridden */\\n  /* 30px is the magic margin used to hide the element's real scrollbars */\\n  /* See overflow: hidden in .CodeMirror */\\n  margin-bottom: -30px; margin-right: -30px;\\n  padding-bottom: 30px;\\n  height: 100%;\\n  outline: none; /* Prevent dragging from highlighting the element */\\n  position: relative;\\n}\\n.CodeMirror-sizer {\\n  position: relative;\\n  border-right: 30px solid transparent;\\n}\\n\\n/* The fake, visible scrollbars. Used to force redraw during scrolling\\n   before actual scrolling happens, thus preventing shaking and\\n   flickering artifacts. */\\n.CodeMirror-vscrollbar, .CodeMirror-hscrollbar, .CodeMirror-scrollbar-filler, .CodeMirror-gutter-filler {\\n  position: absolute;\\n  z-index: 6;\\n  display: none;\\n}\\n.CodeMirror-vscrollbar {\\n  right: 0; top: 0;\\n  overflow-x: hidden;\\n  overflow-y: scroll;\\n}\\n.CodeMirror-hscrollbar {\\n  bottom: 0; left: 0;\\n  overflow-y: hidden;\\n  overflow-x: scroll;\\n}\\n.CodeMirror-scrollbar-filler {\\n  right: 0; bottom: 0;\\n}\\n.CodeMirror-gutter-filler {\\n  left: 0; bottom: 0;\\n}\\n\\n.CodeMirror-gutters {\\n  position: absolute; left: 0; top: 0;\\n  min-height: 100%;\\n  z-index: 3;\\n}\\n.CodeMirror-gutter {\\n  white-space: normal;\\n  height: 100%;\\n  display: inline-block;\\n  vertical-align: top;\\n  margin-bottom: -30px;\\n}\\n.CodeMirror-gutter-wrapper {\\n  position: absolute;\\n  z-index: 4;\\n  background: none !important;\\n  border: none !important;\\n}\\n.CodeMirror-gutter-background {\\n  position: absolute;\\n  top: 0; bottom: 0;\\n  z-index: 4;\\n}\\n.CodeMirror-gutter-elt {\\n  position: absolute;\\n  cursor: default;\\n  z-index: 4;\\n}\\n.CodeMirror-gutter-wrapper ::selection { background-color: transparent }\\n.CodeMirror-gutter-wrapper ::-moz-selection { background-color: transparent }\\n\\n.CodeMirror-lines {\\n  cursor: text;\\n  min-height: 1px; /* prevents collapsing before first draw */\\n}\\n.CodeMirror pre {\\n  /* Reset some styles that the rest of the page might have set */\\n  -moz-border-radius: 0; -webkit-border-radius: 0; border-radius: 0;\\n  border-width: 0;\\n  background: transparent;\\n  font-family: inherit;\\n  font-size: inherit;\\n  margin: 0;\\n  white-space: pre;\\n  word-wrap: normal;\\n  line-height: inherit;\\n  color: inherit;\\n  z-index: 2;\\n  position: relative;\\n  overflow: visible;\\n  -webkit-tap-highlight-color: transparent;\\n  -webkit-font-variant-ligatures: contextual;\\n  font-variant-ligatures: contextual;\\n}\\n.CodeMirror-wrap pre {\\n  word-wrap: break-word;\\n  white-space: pre-wrap;\\n  word-break: normal;\\n}\\n\\n.CodeMirror-linebackground {\\n  position: absolute;\\n  left: 0; right: 0; top: 0; bottom: 0;\\n  z-index: 0;\\n}\\n\\n.CodeMirror-linewidget {\\n  position: relative;\\n  z-index: 2;\\n  padding: 0.1px; /* Force widget margins to stay inside of the container */\\n}\\n\\n.CodeMirror-widget {}\\n\\n.CodeMirror-rtl pre { direction: rtl; }\\n\\n.CodeMirror-code {\\n  outline: none;\\n}\\n\\n/* Force content-box sizing for the elements where we expect it */\\n.CodeMirror-scroll,\\n.CodeMirror-sizer,\\n.CodeMirror-gutter,\\n.CodeMirror-gutters,\\n.CodeMirror-linenumber {\\n  -moz-box-sizing: content-box;\\n  box-sizing: content-box;\\n}\\n\\n.CodeMirror-measure {\\n  position: absolute;\\n  width: 100%;\\n  height: 0;\\n  overflow: hidden;\\n  visibility: hidden;\\n}\\n\\n.CodeMirror-cursor {\\n  position: absolute;\\n  pointer-events: none;\\n}\\n.CodeMirror-measure pre { position: static; }\\n\\ndiv.CodeMirror-cursors {\\n  visibility: hidden;\\n  position: relative;\\n  z-index: 3;\\n}\\ndiv.CodeMirror-dragcursors {\\n  visibility: visible;\\n}\\n\\n.CodeMirror-focused div.CodeMirror-cursors {\\n  visibility: visible;\\n}\\n\\n.CodeMirror-selected { background: #d9d9d9; }\\n.CodeMirror-focused .CodeMirror-selected { background: #d7d4f0; }\\n.CodeMirror-crosshair { cursor: crosshair; }\\n.CodeMirror-line::selection, .CodeMirror-line > span::selection, .CodeMirror-line > span > span::selection { background: #d7d4f0; }\\n.CodeMirror-line::-moz-selection, .CodeMirror-line > span::-moz-selection, .CodeMirror-line > span > span::-moz-selection { background: #d7d4f0; }\\n\\n.cm-searching {\\n  background-color: #ffa;\\n  background-color: rgba(255, 255, 0, .4);\\n}\\n\\n/* Used to force a border model for a node */\\n.cm-force-border { padding-right: .1px; }\\n\\n@media print {\\n  /* Hide the cursor when printing */\\n  .CodeMirror div.CodeMirror-cursors {\\n    visibility: hidden;\\n  }\\n}\\n\\n/* See issue #2901 */\\n.cm-tab-wrap-hack:after { content: ''; }\\n\\n/* Help users use markselection to safely style text background */\\nspan.CodeMirror-selectedtext { background: none; }\\n\", \"\"]);\n\n","\"use strict\";\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function (useSourceMap) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item, useSourceMap);\n\n      if (item[2]) {\n        return '@media ' + item[2] + '{' + content + '}';\n      } else {\n        return content;\n      }\n    }).join('');\n  }; // import a list of modules into the list\n\n\n  list.i = function (modules, mediaQuery) {\n    if (typeof modules === 'string') {\n      modules = [[null, modules, '']];\n    }\n\n    var alreadyImportedModules = {};\n\n    for (var i = 0; i < this.length; i++) {\n      var id = this[i][0];\n\n      if (id != null) {\n        alreadyImportedModules[id] = true;\n      }\n    }\n\n    for (i = 0; i < modules.length; i++) {\n      var item = modules[i]; // skip already imported module\n      // this implementation is not 100% perfect for weird media query combinations\n      // when a module is imported multiple times with different media queries.\n      // I hope this will never occur (Hey this way we have smaller bundles)\n\n      if (item[0] == null || !alreadyImportedModules[item[0]]) {\n        if (mediaQuery && !item[2]) {\n          item[2] = mediaQuery;\n        } else if (mediaQuery) {\n          item[2] = '(' + item[2] + ') and (' + mediaQuery + ')';\n        }\n\n        list.push(item);\n      }\n    }\n  };\n\n  return list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || '';\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (useSourceMap && typeof btoa === 'function') {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n  }\n\n  return [content].join('\\n');\n} // Adapted from convert-source-map (MIT)\n\n\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n  return '/*# ' + data + ' */';\n}","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target, parent) {\n  if (parent){\n    return parent.querySelector(target);\n  }\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target, parent) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target, parent);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = require(\"./urls\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertAt.before, target);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\tif(options.attrs.nonce === undefined) {\n\t\tvar nonce = getNonce();\n\t\tif (nonce) {\n\t\t\toptions.attrs.nonce = nonce;\n\t\t}\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction getNonce() {\n\tif (typeof __webpack_nonce__ === 'undefined') {\n\t\treturn null;\n\t}\n\n\treturn __webpack_nonce__;\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = typeof options.transform === 'function'\n\t\t ? options.transform(obj.css) \n\t\t : options.transform.default(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n","\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n","// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"javascript\", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n  var statementIndent = parserConfig.statementIndent;\n  var jsonldMode = parserConfig.jsonld;\n  var jsonMode = parserConfig.json || jsonldMode;\n  var isTS = parserConfig.typescript;\n  var wordRE = parserConfig.wordCharacters || /[\\w$\\xa1-\\uffff]/;\n\n  // Tokenizer\n\n  var keywords = function(){\n    function kw(type) {return {type: type, style: \"keyword\"};}\n    var A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\"), D = kw(\"keyword d\");\n    var operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"};\n\n    return {\n      \"if\": kw(\"if\"), \"while\": A, \"with\": A, \"else\": B, \"do\": B, \"try\": B, \"finally\": B,\n      \"return\": D, \"break\": D, \"continue\": D, \"new\": kw(\"new\"), \"delete\": C, \"void\": C, \"throw\": C,\n      \"debugger\": kw(\"debugger\"), \"var\": kw(\"var\"), \"const\": kw(\"var\"), \"let\": kw(\"var\"),\n      \"function\": kw(\"function\"), \"catch\": kw(\"catch\"),\n      \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n      \"in\": operator, \"typeof\": operator, \"instanceof\": operator,\n      \"true\": atom, \"false\": atom, \"null\": atom, \"undefined\": atom, \"NaN\": atom, \"Infinity\": atom,\n      \"this\": kw(\"this\"), \"class\": kw(\"class\"), \"super\": kw(\"atom\"),\n      \"yield\": C, \"export\": kw(\"export\"), \"import\": kw(\"import\"), \"extends\": C,\n      \"await\": C\n    };\n  }();\n\n  var isOperatorChar = /[+\\-*&%=<>!?|~^@]/;\n  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)\"/;\n\n  function readRegexp(stream) {\n    var escaped = false, next, inSet = false;\n    while ((next = stream.next()) != null) {\n      if (!escaped) {\n        if (next == \"/\" && !inSet) return;\n        if (next == \"[\") inSet = true;\n        else if (inSet && next == \"]\") inSet = false;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n  }\n\n  // Used as scratch variables to communicate multiple values without\n  // consing up tons of objects.\n  var type, content;\n  function ret(tp, style, cont) {\n    type = tp; content = cont;\n    return style;\n  }\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == '\"' || ch == \"'\") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    } else if (ch == \".\" && stream.match(/^\\d+(?:[eE][+\\-]?\\d+)?/)) {\n      return ret(\"number\", \"number\");\n    } else if (ch == \".\" && stream.match(\"..\")) {\n      return ret(\"spread\", \"meta\");\n    } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n      return ret(ch);\n    } else if (ch == \"=\" && stream.eat(\">\")) {\n      return ret(\"=>\", \"operator\");\n    } else if (ch == \"0\" && stream.match(/^(?:x[\\da-f]+|o[0-7]+|b[01]+)n?/i)) {\n      return ret(\"number\", \"number\");\n    } else if (/\\d/.test(ch)) {\n      stream.match(/^\\d*(?:n|(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?)?/);\n      return ret(\"number\", \"number\");\n    } else if (ch == \"/\") {\n      if (stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      } else if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return ret(\"comment\", \"comment\");\n      } else if (expressionAllowed(stream, state, 1)) {\n        readRegexp(stream);\n        stream.match(/^\\b(([gimyus])(?![gimyus]*\\2))+\\b/);\n        return ret(\"regexp\", \"string-2\");\n      } else {\n        stream.eat(\"=\");\n        return ret(\"operator\", \"operator\", stream.current());\n      }\n    } else if (ch == \"`\") {\n      state.tokenize = tokenQuasi;\n      return tokenQuasi(stream, state);\n    } else if (ch == \"#\") {\n      stream.skipToEnd();\n      return ret(\"error\", \"error\");\n    } else if (isOperatorChar.test(ch)) {\n      if (ch != \">\" || !state.lexical || state.lexical.type != \">\") {\n        if (stream.eat(\"=\")) {\n          if (ch == \"!\" || ch == \"=\") stream.eat(\"=\")\n        } else if (/[<>*+\\-]/.test(ch)) {\n          stream.eat(ch)\n          if (ch == \">\") stream.eat(ch)\n        }\n      }\n      return ret(\"operator\", \"operator\", stream.current());\n    } else if (wordRE.test(ch)) {\n      stream.eatWhile(wordRE);\n      var word = stream.current()\n      if (state.lastType != \".\") {\n        if (keywords.propertyIsEnumerable(word)) {\n          var kw = keywords[word]\n          return ret(kw.type, kw.style, word)\n        }\n        if (word == \"async\" && stream.match(/^(\\s|\\/\\*.*?\\*\\/)*[\\[\\(\\w]/, false))\n          return ret(\"async\", \"keyword\", word)\n      }\n      return ret(\"variable\", \"variable\", word)\n    }\n  }\n\n  function tokenString(quote) {\n    return function(stream, state) {\n      var escaped = false, next;\n      if (jsonldMode && stream.peek() == \"@\" && stream.match(isJsonldKeyword)){\n        state.tokenize = tokenBase;\n        return ret(\"jsonld-keyword\", \"meta\");\n      }\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) break;\n        escaped = !escaped && next == \"\\\\\";\n      }\n      if (!escaped) state.tokenize = tokenBase;\n      return ret(\"string\", \"string\");\n    };\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return ret(\"comment\", \"comment\");\n  }\n\n  function tokenQuasi(stream, state) {\n    var escaped = false, next;\n    while ((next = stream.next()) != null) {\n      if (!escaped && (next == \"`\" || next == \"$\" && stream.eat(\"{\"))) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      escaped = !escaped && next == \"\\\\\";\n    }\n    return ret(\"quasi\", \"string-2\", stream.current());\n  }\n\n  var brackets = \"([{}])\";\n  // This is a crude lookahead trick to try and notice that we're\n  // parsing the argument patterns for a fat-arrow function before we\n  // actually hit the arrow token. It only works if the arrow is on\n  // the same line as the arguments and there's no strange noise\n  // (comments) in between. Fallback is to only notice when we hit the\n  // arrow, and not declare the arguments as locals for the arrow\n  // body.\n  function findFatArrow(stream, state) {\n    if (state.fatArrowAt) state.fatArrowAt = null;\n    var arrow = stream.string.indexOf(\"=>\", stream.start);\n    if (arrow < 0) return;\n\n    if (isTS) { // Try to skip TypeScript return type declarations after the arguments\n      var m = /:\\s*(?:\\w+(?:<[^>]*>|\\[\\])?|\\{[^}]*\\})\\s*$/.exec(stream.string.slice(stream.start, arrow))\n      if (m) arrow = m.index\n    }\n\n    var depth = 0, sawSomething = false;\n    for (var pos = arrow - 1; pos >= 0; --pos) {\n      var ch = stream.string.charAt(pos);\n      var bracket = brackets.indexOf(ch);\n      if (bracket >= 0 && bracket < 3) {\n        if (!depth) { ++pos; break; }\n        if (--depth == 0) { if (ch == \"(\") sawSomething = true; break; }\n      } else if (bracket >= 3 && bracket < 6) {\n        ++depth;\n      } else if (wordRE.test(ch)) {\n        sawSomething = true;\n      } else if (/[\"'\\/]/.test(ch)) {\n        return;\n      } else if (sawSomething && !depth) {\n        ++pos;\n        break;\n      }\n    }\n    if (sawSomething && !depth) state.fatArrowAt = pos;\n  }\n\n  // Parser\n\n  var atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true, \"regexp\": true, \"this\": true, \"jsonld-keyword\": true};\n\n  function JSLexical(indented, column, type, align, prev, info) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.prev = prev;\n    this.info = info;\n    if (align != null) this.align = align;\n  }\n\n  function inScope(state, varname) {\n    for (var v = state.localVars; v; v = v.next)\n      if (v.name == varname) return true;\n    for (var cx = state.context; cx; cx = cx.prev) {\n      for (var v = cx.vars; v; v = v.next)\n        if (v.name == varname) return true;\n    }\n  }\n\n  function parseJS(state, style, type, content, stream) {\n    var cc = state.cc;\n    // Communicate our context to the combinators.\n    // (Less wasteful than consing up a hundred closures on every call.)\n    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;\n\n    if (!state.lexical.hasOwnProperty(\"align\"))\n      state.lexical.align = true;\n\n    while(true) {\n      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;\n      if (combinator(type, content)) {\n        while(cc.length && cc[cc.length - 1].lex)\n          cc.pop()();\n        if (cx.marked) return cx.marked;\n        if (type == \"variable\" && inScope(state, content)) return \"variable-2\";\n        return style;\n      }\n    }\n  }\n\n  // Combinator utils\n\n  var cx = {state: null, column: null, marked: null, cc: null};\n  function pass() {\n    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n  }\n  function cont() {\n    pass.apply(null, arguments);\n    return true;\n  }\n  function inList(name, list) {\n    for (var v = list; v; v = v.next) if (v.name == name) return true\n    return false;\n  }\n  function register(varname) {\n    var state = cx.state;\n    cx.marked = \"def\";\n    if (state.context) {\n      if (state.lexical.info == \"var\" && state.context && state.context.block) {\n        // FIXME function decls are also not block scoped\n        var newContext = registerVarScoped(varname, state.context)\n        if (newContext != null) {\n          state.context = newContext\n          return\n        }\n      } else if (!inList(varname, state.localVars)) {\n        state.localVars = new Var(varname, state.localVars)\n        return\n      }\n    }\n    // Fall through means this is global\n    if (parserConfig.globalVars && !inList(varname, state.globalVars))\n      state.globalVars = new Var(varname, state.globalVars)\n  }\n  function registerVarScoped(varname, context) {\n    if (!context) {\n      return null\n    } else if (context.block) {\n      var inner = registerVarScoped(varname, context.prev)\n      if (!inner) return null\n      if (inner == context.prev) return context\n      return new Context(inner, context.vars, true)\n    } else if (inList(varname, context.vars)) {\n      return context\n    } else {\n      return new Context(context.prev, new Var(varname, context.vars), false)\n    }\n  }\n\n  function isModifier(name) {\n    return name == \"public\" || name == \"private\" || name == \"protected\" || name == \"abstract\" || name == \"readonly\"\n  }\n\n  // Combinators\n\n  function Context(prev, vars, block) { this.prev = prev; this.vars = vars; this.block = block }\n  function Var(name, next) { this.name = name; this.next = next }\n\n  var defaultVars = new Var(\"this\", new Var(\"arguments\", null))\n  function pushcontext() {\n    cx.state.context = new Context(cx.state.context, cx.state.localVars, false)\n    cx.state.localVars = defaultVars\n  }\n  function pushblockcontext() {\n    cx.state.context = new Context(cx.state.context, cx.state.localVars, true)\n    cx.state.localVars = null\n  }\n  function popcontext() {\n    cx.state.localVars = cx.state.context.vars\n    cx.state.context = cx.state.context.prev\n  }\n  popcontext.lex = true\n  function pushlex(type, info) {\n    var result = function() {\n      var state = cx.state, indent = state.indented;\n      if (state.lexical.type == \"stat\") indent = state.lexical.indented;\n      else for (var outer = state.lexical; outer && outer.type == \")\" && outer.align; outer = outer.prev)\n        indent = outer.indented;\n      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);\n    };\n    result.lex = true;\n    return result;\n  }\n  function poplex() {\n    var state = cx.state;\n    if (state.lexical.prev) {\n      if (state.lexical.type == \")\")\n        state.indented = state.lexical.indented;\n      state.lexical = state.lexical.prev;\n    }\n  }\n  poplex.lex = true;\n\n  function expect(wanted) {\n    function exp(type) {\n      if (type == wanted) return cont();\n      else if (wanted == \";\" || type == \"}\" || type == \")\" || type == \"]\") return pass();\n      else return cont(exp);\n    };\n    return exp;\n  }\n\n  function statement(type, value) {\n    if (type == \"var\") return cont(pushlex(\"vardef\", value), vardef, expect(\";\"), poplex);\n    if (type == \"keyword a\") return cont(pushlex(\"form\"), parenExpr, statement, poplex);\n    if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n    if (type == \"keyword d\") return cx.stream.match(/^\\s*$/, false) ? cont() : cont(pushlex(\"stat\"), maybeexpression, expect(\";\"), poplex);\n    if (type == \"debugger\") return cont(expect(\";\"));\n    if (type == \"{\") return cont(pushlex(\"}\"), pushblockcontext, block, poplex, popcontext);\n    if (type == \";\") return cont();\n    if (type == \"if\") {\n      if (cx.state.lexical.info == \"else\" && cx.state.cc[cx.state.cc.length - 1] == poplex)\n        cx.state.cc.pop()();\n      return cont(pushlex(\"form\"), parenExpr, statement, poplex, maybeelse);\n    }\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"for\") return cont(pushlex(\"form\"), forspec, statement, poplex);\n    if (type == \"class\" || (isTS && value == \"interface\")) {\n      cx.marked = \"keyword\"\n      return cont(pushlex(\"form\", type == \"class\" ? type : value), className, poplex)\n    }\n    if (type == \"variable\") {\n      if (isTS && value == \"declare\") {\n        cx.marked = \"keyword\"\n        return cont(statement)\n      } else if (isTS && (value == \"module\" || value == \"enum\" || value == \"type\") && cx.stream.match(/^\\s*\\w/, false)) {\n        cx.marked = \"keyword\"\n        if (value == \"enum\") return cont(enumdef);\n        else if (value == \"type\") return cont(typename, expect(\"operator\"), typeexpr, expect(\";\"));\n        else return cont(pushlex(\"form\"), pattern, expect(\"{\"), pushlex(\"}\"), block, poplex, poplex)\n      } else if (isTS && value == \"namespace\") {\n        cx.marked = \"keyword\"\n        return cont(pushlex(\"form\"), expression, statement, poplex)\n      } else if (isTS && value == \"abstract\") {\n        cx.marked = \"keyword\"\n        return cont(statement)\n      } else {\n        return cont(pushlex(\"stat\"), maybelabel);\n      }\n    }\n    if (type == \"switch\") return cont(pushlex(\"form\"), parenExpr, expect(\"{\"), pushlex(\"}\", \"switch\"), pushblockcontext,\n                                      block, poplex, poplex, popcontext);\n    if (type == \"case\") return cont(expression, expect(\":\"));\n    if (type == \"default\") return cont(expect(\":\"));\n    if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);\n    if (type == \"export\") return cont(pushlex(\"stat\"), afterExport, poplex);\n    if (type == \"import\") return cont(pushlex(\"stat\"), afterImport, poplex);\n    if (type == \"async\") return cont(statement)\n    if (value == \"@\") return cont(expression, statement)\n    return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n  }\n  function maybeCatchBinding(type) {\n    if (type == \"(\") return cont(funarg, expect(\")\"))\n  }\n  function expression(type, value) {\n    return expressionInner(type, value, false);\n  }\n  function expressionNoComma(type, value) {\n    return expressionInner(type, value, true);\n  }\n  function parenExpr(type) {\n    if (type != \"(\") return pass()\n    return cont(pushlex(\")\"), expression, expect(\")\"), poplex)\n  }\n  function expressionInner(type, value, noComma) {\n    if (cx.state.fatArrowAt == cx.stream.start) {\n      var body = noComma ? arrowBodyNoComma : arrowBody;\n      if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, expect(\"=>\"), body, popcontext);\n      else if (type == \"variable\") return pass(pushcontext, pattern, expect(\"=>\"), body, popcontext);\n    }\n\n    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;\n    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);\n    if (type == \"function\") return cont(functiondef, maybeop);\n    if (type == \"class\" || (isTS && value == \"interface\")) { cx.marked = \"keyword\"; return cont(pushlex(\"form\"), classExpression, poplex); }\n    if (type == \"keyword c\" || type == \"async\") return cont(noComma ? expressionNoComma : expression);\n    if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeop);\n    if (type == \"operator\" || type == \"spread\") return cont(noComma ? expressionNoComma : expression);\n    if (type == \"[\") return cont(pushlex(\"]\"), arrayLiteral, poplex, maybeop);\n    if (type == \"{\") return contCommasep(objprop, \"}\", null, maybeop);\n    if (type == \"quasi\") return pass(quasi, maybeop);\n    if (type == \"new\") return cont(maybeTarget(noComma));\n    if (type == \"import\") return cont(expression);\n    return cont();\n  }\n  function maybeexpression(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expression);\n  }\n\n  function maybeoperatorComma(type, value) {\n    if (type == \",\") return cont(expression);\n    return maybeoperatorNoComma(type, value, false);\n  }\n  function maybeoperatorNoComma(type, value, noComma) {\n    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;\n    var expr = noComma == false ? expression : expressionNoComma;\n    if (type == \"=>\") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);\n    if (type == \"operator\") {\n      if (/\\+\\+|--/.test(value) || isTS && value == \"!\") return cont(me);\n      if (isTS && value == \"<\" && cx.stream.match(/^([^>]|<.*?>)*>\\s*\\(/, false))\n        return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, me);\n      if (value == \"?\") return cont(expression, expect(\":\"), expr);\n      return cont(expr);\n    }\n    if (type == \"quasi\") { return pass(quasi, me); }\n    if (type == \";\") return;\n    if (type == \"(\") return contCommasep(expressionNoComma, \")\", \"call\", me);\n    if (type == \".\") return cont(property, me);\n    if (type == \"[\") return cont(pushlex(\"]\"), maybeexpression, expect(\"]\"), poplex, me);\n    if (isTS && value == \"as\") { cx.marked = \"keyword\"; return cont(typeexpr, me) }\n    if (type == \"regexp\") {\n      cx.state.lastType = cx.marked = \"operator\"\n      cx.stream.backUp(cx.stream.pos - cx.stream.start - 1)\n      return cont(expr)\n    }\n  }\n  function quasi(type, value) {\n    if (type != \"quasi\") return pass();\n    if (value.slice(value.length - 2) != \"${\") return cont(quasi);\n    return cont(expression, continueQuasi);\n  }\n  function continueQuasi(type) {\n    if (type == \"}\") {\n      cx.marked = \"string-2\";\n      cx.state.tokenize = tokenQuasi;\n      return cont(quasi);\n    }\n  }\n  function arrowBody(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expression);\n  }\n  function arrowBodyNoComma(type) {\n    findFatArrow(cx.stream, cx.state);\n    return pass(type == \"{\" ? statement : expressionNoComma);\n  }\n  function maybeTarget(noComma) {\n    return function(type) {\n      if (type == \".\") return cont(noComma ? targetNoComma : target);\n      else if (type == \"variable\" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma)\n      else return pass(noComma ? expressionNoComma : expression);\n    };\n  }\n  function target(_, value) {\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorComma); }\n  }\n  function targetNoComma(_, value) {\n    if (value == \"target\") { cx.marked = \"keyword\"; return cont(maybeoperatorNoComma); }\n  }\n  function maybelabel(type) {\n    if (type == \":\") return cont(poplex, statement);\n    return pass(maybeoperatorComma, expect(\";\"), poplex);\n  }\n  function property(type) {\n    if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n  }\n  function objprop(type, value) {\n    if (type == \"async\") {\n      cx.marked = \"property\";\n      return cont(objprop);\n    } else if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      if (value == \"get\" || value == \"set\") return cont(getterSetter);\n      var m // Work around fat-arrow-detection complication for detecting typescript typed arrow params\n      if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\\s*:\\s*/, false)))\n        cx.state.fatArrowAt = cx.stream.pos + m[0].length\n      return cont(afterprop);\n    } else if (type == \"number\" || type == \"string\") {\n      cx.marked = jsonldMode ? \"property\" : (cx.style + \" property\");\n      return cont(afterprop);\n    } else if (type == \"jsonld-keyword\") {\n      return cont(afterprop);\n    } else if (isTS && isModifier(value)) {\n      cx.marked = \"keyword\"\n      return cont(objprop)\n    } else if (type == \"[\") {\n      return cont(expression, maybetype, expect(\"]\"), afterprop);\n    } else if (type == \"spread\") {\n      return cont(expressionNoComma, afterprop);\n    } else if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(objprop);\n    } else if (type == \":\") {\n      return pass(afterprop)\n    }\n  }\n  function getterSetter(type) {\n    if (type != \"variable\") return pass(afterprop);\n    cx.marked = \"property\";\n    return cont(functiondef);\n  }\n  function afterprop(type) {\n    if (type == \":\") return cont(expressionNoComma);\n    if (type == \"(\") return pass(functiondef);\n  }\n  function commasep(what, end, sep) {\n    function proceed(type, value) {\n      if (sep ? sep.indexOf(type) > -1 : type == \",\") {\n        var lex = cx.state.lexical;\n        if (lex.info == \"call\") lex.pos = (lex.pos || 0) + 1;\n        return cont(function(type, value) {\n          if (type == end || value == end) return pass()\n          return pass(what)\n        }, proceed);\n      }\n      if (type == end || value == end) return cont();\n      if (sep && sep.indexOf(\";\") > -1) return pass(what)\n      return cont(expect(end));\n    }\n    return function(type, value) {\n      if (type == end || value == end) return cont();\n      return pass(what, proceed);\n    };\n  }\n  function contCommasep(what, end, info) {\n    for (var i = 3; i < arguments.length; i++)\n      cx.cc.push(arguments[i]);\n    return cont(pushlex(end, info), commasep(what, end), poplex);\n  }\n  function block(type) {\n    if (type == \"}\") return cont();\n    return pass(statement, block);\n  }\n  function maybetype(type, value) {\n    if (isTS) {\n      if (type == \":\" || value == \"in\") return cont(typeexpr);\n      if (value == \"?\") return cont(maybetype);\n    }\n  }\n  function mayberettype(type) {\n    if (isTS && type == \":\") {\n      if (cx.stream.match(/^\\s*\\w+\\s+is\\b/, false)) return cont(expression, isKW, typeexpr)\n      else return cont(typeexpr)\n    }\n  }\n  function isKW(_, value) {\n    if (value == \"is\") {\n      cx.marked = \"keyword\"\n      return cont()\n    }\n  }\n  function typeexpr(type, value) {\n    if (value == \"keyof\" || value == \"typeof\" || value == \"infer\") {\n      cx.marked = \"keyword\"\n      return cont(value == \"typeof\" ? expressionNoComma : typeexpr)\n    }\n    if (type == \"variable\" || value == \"void\") {\n      cx.marked = \"type\"\n      return cont(afterType)\n    }\n    if (value == \"|\" || value == \"&\") return cont(typeexpr)\n    if (type == \"string\" || type == \"number\" || type == \"atom\") return cont(afterType);\n    if (type == \"[\") return cont(pushlex(\"]\"), commasep(typeexpr, \"]\", \",\"), poplex, afterType)\n    if (type == \"{\") return cont(pushlex(\"}\"), commasep(typeprop, \"}\", \",;\"), poplex, afterType)\n    if (type == \"(\") return cont(commasep(typearg, \")\"), maybeReturnType, afterType)\n    if (type == \"<\") return cont(commasep(typeexpr, \">\"), typeexpr)\n  }\n  function maybeReturnType(type) {\n    if (type == \"=>\") return cont(typeexpr)\n  }\n  function typeprop(type, value) {\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\"\n      return cont(typeprop)\n    } else if (value == \"?\" || type == \"number\" || type == \"string\") {\n      return cont(typeprop)\n    } else if (type == \":\") {\n      return cont(typeexpr)\n    } else if (type == \"[\") {\n      return cont(expect(\"variable\"), maybetype, expect(\"]\"), typeprop)\n    } else if (type == \"(\") {\n      return pass(functiondecl, typeprop)\n    }\n  }\n  function typearg(type, value) {\n    if (type == \"variable\" && cx.stream.match(/^\\s*[?:]/, false) || value == \"?\") return cont(typearg)\n    if (type == \":\") return cont(typeexpr)\n    if (type == \"spread\") return cont(typearg)\n    return pass(typeexpr)\n  }\n  function afterType(type, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType)\n    if (value == \"|\" || type == \".\" || value == \"&\") return cont(typeexpr)\n    if (type == \"[\") return cont(typeexpr, expect(\"]\"), afterType)\n    if (value == \"extends\" || value == \"implements\") { cx.marked = \"keyword\"; return cont(typeexpr) }\n    if (value == \"?\") return cont(typeexpr, expect(\":\"), typeexpr)\n  }\n  function maybeTypeArgs(_, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeexpr, \">\"), poplex, afterType)\n  }\n  function typeparam() {\n    return pass(typeexpr, maybeTypeDefault)\n  }\n  function maybeTypeDefault(_, value) {\n    if (value == \"=\") return cont(typeexpr)\n  }\n  function vardef(_, value) {\n    if (value == \"enum\") {cx.marked = \"keyword\"; return cont(enumdef)}\n    return pass(pattern, maybetype, maybeAssign, vardefCont);\n  }\n  function pattern(type, value) {\n    if (isTS && isModifier(value)) { cx.marked = \"keyword\"; return cont(pattern) }\n    if (type == \"variable\") { register(value); return cont(); }\n    if (type == \"spread\") return cont(pattern);\n    if (type == \"[\") return contCommasep(eltpattern, \"]\");\n    if (type == \"{\") return contCommasep(proppattern, \"}\");\n  }\n  function proppattern(type, value) {\n    if (type == \"variable\" && !cx.stream.match(/^\\s*:/, false)) {\n      register(value);\n      return cont(maybeAssign);\n    }\n    if (type == \"variable\") cx.marked = \"property\";\n    if (type == \"spread\") return cont(pattern);\n    if (type == \"}\") return pass();\n    if (type == \"[\") return cont(expression, expect(']'), expect(':'), proppattern);\n    return cont(expect(\":\"), pattern, maybeAssign);\n  }\n  function eltpattern() {\n    return pass(pattern, maybeAssign)\n  }\n  function maybeAssign(_type, value) {\n    if (value == \"=\") return cont(expressionNoComma);\n  }\n  function vardefCont(type) {\n    if (type == \",\") return cont(vardef);\n  }\n  function maybeelse(type, value) {\n    if (type == \"keyword b\" && value == \"else\") return cont(pushlex(\"form\", \"else\"), statement, poplex);\n  }\n  function forspec(type, value) {\n    if (value == \"await\") return cont(forspec);\n    if (type == \"(\") return cont(pushlex(\")\"), forspec1, poplex);\n  }\n  function forspec1(type) {\n    if (type == \"var\") return cont(vardef, forspec2);\n    if (type == \"variable\") return cont(forspec2);\n    return pass(forspec2)\n  }\n  function forspec2(type, value) {\n    if (type == \")\") return cont()\n    if (type == \";\") return cont(forspec2)\n    if (value == \"in\" || value == \"of\") { cx.marked = \"keyword\"; return cont(expression, forspec2) }\n    return pass(expression, forspec2)\n  }\n  function functiondef(type, value) {\n    if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondef);}\n    if (type == \"variable\") {register(value); return cont(functiondef);}\n    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, mayberettype, statement, popcontext);\n    if (isTS && value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, functiondef)\n  }\n  function functiondecl(type, value) {\n    if (value == \"*\") {cx.marked = \"keyword\"; return cont(functiondecl);}\n    if (type == \"variable\") {register(value); return cont(functiondecl);}\n    if (type == \"(\") return cont(pushcontext, pushlex(\")\"), commasep(funarg, \")\"), poplex, mayberettype, popcontext);\n    if (isTS && value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, functiondecl)\n  }\n  function typename(type, value) {\n    if (type == \"keyword\" || type == \"variable\") {\n      cx.marked = \"type\"\n      return cont(typename)\n    } else if (value == \"<\") {\n      return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex)\n    }\n  }\n  function funarg(type, value) {\n    if (value == \"@\") cont(expression, funarg)\n    if (type == \"spread\") return cont(funarg);\n    if (isTS && isModifier(value)) { cx.marked = \"keyword\"; return cont(funarg); }\n    if (isTS && type == \"this\") return cont(maybetype, maybeAssign)\n    return pass(pattern, maybetype, maybeAssign);\n  }\n  function classExpression(type, value) {\n    // Class expressions may have an optional name.\n    if (type == \"variable\") return className(type, value);\n    return classNameAfter(type, value);\n  }\n  function className(type, value) {\n    if (type == \"variable\") {register(value); return cont(classNameAfter);}\n  }\n  function classNameAfter(type, value) {\n    if (value == \"<\") return cont(pushlex(\">\"), commasep(typeparam, \">\"), poplex, classNameAfter)\n    if (value == \"extends\" || value == \"implements\" || (isTS && type == \",\")) {\n      if (value == \"implements\") cx.marked = \"keyword\";\n      return cont(isTS ? typeexpr : expression, classNameAfter);\n    }\n    if (type == \"{\") return cont(pushlex(\"}\"), classBody, poplex);\n  }\n  function classBody(type, value) {\n    if (type == \"async\" ||\n        (type == \"variable\" &&\n         (value == \"static\" || value == \"get\" || value == \"set\" || (isTS && isModifier(value))) &&\n         cx.stream.match(/^\\s+[\\w$\\xa1-\\uffff]/, false))) {\n      cx.marked = \"keyword\";\n      return cont(classBody);\n    }\n    if (type == \"variable\" || cx.style == \"keyword\") {\n      cx.marked = \"property\";\n      return cont(isTS ? classfield : functiondef, classBody);\n    }\n    if (type == \"number\" || type == \"string\") return cont(isTS ? classfield : functiondef, classBody);\n    if (type == \"[\")\n      return cont(expression, maybetype, expect(\"]\"), isTS ? classfield : functiondef, classBody)\n    if (value == \"*\") {\n      cx.marked = \"keyword\";\n      return cont(classBody);\n    }\n    if (isTS && type == \"(\") return pass(functiondecl, classBody)\n    if (type == \";\" || type == \",\") return cont(classBody);\n    if (type == \"}\") return cont();\n    if (value == \"@\") return cont(expression, classBody)\n  }\n  function classfield(type, value) {\n    if (value == \"?\") return cont(classfield)\n    if (type == \":\") return cont(typeexpr, maybeAssign)\n    if (value == \"=\") return cont(expressionNoComma)\n    var context = cx.state.lexical.prev, isInterface = context && context.info == \"interface\"\n    return pass(isInterface ? functiondecl : functiondef)\n  }\n  function afterExport(type, value) {\n    if (value == \"*\") { cx.marked = \"keyword\"; return cont(maybeFrom, expect(\";\")); }\n    if (value == \"default\") { cx.marked = \"keyword\"; return cont(expression, expect(\";\")); }\n    if (type == \"{\") return cont(commasep(exportField, \"}\"), maybeFrom, expect(\";\"));\n    return pass(statement);\n  }\n  function exportField(type, value) {\n    if (value == \"as\") { cx.marked = \"keyword\"; return cont(expect(\"variable\")); }\n    if (type == \"variable\") return pass(expressionNoComma, exportField);\n  }\n  function afterImport(type) {\n    if (type == \"string\") return cont();\n    if (type == \"(\") return pass(expression);\n    return pass(importSpec, maybeMoreImports, maybeFrom);\n  }\n  function importSpec(type, value) {\n    if (type == \"{\") return contCommasep(importSpec, \"}\");\n    if (type == \"variable\") register(value);\n    if (value == \"*\") cx.marked = \"keyword\";\n    return cont(maybeAs);\n  }\n  function maybeMoreImports(type) {\n    if (type == \",\") return cont(importSpec, maybeMoreImports)\n  }\n  function maybeAs(_type, value) {\n    if (value == \"as\") { cx.marked = \"keyword\"; return cont(importSpec); }\n  }\n  function maybeFrom(_type, value) {\n    if (value == \"from\") { cx.marked = \"keyword\"; return cont(expression); }\n  }\n  function arrayLiteral(type) {\n    if (type == \"]\") return cont();\n    return pass(commasep(expressionNoComma, \"]\"));\n  }\n  function enumdef() {\n    return pass(pushlex(\"form\"), pattern, expect(\"{\"), pushlex(\"}\"), commasep(enummember, \"}\"), poplex, poplex)\n  }\n  function enummember() {\n    return pass(pattern, maybeAssign);\n  }\n\n  function isContinuedStatement(state, textAfter) {\n    return state.lastType == \"operator\" || state.lastType == \",\" ||\n      isOperatorChar.test(textAfter.charAt(0)) ||\n      /[,.]/.test(textAfter.charAt(0));\n  }\n\n  function expressionAllowed(stream, state, backUp) {\n    return state.tokenize == tokenBase &&\n      /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\\[{}\\(,;:]|=>)$/.test(state.lastType) ||\n      (state.lastType == \"quasi\" && /\\{\\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0))))\n  }\n\n  // Interface\n\n  return {\n    startState: function(basecolumn) {\n      var state = {\n        tokenize: tokenBase,\n        lastType: \"sof\",\n        cc: [],\n        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n        localVars: parserConfig.localVars,\n        context: parserConfig.localVars && new Context(null, null, false),\n        indented: basecolumn || 0\n      };\n      if (parserConfig.globalVars && typeof parserConfig.globalVars == \"object\")\n        state.globalVars = parserConfig.globalVars;\n      return state;\n    },\n\n    token: function(stream, state) {\n      if (stream.sol()) {\n        if (!state.lexical.hasOwnProperty(\"align\"))\n          state.lexical.align = false;\n        state.indented = stream.indentation();\n        findFatArrow(stream, state);\n      }\n      if (state.tokenize != tokenComment && stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      if (type == \"comment\") return style;\n      state.lastType = type == \"operator\" && (content == \"++\" || content == \"--\") ? \"incdec\" : type;\n      return parseJS(state, style, type, content, stream);\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize == tokenComment) return CodeMirror.Pass;\n      if (state.tokenize != tokenBase) return 0;\n      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top\n      // Kludge to prevent 'maybelse' from blocking lexical scope pops\n      if (!/^\\s*else\\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {\n        var c = state.cc[i];\n        if (c == poplex) lexical = lexical.prev;\n        else if (c != maybeelse) break;\n      }\n      while ((lexical.type == \"stat\" || lexical.type == \"form\") &&\n             (firstChar == \"}\" || ((top = state.cc[state.cc.length - 1]) &&\n                                   (top == maybeoperatorComma || top == maybeoperatorNoComma) &&\n                                   !/^[,\\.=+\\-*:?[\\(]/.test(textAfter))))\n        lexical = lexical.prev;\n      if (statementIndent && lexical.type == \")\" && lexical.prev.type == \"stat\")\n        lexical = lexical.prev;\n      var type = lexical.type, closing = firstChar == type;\n\n      if (type == \"vardef\") return lexical.indented + (state.lastType == \"operator\" || state.lastType == \",\" ? lexical.info.length + 1 : 0);\n      else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n      else if (type == \"form\") return lexical.indented + indentUnit;\n      else if (type == \"stat\")\n        return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);\n      else if (lexical.info == \"switch\" && !closing && parserConfig.doubleIndentSwitch != false)\n        return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n      else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n      else return lexical.indented + (closing ? 0 : indentUnit);\n    },\n\n    electricInput: /^\\s*(?:case .*?:|default:|\\{|\\})$/,\n    blockCommentStart: jsonMode ? null : \"/*\",\n    blockCommentEnd: jsonMode ? null : \"*/\",\n    blockCommentContinue: jsonMode ? null : \" * \",\n    lineComment: jsonMode ? null : \"//\",\n    fold: \"brace\",\n    closeBrackets: \"()[]{}''\\\"\\\"``\",\n\n    helperType: jsonMode ? \"json\" : \"javascript\",\n    jsonldMode: jsonldMode,\n    jsonMode: jsonMode,\n\n    expressionAllowed: expressionAllowed,\n\n    skipExpression: function(state) {\n      var top = state.cc[state.cc.length - 1]\n      if (top == expression || top == expressionNoComma) state.cc.pop()\n    }\n  };\n});\n\nCodeMirror.registerHelper(\"wordChars\", \"javascript\", /[\\w$]/);\n\nCodeMirror.defineMIME(\"text/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"text/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/x-javascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/ecmascript\", \"javascript\");\nCodeMirror.defineMIME(\"application/json\", {name: \"javascript\", json: true});\nCodeMirror.defineMIME(\"application/x-json\", {name: \"javascript\", json: true});\nCodeMirror.defineMIME(\"application/ld+json\", {name: \"javascript\", jsonld: true});\nCodeMirror.defineMIME(\"text/typescript\", { name: \"javascript\", typescript: true });\nCodeMirror.defineMIME(\"application/typescript\", { name: \"javascript\", typescript: true });\n\n});\n","import * as JSInterpreter from \"js-interpreter\";\nimport { Node } from \"acorn\";\nimport { Degrees, Vector2d, Segment } from \"./geometry\";\n\nimport { Animation, Frame } from \"./frames\";\nimport { Stroke } from \"./scene\";\n\nimport * as MainLoop from \"mainloop.js\" // FIXME: we don't want you here!\n\nexport type State = {\n    node: Node;\n    value?: any;\n    mode_?: any;\n    isLoop?: boolean;\n    n_?: number;\n    doneVariable_: true;\n\n    // Call\n    doneCallee_?: boolean;\n    doneArgs_?: boolean;\n    doneExec_?: boolean;\n    arguments_?: Node[];\n\n    // Switch\n    test_?: boolean;\n    index_?: number;\n    checked_?: boolean[];\n    switchValue_?: any;\n    isSwitch?: boolean;\n\n    // Try\n    doneBlock_?: boolean;\n    doneHandler_?: boolean;\n    doneFinalizer_?: boolean;\n    throwValue?: any;\n}\n\ntype NativeInterpreter = {\n    ast: Node;\n    appendCode: (code: any) => void;\n    step: () => boolean;\n    run: () => boolean;\n    stateStack: State[];\n    value: any;\n    parentScope: any;\n    setProperty(scope: any, name: string, value: any, desc?: PropertyDescriptor);\n    createNativeFunction(fn: Function): any;\n    createPrimitive(value: any): any;\n    createObject(value: any): any;\n};\ninterface InitFunc {\n    (interpreter: NativeInterpreter, scope: any): any;\n}\n\nexport interface Environment {\n    forward(distance: number): void;\n    back(distance: number): void;\n    left(angle: Degrees): void;\n    right(angle: Degrees): void;\n    up(): void;\n    down(): void;\n    hide(): void;\n    show(): void;\n}\n\nexport class Instruction {\n    constructor(\n        readonly currentState: State,\n        readonly animation: Animation) { }\n\n    get node() {\n        let state = this.currentState, node = state.node;\n        if (node.type === \"ForStatement\") {\n            if (state.mode_ === 1) {\n                node = (<any>node).test;\n            } else if (state.mode_ === 3) {\n                node = (<any>node).update;\n            }\n        } else if (node.type === \"ForInStatement\") {\n            if (state.isLoop) {\n                node = {\n                    type: \"ForInUpdate\",\n                    start: (<any>node).left.start,\n                    end: (<any>node).right.end,\n                };\n            }\n        } else if (/(Do|While)Statement/.test(node.type) && state.isLoop) {\n            node = (<any>node).test\n        } else if (node.type === \"IfStatement\") {\n            if (state.mode_ === 1) {\n                node = (<any>node).test;\n            }\n        } else if (node.type === \"SwitchStatement\") {\n            if (state.switchValue_ && +state.value === +state.switchValue_) {\n                node = (<any>node).cases[state.index_];\n            } else if (state.test_) {\n                node = (<any>node).discriminant;\n            }\n        } else if (node.type === \"TryStatement\") {\n            if (state.throwValue) {\n                node = (<any>node).handler.param;\n            }\n        } else if (node.type === \"ConditionalExpression\") {\n            if (state.mode_ === 1) {\n                node = (<any>node).test;\n            } else if (state.mode_ === 2) {\n                if ((<any>node).test_) {\n                    node = (<any>node).consequent;\n                } else {\n                    node = (<any>node).alternate;\n                }\n            }\n        } else if (node.type === \"SequenceExpression\") {\n            if (state.n_) {\n                node = (<any>node).expressions[state.n_ - 1];\n            }\n        } else if (node.type === \"CallExpression\") {\n            if (state.n_ && !state.doneArgs_) {\n                node = (<any>node).arguments[state.n_ - 1];\n            }\n        }\n\n        return node;\n    }\n}\n\ninterface Stack<T> {\n    push(item: T): number;\n    pop(): T;\n    peek(): T;\n    map<R>(fn: (t: T) => R): R;\n}\n\nconst MOVE_DURATION = 50;\nconst ROTATE_DURATION = 25;\nconst RISE_DURATION = 25;\nconst FALL_DURATION = 25;\nconst FADE_DURATION = 25;\nconst WAIT_DURATION = 10;\n\nexport class Interpreter {\n    private interpreter: NativeInterpreter;\n\n    private instructionStack: Stack<Node> = (() => {\n        let instructionStack = [] as any;\n        instructionStack.peek = function (): Node {\n            return this[this.length - 1];\n        };\n        return instructionStack as Stack<Node>;\n    })();\n\n    constructor(readonly code: string) {\n        this.interpreter = new JSInterpreter(code, this.init);\n    }\n\n    private readonly init: InitFunc = (interpreter, scope) => {\n        set(\"forward\", (distance: number, color?: string) => {\n            this.animation = new Animation(MOVE_DURATION * distance / 10, (delta: number, keyFrame: Frame) => {\n                let from = keyFrame.position, angle = keyFrame.facingRadians;\n                let to = from.plus(Vector2d.polar(angle, distance * delta));\n\n                if (keyFrame.height === 0) {\n                    return keyFrame.with({ position: to, newStrokes: [new Stroke(from, to, color)] });\n                }\n                return keyFrame.with({ position: to });\n            });\n        });\n        set(\"back\", (distance: number, color?: string) => {\n            this.animation = new Animation(MOVE_DURATION * distance / 10, (delta: number, keyFrame: Frame) => {\n                let from = keyFrame.position, angle = keyFrame.facingRadians;\n                let to = from.plus(Vector2d.polar(angle, -distance * delta));\n\n                if (keyFrame.height === 0) {\n                    return keyFrame.with({ position: to, newStrokes: [new Stroke(from, to, color)] });\n                }\n                return keyFrame.with({ position: to });\n            });\n        });\n        set(\"right\", (angle: Degrees) => {\n            this.animation = new Animation(ROTATE_DURATION * angle / 30, (delta: number, keyFrame: Frame) => {\n                return keyFrame.with({ facing: keyFrame.facing - angle * delta });\n            });\n        });\n        set(\"left\", (angle: Degrees) => {\n            this.animation = new Animation(ROTATE_DURATION * angle / 30, (delta: number, keyFrame: Frame) => {\n                return keyFrame.with({ facing: keyFrame.facing + angle * delta });\n            });\n        });\n        set(\"up\", () => {\n            this.animation = new Animation(RISE_DURATION, (delta: number, keyFrame: Frame) => {\n                return keyFrame.with({ height: delta });\n            });\n        });\n        set(\"down\", () => {\n            this.animation = new Animation(FALL_DURATION, (delta: number, keyFrame: Frame) => {\n                return keyFrame.with({ height: 1 - delta });\n            });\n        });\n        set(\"hide\", () => {\n            this.animation = new Animation(FADE_DURATION, (delta: number, keyFrame: Frame) => {\n                return keyFrame.with({ opacity: 1 - delta });\n            });\n        });\n        set(\"show\", () => {\n            this.animation = new Animation(FADE_DURATION, (delta: number, keyFrame: Frame) => {\n                return keyFrame.with({ opacity: delta });\n            });\n        });\n\n        let foreground = \"black\";\n        prop(\"foreground\", {\n            get: fn(() => {\n                return foreground;\n            }),\n            set: fn((fg) => {\n                foreground = String(fg);\n                this.animation = new Animation(0, (_, keyFrame: Frame) => {\n                    return keyFrame.with({ foreground });\n                });\n            })\n        });\n\n        let background = \"none\";\n        prop(\"background\", {\n            get: fn(() => {\n                return background;\n            }),\n            set: fn((bg) => {\n                background = String(bg);\n                this.animation = new Animation(0, (_, keyFrame: Frame) => {\n                    return keyFrame.with({ background });\n                });\n            })\n        });\n\n        set(\"ask\", (question: any) => {\n            MainLoop.stop(); // FIXME: find another way to make this sync, please!\n\n            let input = prompt(String(question));\n\n            MainLoop.start(); // FIXME:\n\n            return wrap(input);\n        });\n\n        // FIXME: no document.getElementById here!\n        set(\"print\", (...words: any[]) => {\n            document.getElementById(\"out\").innerHTML += words.join(\" \");\n        });\n        set(\"println\", (...lines: any[]) => {\n            document.getElementById(\"out\").innerHTML += lines.join(\"\\n\") + \"\\n\";\n        });\n\n        set(\"wait\", (seconds: number) => {\n            this.animation = new Animation(seconds * 80, (_, keyFrame: Frame) => keyFrame); // FIXME: Magic Number!\n        });\n\n        set(\"random\", (min?: number, max?: number) => {\n            if (typeof min === \"undefined\") {\n                return Math.random();\n            }\n            if (typeof max === \"undefined\") {\n                max = min;\n                min = 0;\n            }\n            let delta = max - min;\n            return min + Math.random() * delta | 0;\n        });\n\n        set(\"rgb\", (r: number, g: number, b: number) => {\n            checkRange(\"red\", r, 0, 255);\n            checkRange(\"green\", g, 0, 255);\n            checkRange(\"blue\", b, 0, 255);\n\n            return `rgb(${r | 0},${g | 0},${b | 0})`;\n        });\n        set(\"rgba\", (r: number, g: number, b: number, a: number) => {\n            checkRange(\"red\", r, 0, 255);\n            checkRange(\"green\", g, 0, 255);\n            checkRange(\"blue\", b, 0, 255);\n            checkRange(\"alpha\", a, 0, 1);\n\n            return `rgba(${r | 0},${g | 0},${b | 0},${a})`;\n        });\n        function checkRange(name: string, value: number, min: number, max: number) {\n            if (value < min) throw new Error(`${name} should be >= ${min} (was ${value})`);\n            if (value > max) throw new Error(`${name} should be <= ${max} (was ${value})`);\n        }\n\n        function set(name: string, fnWrapper: Function) {\n            interpreter.setProperty(scope, name, fn(fnWrapper));\n        }\n        function fn(wrapper: Function) {\n            return interpreter.createNativeFunction(wrapper);\n        }\n        function wrap(value: any): any {\n            return interpreter.createPrimitive(value);\n        }\n        function prop(name: string, desc: PropertyDescriptor) {\n            interpreter.setProperty(scope, name, null, desc);\n        }\n    };\n\n    reset() {\n        this.interpreter = new JSInterpreter(this.interpreter.ast, this.init);\n    }\n\n    private step(): State {\n        let recoverState = this.currentState;\n        try {\n            if (this.interpreter.step()) {\n                return this.currentState;\n            }\n        } catch (e) {\n            e.state = recoverState;\n            throw e;\n        }\n        return null;\n    }\n    private get currentState(): State {\n        return this.interpreter.stateStack[this.interpreter.stateStack.length - 1];\n    }\n    private get currentNode(): Node {\n        return this.instructionStack.peek();\n    }\n\n    private state: State;\n    private animation: Animation;\n    private get currentInstruction(): Instruction {\n        let instruction = new Instruction(this.state, this.animation);\n        this.animation = null;\n        return instruction;\n    }\n\n    stepToNextInstruction(): Instruction {\n        seek: {\n            while (this.state = this.step()) {\n                let node = this.state.node;\n\n                if (node.type === \"ForStatement\") {\n                    if (node !== this.currentNode) {\n                        this.instructionStack.push(node);\n                        break seek;\n                    } else if (this.state.mode_ === 1) {\n                        break seek; // return For.TestInstruction\n                    } else if (this.state.mode_ === 3) {\n                        break seek; // return For.UpdateInstruction\n                    } else if (this.state.mode_ === 2) {\n                        if (!this.state.value || !this.state.value.data) {\n                            this.instructionStack.pop();\n                        }\n                        break seek;\n                    }\n                } else if (node.type === \"ForInStatement\") {\n                    if (!this.state.doneVariable_) {\n                        break seek;\n                    } else if (this.state.isLoop) {\n                        break seek; // return ForIn.Update\n                    }\n                } else if (/(Do|While)Statement/.test(node.type)) {\n                    if (node !== this.currentNode) {\n                        this.instructionStack.push(node);\n                        break seek;\n                    } else if (this.state.isLoop) {\n                        if (!this.state.value || !this.state.value.data) {\n                            this.instructionStack.pop();\n                        }\n                        break seek; // return While.TestInstruction\n                    }\n                } else if (node.type === \"BlockStatement\") {\n                    if (!this.state.n_) {\n                        break seek;\n                    }\n                } else if (node.type === \"IfStatement\") {\n                    if (!this.state.mode_) {\n                        this.instructionStack.push(node);\n                        break seek;\n                    } else if (this.state.mode_ === 1) {\n                        if (!this.state.value.data) {\n                            this.instructionStack.pop();\n                        }\n                        break seek; // return If.TestInstruction\n                    } else if (this.state.mode_ === 2) {\n                        this.instructionStack.pop();\n                    }\n                } else if (node.type === \"SwitchStatement\") {\n                    if (this.state.switchValue_) {\n                        if (!this.state.isSwitch && +this.state.value === +this.state.switchValue_) {\n                            break seek; // return Switch.Found\n                        }\n                    } else if (this.state.test_) {\n                        break seek; // return Switch.TestInstruction\n                    } else {\n                        break seek;\n                    }\n                } else if (node.type === \"TryStatement\") {\n                    if (this.state.throwValue) {\n                        break seek; // return Try.CatchBlock\n                    } else if (!this.state.doneBlock_) {\n                        break seek; // return Try.TryBlock\n                    }\n                } else if (node.type === \"ConditionalExpression\") {\n                    if (!this.state.mode_) {\n                        break seek;\n                    } else if (this.state.mode_ === 1) {\n                        (<any>node).test_ = this.state.value.data;\n                        this.instructionStack.push(node);\n                        break seek; // return Elvis.TestInstruction\n                    } else if (this.state.mode_ === 2) {\n                        if ((<any>this.instructionStack.pop()).test_) {\n                            break seek; // return Elvis.Consequent\n                        } else {\n                            break seek; // return Elvis.Alternate\n                        }\n                    }\n                } else if (node.type === \"SequenceExpression\") {\n                    if (!this.state.n_) {\n                        break seek;\n                    } else {\n                        break seek; // return Sequence.Element(this.state.n_)\n                    }\n                } else if (node.type === \"CallExpression\") {\n                    if (this.state.doneExec_) {\n                        this.instructionStack.pop();\n                    } else if (this.state.n_) {\n                        break seek; // return Call.Args(this.state.n_)\n                    } else if (this.state.doneCallee_) {\n                        // break seek; // return Call.Fn(String(this.state.value))\n                    } else {\n                        this.instructionStack.push(node);\n                    }\n                } else if (/(Break|Continue)Statement/.test(node.type)) {\n                    break seek;\n                } else if (/^(?!Function).*(Statement|Declaration)/.test(node.type)) {\n                    if (node === this.currentNode) {\n                        this.instructionStack.pop();\n                        break seek;\n                    } else {\n                        this.instructionStack.push(node);\n                        //break seek;\n                    }\n                } else {\n                    //console.log(\"???\", node.type)\n                }\n            }\n            return null;\n        }\n        return this.currentInstruction;\n    }\n\n};","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"js-interpreter\"] = factory();\n\telse\n\t\troot[\"js-interpreter\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 8);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/**\n * @license\n * JavaScript Interpreter\n *\n * Copyright 2013 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview Interpreting JavaScript in JavaScript.\n * @author fraser@google.com (Neil Fraser)\n */\n\n\n/**\n * Create a new interpreter.\n * @param {string|!Object} code Raw JavaScript text or AST.\n * @param {Function=} opt_initFunc Optional initialization function.  Used to\n *     define APIs.  When called it is passed the interpreter object and the\n *     global scope object.\n * @constructor\n */\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar acorn = __webpack_require__(1);\n\nvar clone = __webpack_require__(4);\n\nvar Interpreter = function Interpreter(code, opt_initFunc) {\n  if (typeof code == 'string') {\n    code = acorn.parse(code, Interpreter.PARSE_OPTIONS);\n  }\n  this.ast = code;\n  this.initFunc_ = opt_initFunc;\n  this.paused_ = false;\n  this.polyfills_ = [];\n  // Predefine some common primitives for performance.\n  this.UNDEFINED = new Interpreter.Primitive(undefined, this);\n  this.NULL = new Interpreter.Primitive(null, this);\n  this.NAN = new Interpreter.Primitive(NaN, this);\n  this.TRUE = new Interpreter.Primitive(true, this);\n  this.FALSE = new Interpreter.Primitive(false, this);\n  this.NUMBER_ZERO = new Interpreter.Primitive(0, this);\n  this.NUMBER_ONE = new Interpreter.Primitive(1, this);\n  this.STRING_EMPTY = new Interpreter.Primitive('', this);\n  // Create and initialize the global scope.\n  this.global = this.createScope(this.ast, null);\n  // Fix the parent properties now that the global scope exists.\n  //this.UNDEFINED.parent = undefined;\n  //this.NULL.parent = undefined;\n  this.NAN.parent = this.NUMBER;\n  this.TRUE.parent = this.BOOLEAN;\n  this.FALSE.parent = this.BOOLEAN;\n  this.NUMBER_ZERO.parent = this.NUMBER;\n  this.NUMBER_ONE.parent = this.NUMBER;\n  this.STRING_EMPTY.parent = this.STRING;\n  // Run the polyfills.\n  this.ast = acorn.parse(this.polyfills_.join('\\n'), Interpreter.PARSE_OPTIONS);\n  this.polyfills_ = undefined; // Allow polyfill strings to garbage collect.\n  this.stripLocations_(this.ast, undefined, undefined);\n  this.stateStack = [{\n    node: this.ast,\n    scope: this.global,\n    thisExpression: this.global,\n    done: false\n  }];\n  this.run();\n  this.value = this.UNDEFINED;\n  // Point at the main program.\n  this.ast = code;\n  this.stateStack = [{\n    node: this.ast,\n    scope: this.global,\n    thisExpression: this.global,\n    done: false\n  }];\n};\n\n/**\n * @const {!Object} Configuration used for all Acorn parsing.\n */\nInterpreter.PARSE_OPTIONS = {\n  ecmaVersion: 5\n};\n\n/**\n * Property descriptor of readonly properties.\n */\nInterpreter.READONLY_DESCRIPTOR = {\n  configurable: true,\n  enumerable: true,\n  writable: false\n};\n\n/**\n * Property descriptor of non-enumerable properties.\n */\nInterpreter.NONENUMERABLE_DESCRIPTOR = {\n  configurable: true,\n  enumerable: false,\n  writable: true\n};\n\n/**\n * Property descriptor of readonly, non-enumerable properties.\n */\nInterpreter.READONLY_NONENUMERABLE_DESCRIPTOR = {\n  configurable: true,\n  enumerable: false,\n  writable: false\n};\n\n/**\n * Add more code to the interpreter.\n * @param {string|!Object} code Raw JavaScript text or AST.\n */\nInterpreter.prototype.appendCode = function (code) {\n  var state = this.stateStack[0];\n  if (!state || state.node.type != 'Program') {\n    throw Error('Expecting original AST to start with a Program node.');\n  }\n  if (typeof code == 'string') {\n    code = acorn.parse(code, Interpreter.PARSE_OPTIONS);\n  }\n  if (!code || code.type != 'Program') {\n    throw Error('Expecting new AST to start with a Program node.');\n  }\n  this.populateScope_(code, state.scope);\n  // Append the new program to the old one.\n  for (var i = 0, node; node = code.body[i]; i++) {\n    state.node.body.push(node);\n  }\n  state.done = false;\n};\n\n/**\n * Execute one step of the interpreter.\n * @return {boolean} True if a step was executed, false if no more instructions.\n */\nInterpreter.prototype.step = function () {\n  var state = this.stateStack[this.stateStack.length - 1];\n  if (!state || state.node.type == 'Program' && state.done) {\n    return false;\n  } else if (this.paused_) {\n    return true;\n  }\n  this['step' + state.node.type]();\n  if (!state.node.end) {\n    // This is polyfill code.  Keep executing until we arrive at user code.\n    return this.step();\n  }\n  return true;\n};\n\n/**\n * Execute the interpreter to program completion.  Vulnerable to infinite loops.\n * @return {boolean} True if a execution is asynchronously blocked,\n *     false if no more instructions.\n */\nInterpreter.prototype.run = function () {\n  while (!this.paused_ && this.step()) {}\n  return this.paused_;\n};\n\n/**\n * Initialize the global scope with buitin properties and functions.\n * @param {!Interpreter.Object} scope Global scope.\n */\nInterpreter.prototype.initGlobalScope = function (scope) {\n  // Initialize uneditable global properties.\n  this.setProperty(scope, 'Infinity', this.createPrimitive(Infinity), Interpreter.READONLY_DESCRIPTOR);\n  this.setProperty(scope, 'NaN', this.NAN, Interpreter.READONLY_DESCRIPTOR);\n  this.setProperty(scope, 'undefined', this.UNDEFINED, Interpreter.READONLY_DESCRIPTOR);\n  this.setProperty(scope, 'window', scope, Interpreter.READONLY_DESCRIPTOR);\n  this.setProperty(scope, 'self', scope); // Editable.\n\n  // Initialize global objects.\n  this.initFunction(scope);\n  this.initObject(scope);\n  // Unable to set scope's parent prior (this.OBJECT did not exist).\n  scope.parent = this.OBJECT;\n  this.initArray(scope);\n  this.initNumber(scope);\n  this.initString(scope);\n  this.initBoolean(scope);\n  this.initDate(scope);\n  this.initMath(scope);\n  this.initRegExp(scope);\n  this.initJSON(scope);\n  this.initError(scope);\n\n  // Initialize global functions.\n  var thisInterpreter = this;\n  var wrapper;\n  wrapper = function wrapper(num) {\n    num = num || thisInterpreter.UNDEFINED;\n    return thisInterpreter.createPrimitive(isNaN(num.toNumber()));\n  };\n  this.setProperty(scope, 'isNaN', this.createNativeFunction(wrapper));\n\n  wrapper = function wrapper(num) {\n    num = num || thisInterpreter.UNDEFINED;\n    return thisInterpreter.createPrimitive(isFinite(num.toNumber()));\n  };\n  this.setProperty(scope, 'isFinite', this.createNativeFunction(wrapper));\n\n  this.setProperty(scope, 'parseFloat', this.getProperty(this.NUMBER, 'parseFloat'));\n\n  this.setProperty(scope, 'parseInt', this.getProperty(this.NUMBER, 'parseInt'));\n\n  var func = this.createObject(this.FUNCTION);\n  func.eval = true;\n  this.setProperty(func, 'length', this.NUMBER_ONE, Interpreter.READONLY_DESCRIPTOR);\n  this.setProperty(scope, 'eval', func);\n\n  var strFunctions = [[escape, 'escape'], [unescape, 'unescape'], [decodeURI, 'decodeURI'], [decodeURIComponent, 'decodeURIComponent'], [encodeURI, 'encodeURI'], [encodeURIComponent, 'encodeURIComponent']];\n  for (var i = 0; i < strFunctions.length; i++) {\n    wrapper = function (nativeFunc) {\n      return function (str) {\n        str = (str || thisInterpreter.UNDEFINED).toString();\n        try {\n          str = nativeFunc(str);\n        } catch (e) {\n          // decodeURI('%xy') will throw an error.  Catch and rethrow.\n          thisInterpreter.throwException(thisInterpreter.URI_ERROR, e.message);\n        }\n        return thisInterpreter.createPrimitive(str);\n      };\n    }(strFunctions[i][0]);\n    this.setProperty(scope, strFunctions[i][1], this.createNativeFunction(wrapper));\n  }\n\n  // Run any user-provided initialization.\n  if (this.initFunc_) {\n    this.initFunc_(this, scope);\n  }\n};\n\n/**\n * Initialize the Function class.\n * @param {!Interpreter.Object} scope Global scope.\n */\nInterpreter.prototype.initFunction = function (scope) {\n  var thisInterpreter = this;\n  var wrapper;\n  var identifierRegexp = /^[A-Za-z_$][\\w$]*$/;\n  // Function constructor.\n  wrapper = function wrapper(var_args) {\n    if (this.parent == thisInterpreter.FUNCTION) {\n      // Called with new.\n      var newFunc = this;\n    } else {\n      var newFunc = thisInterpreter.createObject(thisInterpreter.FUNCTION);\n    }\n    if (arguments.length) {\n      var code = arguments[arguments.length - 1].toString();\n    } else {\n      var code = '';\n    }\n    var args = [];\n    for (var i = 0; i < arguments.length - 1; i++) {\n      var name = arguments[i].toString();\n      if (!name.match(identifierRegexp)) {\n        thisInterpreter.throwException(thisInterpreter.SYNTAX_ERROR, 'Invalid function argument: ' + name);\n        return;\n      }\n      args.push(name);\n    }\n    args = args.join(', ');\n    // Interestingly, the scope for constructed functions is the global scope,\n    // even if they were constructed in some other scope.\n    newFunc.parentScope = thisInterpreter.stateStack[0].scope;\n    // Acorn needs to parse code in the context of a function or else 'return'\n    // statements will be syntax errors.\n    var ast = acorn.parse('$ = function(' + args + ') {' + code + '};', Interpreter.PARSE_OPTIONS);\n    if (ast.body.length != 1) {\n      // Function('a', 'return a + 6;}; {alert(1);');\n      thisInterpreter.throwException(thisInterpreter.SYNTAX_ERROR, 'Invalid code in function body.');\n      return;\n    }\n    newFunc.node = ast.body[0].expression.right;\n    thisInterpreter.setProperty(newFunc, 'length', thisInterpreter.createPrimitive(newFunc.node.length), Interpreter.READONLY_DESCRIPTOR);\n    return newFunc;\n  };\n  this.FUNCTION = this.createObject(null);\n  this.setProperty(scope, 'Function', this.FUNCTION);\n  // Manually setup type and prototype because createObj doesn't recognize\n  // this object as a function (this.FUNCTION did not exist).\n  this.FUNCTION.type = 'function';\n  this.setProperty(this.FUNCTION, 'prototype', this.createObject(null));\n  this.FUNCTION.nativeFunc = wrapper;\n\n  var boxThis = function boxThis(value) {\n    // In non-strict mode 'this' must be an object.\n    if (value.isPrimitive && !thisInterpreter.getScope().strict) {\n      if (value == thisInterpreter.UNDEFINED || value == thisInterpreter.NULL) {\n        // 'Undefined' and 'null' are changed to global object.\n        value = thisInterpreter.global;\n      } else {\n        // Primitives must be boxed in non-strict mode.\n        var box = thisInterpreter.createObject(value.parent);\n        box.data = value.data;\n        value = box;\n      }\n    }\n    return value;\n  };\n\n  wrapper = function wrapper(thisArg, args) {\n    var state = thisInterpreter.stateStack[thisInterpreter.stateStack.length - 1];\n    // Rewrite the current 'CallExpression' to apply a different function.\n    state.func_ = this;\n    // Assign the 'this' object.\n    state.funcThis_ = boxThis(thisArg);\n    // Bind any provided arguments.\n    state.arguments_ = [];\n    if (args) {\n      if (thisInterpreter.isa(args, thisInterpreter.ARRAY)) {\n        for (var i = 0; i < args.length; i++) {\n          state.arguments_[i] = thisInterpreter.getProperty(args, i);\n        }\n      } else {\n        thisInterpreter.throwException(thisInterpreter.TYPE_ERROR, 'CreateListFromArrayLike called on non-object');\n      }\n    }\n    state.doneArgs_ = true;\n    state.doneExec_ = false;\n  };\n  this.setNativeFunctionPrototype(this.FUNCTION, 'apply', wrapper);\n\n  wrapper = function wrapper(thisArg, var_args) {\n    var state = thisInterpreter.stateStack[thisInterpreter.stateStack.length - 1];\n    // Rewrite the current 'CallExpression' to call a different function.\n    state.func_ = this;\n    // Assign the 'this' object.\n    state.funcThis_ = boxThis(thisArg);\n    // Bind any provided arguments.\n    state.arguments_ = [];\n    for (var i = 1; i < arguments.length; i++) {\n      state.arguments_.push(arguments[i]);\n    }\n    state.doneArgs_ = true;\n    state.doneExec_ = false;\n  };\n  this.setNativeFunctionPrototype(this.FUNCTION, 'call', wrapper);\n\n  this.polyfills_.push(\n  // Polyfill copied from:\n  // https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind\n  \"Object.defineProperty(Function.prototype, 'bind', {configurable: true, value:\", \"function(oThis) {\", \"if (typeof this !== 'function') {\", \"throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');\", \"}\", \"var aArgs   = Array.prototype.slice.call(arguments, 1),\", \"fToBind = this,\", \"fNOP    = function() {},\", \"fBound  = function() {\", \"return fToBind.apply(this instanceof fNOP\", \"? this\", \": oThis,\", \"aArgs.concat(Array.prototype.slice.call(arguments)));\", \"};\", \"if (this.prototype) {\", \"fNOP.prototype = this.prototype;\", \"}\", \"fBound.prototype = new fNOP();\", \"return fBound;\", \"}\", \"});\", \"\");\n\n  // Function has no parent to inherit from, so it needs its own mandatory\n  // toString and valueOf functions.\n  wrapper = function wrapper() {\n    return thisInterpreter.createPrimitive(this.toString());\n  };\n  this.setNativeFunctionPrototype(this.FUNCTION, 'toString', wrapper);\n  this.setProperty(this.FUNCTION, 'toString', this.createNativeFunction(wrapper), Interpreter.NONENUMERABLE_DESCRIPTOR);\n  wrapper = function wrapper() {\n    return thisInterpreter.createPrimitive(this.valueOf());\n  };\n  this.setNativeFunctionPrototype(this.FUNCTION, 'valueOf', wrapper);\n  this.setProperty(this.FUNCTION, 'valueOf', this.createNativeFunction(wrapper), Interpreter.NONENUMERABLE_DESCRIPTOR);\n};\n\n/**\n * Initialize the Object class.\n * @param {!Interpreter.Object} scope Global scope.\n */\nInterpreter.prototype.initObject = function (scope) {\n  var thisInterpreter = this;\n  var wrapper;\n  // Object constructor.\n  wrapper = function wrapper(value) {\n    if (!value || value == thisInterpreter.UNDEFINED || value == thisInterpreter.NULL) {\n      // Create a new object.\n      if (this.parent == thisInterpreter.OBJECT) {\n        // Called with new.\n        return this;\n      } else {\n        return thisInterpreter.createObject(thisInterpreter.OBJECT);\n      }\n    }\n    if (value.isPrimitive) {\n      // Wrap the value as an object.\n      var obj = thisInterpreter.createObject(value.parent);\n      obj.data = value.data;\n      return obj;\n    }\n    // Return the provided object.\n    return value;\n  };\n  this.OBJECT = this.createNativeFunction(wrapper);\n  this.setProperty(scope, 'Object', this.OBJECT);\n\n  // Static methods on Object.\n  wrapper = function wrapper(obj) {\n    var pseudoList = thisInterpreter.createObject(thisInterpreter.ARRAY);\n    var i = 0;\n    for (var key in obj.properties) {\n      thisInterpreter.setProperty(pseudoList, i, thisInterpreter.createPrimitive(key));\n      i++;\n    }\n    return pseudoList;\n  };\n  this.setProperty(this.OBJECT, 'getOwnPropertyNames', this.createNativeFunction(wrapper), Interpreter.NONENUMERABLE_DESCRIPTOR);\n\n  wrapper = function wrapper(obj) {\n    var pseudoList = thisInterpreter.createObject(thisInterpreter.ARRAY);\n    var i = 0;\n    for (var key in obj.properties) {\n      if (obj.notEnumerable[key]) {\n        continue;\n      }\n      thisInterpreter.setProperty(pseudoList, i, thisInterpreter.createPrimitive(key));\n      i++;\n    }\n    return pseudoList;\n  };\n  this.setProperty(this.OBJECT, 'keys', this.createNativeFunction(wrapper), Interpreter.NONENUMERABLE_DESCRIPTOR);\n\n  wrapper = function wrapper(obj, prop, descriptor) {\n    prop = (prop || thisInterpreter.UNDEFINED).toString();\n    if (!(descriptor instanceof Interpreter.Object)) {\n      thisInterpreter.throwException(thisInterpreter.TYPE_ERROR, 'Property description must be an object.');\n      return;\n    }\n    if (!obj.properties[prop] && obj.preventExtensions) {\n      thisInterpreter.throwException(thisInterpreter.TYPE_ERROR, 'Can\\'t define property ' + prop + ', object is not extensible');\n      return;\n    }\n    var value = thisInterpreter.getProperty(descriptor, 'value');\n    if (value == thisInterpreter.UNDEFINED) {\n      value = null;\n    }\n    var get = thisInterpreter.getProperty(descriptor, 'get');\n    var set = thisInterpreter.getProperty(descriptor, 'set');\n    var nativeDescriptor = {\n      configurable: thisInterpreter.pseudoToNative(\n      /** @type !Interpreter.Primitive */\n      thisInterpreter.getProperty(descriptor, 'configurable')),\n      enumerable: thisInterpreter.pseudoToNative(\n      /** @type !Interpreter.Primitive */\n      thisInterpreter.getProperty(descriptor, 'enumerable')),\n      writable: thisInterpreter.pseudoToNative(\n      /** @type !Interpreter.Primitive */\n      thisInterpreter.getProperty(descriptor, 'writable')),\n      get: get == thisInterpreter.UNDEFINED ? undefined : get,\n      set: set == thisInterpreter.UNDEFINED ? undefined : set\n    };\n    thisInterpreter.setProperty(obj, prop, value, nativeDescriptor);\n    return obj;\n  };\n  this.setProperty(this.OBJECT, 'defineProperty', this.createNativeFunction(wrapper), Interpreter.NONENUMERABLE_DESCRIPTOR);\n\n  this.polyfills_.push(\"Object.defineProperty(Object.prototype, 'defineProperties', {configurable: true, value:\", \"function(obj, props) {\", \"var keys = Object.keys(props);\", \"for (var i = 0; i < keys.length; i++) {\", \"Object.defineProperty(obj, keys[i], props[keys[i]]);\", \"}\", \"return obj;\", \"}\", \"});\", \"\");\n\n  wrapper = function wrapper(obj, prop) {\n    prop = (prop || thisInterpreter.UNDEFINED).toString();\n    if (!(prop in obj.properties)) {\n      return thisInterpreter.UNDEFINED;\n    }\n    var configurable = !obj.notConfigurable[prop];\n    var enumerable = !obj.notEnumerable[prop];\n    var writable = !obj.notWritable[prop];\n    var getter = obj.getter[prop];\n    var setter = obj.setter[prop];\n\n    var descriptor = thisInterpreter.createObject(thisInterpreter.OBJECT);\n    thisInterpreter.setProperty(descriptor, 'configurable', thisInterpreter.createPrimitive(configurable));\n    thisInterpreter.setProperty(descriptor, 'enumerable', thisInterpreter.createPrimitive(enumerable));\n    if (getter || setter) {\n      thisInterpreter.setProperty(descriptor, 'getter', getter);\n      thisInterpreter.setProperty(descriptor, 'setter', setter);\n    } else {\n      thisInterpreter.setProperty(descriptor, 'writable', thisInterpreter.createPrimitive(writable));\n      thisInterpreter.setProperty(descriptor, 'value', thisInterpreter.getProperty(obj, prop));\n    }\n    return descriptor;\n  };\n  this.setProperty(this.OBJECT, 'getOwnPropertyDescriptor', this.createNativeFunction(wrapper), Interpreter.NONENUMERABLE_DESCRIPTOR);\n\n  wrapper = function wrapper(obj) {\n    if (obj.parent && obj.parent.properties && obj.parent.properties.prototype) {\n      return obj.parent.properties.prototype;\n    }\n    return thisInterpreter.NULL;\n  };\n  this.setProperty(this.OBJECT, 'getPrototypeOf', this.createNativeFunction(wrapper), Interpreter.NONENUMERABLE_DESCRIPTOR);\n\n  wrapper = function wrapper(obj) {\n    return thisInterpreter.createPrimitive(!obj.preventExtensions);\n  };\n  this.setProperty(this.OBJECT, 'isExtensible', this.createNativeFunction(wrapper), Interpreter.NONENUMERABLE_DESCRIPTOR);\n\n  wrapper = function wrapper(obj) {\n    if (!obj.isPrimitive) {\n      obj.preventExtensions = true;\n    }\n    return obj;\n  };\n  this.setProperty(this.OBJECT, 'preventExtensions', this.createNativeFunction(wrapper), Interpreter.NONENUMERABLE_DESCRIPTOR);\n\n  // Instance methods on Object.\n  wrapper = function wrapper() {\n    return thisInterpreter.createPrimitive(this.toString());\n  };\n  this.setNativeFunctionPrototype(this.OBJECT, 'toString', wrapper);\n\n  wrapper = function wrapper() {\n    return thisInterpreter.createPrimitive(this.toString());\n  };\n  this.setNativeFunctionPrototype(this.OBJECT, 'toLocaleString', wrapper);\n\n  wrapper = function wrapper() {\n    return thisInterpreter.createPrimitive(this.valueOf());\n  };\n  this.setNativeFunctionPrototype(this.OBJECT, 'valueOf', wrapper);\n\n  wrapper = function wrapper(prop) {\n    if (this == thisInterpreter.NULL || this == thisInterpreter.UNDEFINED) {\n      thisInterpreter.throwException(thisInterpreter.TYPE_ERROR, 'Cannot convert undefined or null to object');\n      return;\n    }\n    prop = (prop || thisInterpreter.UNDEFINED).toString();\n    return prop in this.properties ? thisInterpreter.TRUE : thisInterpreter.FALSE;\n  };\n  this.setNativeFunctionPrototype(this.OBJECT, 'hasOwnProperty', wrapper);\n\n  wrapper = function wrapper(prop) {\n    prop = (prop || thisInterpreter.UNDEFINED).toString();\n    var enumerable = prop in this.properties && !this.notEnumerable[prop];\n    return thisInterpreter.createPrimitive(enumerable);\n  };\n  this.setNativeFunctionPrototype(this.OBJECT, 'propertyIsEnumerable', wrapper);\n\n  wrapper = function wrapper(obj) {\n    while (true) {\n      if (obj.parent && obj.parent.properties && obj.parent.properties.prototype) {\n        obj = obj.parent.properties.prototype;\n        if (obj == this) {\n          return thisInterpreter.createPrimitive(true);\n        }\n      } else {\n        // No parent, reached the top.\n        return thisInterpreter.createPrimitive(false);\n      }\n    }\n  };\n  this.setNativeFunctionPrototype(this.OBJECT, 'isPrototypeOf', wrapper);\n};\n\n/**\n * Initialize the Array class.\n * @param {!Interpreter.Object} scope Global scope.\n */\nInterpreter.prototype.initArray = function (scope) {\n  var thisInterpreter = this;\n  var getInt = function getInt(obj, def) {\n    // Return an integer, or the default.\n    var n = obj ? Math.floor(obj.toNumber()) : def;\n    if (isNaN(n)) {\n      n = def;\n    }\n    return n;\n  };\n  var strictComp = function strictComp(a, b) {\n    // Strict === comparison.\n    if (a.isPrimitive && b.isPrimitive) {\n      return a.data === b.data;\n    }\n    return a === b;\n  };\n  var wrapper;\n  // Array constructor.\n  wrapper = function wrapper(var_args) {\n    if (this.parent == thisInterpreter.ARRAY) {\n      // Called with new.\n      var newArray = this;\n    } else {\n      var newArray = thisInterpreter.createObject(thisInterpreter.ARRAY);\n    }\n    var first = arguments[0];\n    if (arguments.length == 1 && first.type == 'number') {\n      if (isNaN(thisInterpreter.arrayIndex(first))) {\n        thisInterpreter.throwException(thisInterpreter.RANGE_ERROR, 'Invalid array length');\n      }\n      newArray.length = first.data;\n    } else {\n      for (var i = 0; i < arguments.length; i++) {\n        newArray.properties[i] = arguments[i];\n      }\n      newArray.length = i;\n    }\n    return newArray;\n  };\n  this.ARRAY = this.createNativeFunction(wrapper);\n  this.setProperty(scope, 'Array', this.ARRAY);\n\n  // Static methods on Array.\n  wrapper = function wrapper(obj) {\n    return thisInterpreter.createPrimitive(thisInterpreter.isa(obj, thisInterpreter.ARRAY));\n  };\n  this.setProperty(this.ARRAY, 'isArray', this.createNativeFunction(wrapper), Interpreter.NONENUMERABLE_DESCRIPTOR);\n\n  // Instance methods on Array.\n  wrapper = function wrapper() {\n    if (this.length) {\n      var value = this.properties[this.length - 1];\n      delete this.properties[this.length - 1];\n      this.length--;\n    } else {\n      var value = thisInterpreter.UNDEFINED;\n    }\n    return value;\n  };\n  this.setNativeFunctionPrototype(this.ARRAY, 'pop', wrapper);\n\n  wrapper = function wrapper(var_args) {\n    for (var i = 0; i < arguments.length; i++) {\n      this.properties[this.length] = arguments[i];\n      this.length++;\n    }\n    return thisInterpreter.createPrimitive(this.length);\n  };\n  this.setNativeFunctionPrototype(this.ARRAY, 'push', wrapper);\n\n  wrapper = function wrapper() {\n    if (this.length) {\n      var value = this.properties[0];\n      for (var i = 1; i < this.length; i++) {\n        this.properties[i - 1] = this.properties[i];\n      }\n      this.length--;\n      delete this.properties[this.length];\n    } else {\n      var value = thisInterpreter.UNDEFINED;\n    }\n    return value;\n  };\n  this.setNativeFunctionPrototype(this.ARRAY, 'shift', wrapper);\n\n  wrapper = function wrapper(var_args) {\n    for (var i = this.length - 1; i >= 0; i--) {\n      this.properties[i + arguments.length] = this.properties[i];\n    }\n    this.length += arguments.length;\n    for (var i = 0; i < arguments.length; i++) {\n      this.properties[i] = arguments[i];\n    }\n    return thisInterpreter.createPrimitive(this.length);\n  };\n  this.setNativeFunctionPrototype(this.ARRAY, 'unshift', wrapper);\n\n  wrapper = function wrapper() {\n    for (var i = 0; i < this.length / 2; i++) {\n      var tmp = this.properties[this.length - i - 1];\n      this.properties[this.length - i - 1] = this.properties[i];\n      this.properties[i] = tmp;\n    }\n    return this;\n  };\n  this.setNativeFunctionPrototype(this.ARRAY, 'reverse', wrapper);\n\n  wrapper = function wrapper(index, howmany, var_args) {\n    index = getInt(index, 0);\n    if (index < 0) {\n      index = Math.max(this.length + index, 0);\n    } else {\n      index = Math.min(index, this.length);\n    }\n    howmany = getInt(howmany, Infinity);\n    howmany = Math.min(howmany, this.length - index);\n    var removed = thisInterpreter.createObject(thisInterpreter.ARRAY);\n    // Remove specified elements.\n    for (var i = index; i < index + howmany; i++) {\n      removed.properties[removed.length++] = this.properties[i];\n      this.properties[i] = this.properties[i + howmany];\n    }\n    // Move other element to fill the gap.\n    for (var i = index + howmany; i < this.length - howmany; i++) {\n      this.properties[i] = this.properties[i + howmany];\n    }\n    // Delete superfluous properties.\n    for (var i = this.length - howmany; i < this.length; i++) {\n      delete this.properties[i];\n    }\n    this.length -= howmany;\n    // Insert specified items.\n    for (var i = this.length - 1; i >= index; i--) {\n      this.properties[i + arguments.length - 2] = this.properties[i];\n    }\n    this.length += arguments.length - 2;\n    for (var i = 2; i < arguments.length; i++) {\n      this.properties[index + i - 2] = arguments[i];\n    }\n    return removed;\n  };\n  this.setNativeFunctionPrototype(this.ARRAY, 'splice', wrapper);\n\n  wrapper = function wrapper(opt_begin, opt_end) {\n    var list = thisInterpreter.createObject(thisInterpreter.ARRAY);\n    var begin = getInt(opt_begin, 0);\n    if (begin < 0) {\n      begin = this.length + begin;\n    }\n    begin = Math.max(0, Math.min(begin, this.length));\n    var end = getInt(opt_end, this.length);\n    if (end < 0) {\n      end = this.length + end;\n    }\n    end = Math.max(0, Math.min(end, this.length));\n    var length = 0;\n    for (var i = begin; i < end; i++) {\n      var element = thisInterpreter.getProperty(this, i);\n      thisInterpreter.setProperty(list, length++, element);\n    }\n    return list;\n  };\n  this.setNativeFunctionPrototype(this.ARRAY, 'slice', wrapper);\n\n  wrapper = function wrapper(opt_separator) {\n    if (!opt_separator || opt_separator.data === undefined) {\n      var sep = undefined;\n    } else {\n      var sep = opt_separator.toString();\n    }\n    var text = [];\n    for (var i = 0; i < this.length; i++) {\n      text[i] = this.properties[i];\n    }\n    return thisInterpreter.createPrimitive(text.join(sep));\n  };\n  this.setNativeFunctionPrototype(this.ARRAY, 'join', wrapper);\n\n  wrapper = function wrapper(var_args) {\n    var list = thisInterpreter.createObject(thisInterpreter.ARRAY);\n    var length = 0;\n    // Start by copying the current array.\n    for (var i = 0; i < this.length; i++) {\n      var element = thisInterpreter.getProperty(this, i);\n      thisInterpreter.setProperty(list, length++, element);\n    }\n    // Loop through all arguments and copy them in.\n    for (var i = 0; i < arguments.length; i++) {\n      var value = arguments[i];\n      if (thisInterpreter.isa(value, thisInterpreter.ARRAY)) {\n        for (var j = 0; j < value.length; j++) {\n          var element = thisInterpreter.getProperty(value, j);\n          thisInterpreter.setProperty(list, length++, element);\n        }\n      } else {\n        thisInterpreter.setProperty(list, length++, value);\n      }\n    }\n    return list;\n  };\n  this.setNativeFunctionPrototype(this.ARRAY, 'concat', wrapper);\n\n  wrapper = function wrapper(searchElement, opt_fromIndex) {\n    searchElement = searchElement || thisInterpreter.UNDEFINED;\n    var fromIndex = getInt(opt_fromIndex, 0);\n    if (fromIndex < 0) {\n      fromIndex = this.length + fromIndex;\n    }\n    fromIndex = Math.max(0, fromIndex);\n    for (var i = fromIndex; i < this.length; i++) {\n      var element = thisInterpreter.getProperty(this, i);\n      if (strictComp(element, searchElement)) {\n        return thisInterpreter.createPrimitive(i);\n      }\n    }\n    return thisInterpreter.createPrimitive(-1);\n  };\n  this.setNativeFunctionPrototype(this.ARRAY, 'indexOf', wrapper);\n\n  wrapper = function wrapper(searchElement, opt_fromIndex) {\n    searchElement = searchElement || thisInterpreter.UNDEFINED;\n    var fromIndex = getInt(opt_fromIndex, this.length);\n    if (fromIndex < 0) {\n      fromIndex = this.length + fromIndex;\n    }\n    fromIndex = Math.min(fromIndex, this.length - 1);\n    for (var i = fromIndex; i >= 0; i--) {\n      var element = thisInterpreter.getProperty(this, i);\n      if (strictComp(element, searchElement)) {\n        return thisInterpreter.createPrimitive(i);\n      }\n    }\n    return thisInterpreter.createPrimitive(-1);\n  };\n  this.setNativeFunctionPrototype(this.ARRAY, 'lastIndexOf', wrapper);\n\n  this.polyfills_.push(\n  // Polyfill copied from:\n  // developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/every\n  \"Object.defineProperty(Array.prototype, 'every', {configurable: true, value:\", \"function(callbackfn, thisArg) {\", \"if (this == null || typeof callbackfn !== 'function') throw new TypeError;\", \"var T, k;\", \"var O = Object(this);\", \"var len = O.length >>> 0;\", \"if (arguments.length > 1) T = thisArg;\", \"k = 0;\", \"while (k < len) {\", \"if (k in O && !callbackfn.call(T, O[k], k, O)) return false;\", \"k++;\", \"}\", \"return true;\", \"}\", \"});\",\n\n  // Polyfill copied from:\n  // developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/filter\n  \"Object.defineProperty(Array.prototype, 'filter', {configurable: true, value:\", \"function(fun/*, thisArg*/) {\", \"if (this === void 0 || this === null || typeof fun !== 'function') throw new TypeError;\", \"var t = Object(this);\", \"var len = t.length >>> 0;\", \"var res = [];\", \"var thisArg = arguments.length >= 2 ? arguments[1] : void 0;\", \"for (var i = 0; i < len; i++) {\", \"if (i in t) {\", \"var val = t[i];\", \"if (fun.call(thisArg, val, i, t)) res.push(val);\", \"}\", \"}\", \"return res;\", \"}\", \"});\",\n\n  // Polyfill copied from:\n  // developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach\n  \"Object.defineProperty(Array.prototype, 'forEach', {configurable: true, value:\", \"function(callback, thisArg) {\", \"if (this == null || typeof callback !== 'function') throw new TypeError;\", \"var T, k;\", \"var O = Object(this);\", \"var len = O.length >>> 0;\", \"if (arguments.length > 1) T = thisArg;\", \"k = 0;\", \"while (k < len) {\", \"if (k in O) callback.call(T, O[k], k, O);\", \"k++;\", \"}\", \"}\", \"});\",\n\n  // Polyfill copied from:\n  // developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/map\n  \"Object.defineProperty(Array.prototype, 'map', {configurable: true, value:\", \"function(callback, thisArg) {\", \"if (this == null || typeof callback !== 'function') new TypeError;\", \"var T, A, k;\", \"var O = Object(this);\", \"var len = O.length >>> 0;\", \"if (arguments.length > 1) T = thisArg;\", \"A = new Array(len);\", \"k = 0;\", \"while (k < len) {\", \"if (k in O) A[k] = callback.call(T, O[k], k, O);\", \"k++;\", \"}\", \"return A;\", \"}\", \"});\",\n\n  // Polyfill copied from:\n  // developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce\n  \"Object.defineProperty(Array.prototype, 'reduce', {configurable: true, value:\", \"function(callback /*, initialValue*/) {\", \"if (this == null || typeof callback !== 'function') throw new TypeError;\", \"var t = Object(this), len = t.length >>> 0, k = 0, value;\", \"if (arguments.length == 2) {\", \"value = arguments[1];\", \"} else {\", \"while (k < len && !(k in t)) k++;\", \"if (k >= len) {\", \"throw new TypeError('Reduce of empty array with no initial value');\", \"}\", \"value = t[k++];\", \"}\", \"for (; k < len; k++) {\", \"if (k in t) value = callback(value, t[k], k, t);\", \"}\", \"return value;\", \"}\", \"});\",\n\n  // Polyfill copied from:\n  // developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/ReduceRight\n  \"Object.defineProperty(Array.prototype, 'reduceRight', {configurable: true, value:\", \"function(callback /*, initialValue*/) {\", \"if (null === this || 'undefined' === typeof this || 'function' !== typeof callback) throw new TypeError;\", \"var t = Object(this), len = t.length >>> 0, k = len - 1, value;\", \"if (arguments.length >= 2) {\", \"value = arguments[1];\", \"} else {\", \"while (k >= 0 && !(k in t)) k--;\", \"if (k < 0) {\", \"throw new TypeError('Reduce of empty array with no initial value');\", \"}\", \"value = t[k--];\", \"}\", \"for (; k >= 0; k--) {\", \"if (k in t) value = callback(value, t[k], k, t);\", \"}\", \"return value;\", \"}\", \"});\",\n\n  // Polyfill copied from:\n  // developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Array/some\n  \"Object.defineProperty(Array.prototype, 'some', {configurable: true, value:\", \"function(fun/*, thisArg*/) {\", \"if (this == null || typeof fun !== 'function') throw new TypeError;\", \"var t = Object(this);\", \"var len = t.length >>> 0;\", \"var thisArg = arguments.length >= 2 ? arguments[1] : void 0;\", \"for (var i = 0; i < len; i++) {\", \"if (i in t && fun.call(thisArg, t[i], i, t)) {\", \"return true;\", \"}\", \"}\", \"return false;\", \"}\", \"});\", \"Object.defineProperty(Array.prototype, 'sort', {configurable: true, value:\", \"function(opt_comp) {\", \"for (var i = 0; i < this.length; i++) {\", \"var changes = 0;\", \"for (var j = 0; j < this.length - i - 1; j++) {\", \"if (opt_comp ?\" + \"opt_comp(this[j], this[j + 1]) > 0 : this[j] > this[j + 1]) {\", \"var swap = this[j];\", \"this[j] = this[j + 1];\", \"this[j + 1] = swap;\", \"changes++;\", \"}\", \"}\", \"if (changes <= 1) break;\", \"}\", \"return this;\", \"}\", \"});\", \"Object.defineProperty(Array.prototype, 'toLocaleString', {configurable: true, value:\", \"function() {\", \"var out = [];\", \"for (var i = 0; i < this.length; i++) {\", \"out[i] = (this[i] === null || this[i] === undefined) ? '' : this[i].toLocaleString();\", \"}\", \"return out.join(',');\", \"}\", \"});\", \"\");\n};\n\n/**\n * Initialize the Number class.\n * @param {!Interpreter.Object} scope Global scope.\n */\nInterpreter.prototype.initNumber = function (scope) {\n  var thisInterpreter = this;\n  var wrapper;\n  // Number constructor.\n  wrapper = function wrapper(value) {\n    value = value ? value.toNumber() : 0;\n    if (this.parent != thisInterpreter.NUMBER) {\n      // Called as Number().\n      return thisInterpreter.createPrimitive(value);\n    }\n    // Called as new Number().\n    this.data = value;\n    return this;\n  };\n  this.NUMBER = this.createNativeFunction(wrapper);\n  this.setProperty(scope, 'Number', this.NUMBER);\n\n  var numConsts = ['MAX_VALUE', 'MIN_VALUE', 'NaN', 'NEGATIVE_INFINITY', 'POSITIVE_INFINITY'];\n  for (var i = 0; i < numConsts.length; i++) {\n    this.setProperty(this.NUMBER, numConsts[i], this.createPrimitive(Number[numConsts[i]]));\n  }\n\n  // Static methods on Number.\n  wrapper = function wrapper(str) {\n    str = str || thisInterpreter.UNDEFINED;\n    return thisInterpreter.createPrimitive(parseFloat(str.toString()));\n  };\n  this.setProperty(this.NUMBER, 'parseFloat', this.createNativeFunction(wrapper));\n\n  wrapper = function wrapper(str, radix) {\n    str = str || thisInterpreter.UNDEFINED;\n    radix = radix || thisInterpreter.UNDEFINED;\n    return thisInterpreter.createPrimitive(parseInt(str.toString(), radix.toNumber()));\n  };\n  this.setProperty(this.NUMBER, 'parseInt', this.createNativeFunction(wrapper));\n\n  // Instance methods on Number.\n  wrapper = function wrapper(fractionDigits) {\n    fractionDigits = fractionDigits ? fractionDigits.toNumber() : undefined;\n    var n = this.toNumber();\n    return thisInterpreter.createPrimitive(n.toExponential(fractionDigits));\n  };\n  this.setNativeFunctionPrototype(this.NUMBER, 'toExponential', wrapper);\n\n  wrapper = function wrapper(digits) {\n    digits = digits ? digits.toNumber() : undefined;\n    var n = this.toNumber();\n    return thisInterpreter.createPrimitive(n.toFixed(digits));\n  };\n  this.setNativeFunctionPrototype(this.NUMBER, 'toFixed', wrapper);\n\n  wrapper = function wrapper(precision) {\n    precision = precision ? precision.toNumber() : undefined;\n    var n = this.toNumber();\n    return thisInterpreter.createPrimitive(n.toPrecision(precision));\n  };\n  this.setNativeFunctionPrototype(this.NUMBER, 'toPrecision', wrapper);\n\n  wrapper = function wrapper(radix) {\n    radix = radix ? radix.toNumber() : 10;\n    var n = this.toNumber();\n    return thisInterpreter.createPrimitive(n.toString(radix));\n  };\n  this.setNativeFunctionPrototype(this.NUMBER, 'toString', wrapper);\n\n  wrapper = function wrapper(locales, options) {\n    locales = locales ? thisInterpreter.pseudoToNative(locales) : undefined;\n    options = options ? thisInterpreter.pseudoToNative(options) : undefined;\n    return thisInterpreter.createPrimitive(this.toNumber().toLocaleString(locales, options));\n  };\n  this.setNativeFunctionPrototype(this.NUMBER, 'toLocaleString', wrapper);\n};\n\n/**\n * Initialize the String class.\n * @param {!Interpreter.Object} scope Global scope.\n */\nInterpreter.prototype.initString = function (scope) {\n  var thisInterpreter = this;\n  var wrapper;\n  // String constructor.\n  wrapper = function wrapper(value) {\n    value = value ? value.toString() : '';\n    if (this.parent != thisInterpreter.STRING) {\n      // Called as String().\n      return thisInterpreter.createPrimitive(value);\n    }\n    // Called as new String().\n    this.data = value;\n    return this;\n  };\n  this.STRING = this.createNativeFunction(wrapper);\n  this.setProperty(scope, 'String', this.STRING);\n\n  // Static methods on String.\n  wrapper = function wrapper(var_args) {\n    for (var i = 0; i < arguments.length; i++) {\n      arguments[i] = arguments[i].toNumber();\n    }\n    return thisInterpreter.createPrimitive(String.fromCharCode.apply(String, arguments));\n  };\n  this.setProperty(this.STRING, 'fromCharCode', this.createNativeFunction(wrapper), Interpreter.NONENUMERABLE_DESCRIPTOR);\n\n  // Instance methods on String.\n  // Methods with no arguments.\n  var functions = ['toLowerCase', 'toUpperCase', 'toLocaleLowerCase', 'toLocaleUpperCase'];\n  for (var i = 0; i < functions.length; i++) {\n    wrapper = function (nativeFunc) {\n      return function () {\n        return thisInterpreter.createPrimitive(nativeFunc.apply(this));\n      };\n    }(String.prototype[functions[i]]);\n    this.setNativeFunctionPrototype(this.STRING, functions[i], wrapper);\n  }\n\n  // Trim function may not exist in host browser.  Write them from scratch.\n  wrapper = function wrapper() {\n    var str = this.toString();\n    return thisInterpreter.createPrimitive(str.replace(/^\\s+|\\s+$/g, ''));\n  };\n  this.setNativeFunctionPrototype(this.STRING, 'trim', wrapper);\n  wrapper = function wrapper() {\n    var str = this.toString();\n    return thisInterpreter.createPrimitive(str.replace(/^\\s+/g, ''));\n  };\n  this.setNativeFunctionPrototype(this.STRING, 'trimLeft', wrapper);\n  wrapper = function wrapper() {\n    var str = this.toString();\n    return thisInterpreter.createPrimitive(str.replace(/\\s+$/g, ''));\n  };\n  this.setNativeFunctionPrototype(this.STRING, 'trimRight', wrapper);\n\n  // Methods with only numeric arguments.\n  functions = ['charAt', 'charCodeAt', 'substring', 'slice', 'substr'];\n  for (var i = 0; i < functions.length; i++) {\n    wrapper = function (nativeFunc) {\n      return function () {\n        for (var j = 0; j < arguments.length; j++) {\n          arguments[j] = arguments[j].toNumber();\n        }\n        return thisInterpreter.createPrimitive(nativeFunc.apply(this, arguments));\n      };\n    }(String.prototype[functions[i]]);\n    this.setNativeFunctionPrototype(this.STRING, functions[i], wrapper);\n  }\n\n  wrapper = function wrapper(searchValue, fromIndex) {\n    var str = this.toString();\n    searchValue = (searchValue || thisInterpreter.UNDEFINED).toString();\n    fromIndex = fromIndex ? fromIndex.toNumber() : undefined;\n    return thisInterpreter.createPrimitive(str.indexOf(searchValue, fromIndex));\n  };\n  this.setNativeFunctionPrototype(this.STRING, 'indexOf', wrapper);\n\n  wrapper = function wrapper(searchValue, fromIndex) {\n    var str = this.toString();\n    searchValue = (searchValue || thisInterpreter.UNDEFINED).toString();\n    fromIndex = fromIndex ? fromIndex.toNumber() : undefined;\n    return thisInterpreter.createPrimitive(str.lastIndexOf(searchValue, fromIndex));\n  };\n  this.setNativeFunctionPrototype(this.STRING, 'lastIndexOf', wrapper);\n\n  wrapper = function wrapper(compareString, locales, options) {\n    compareString = (compareString || thisInterpreter.UNDEFINED).toString();\n    locales = locales ? thisInterpreter.pseudoToNative(locales) : undefined;\n    options = options ? thisInterpreter.pseudoToNative(options) : undefined;\n    return thisInterpreter.createPrimitive(this.toString().localeCompare(compareString, locales, options));\n  };\n  this.setNativeFunctionPrototype(this.STRING, 'localeCompare', wrapper);\n\n  wrapper = function wrapper(separator, limit) {\n    var str = this.toString();\n    if (separator) {\n      separator = thisInterpreter.isa(separator, thisInterpreter.REGEXP) ? separator.data : separator.toString();\n    } else {\n      // is this really necessary?\n      separator = undefined;\n    }\n    limit = limit ? limit.toNumber() : undefined;\n    var jsList = str.split(separator, limit);\n    var pseudoList = thisInterpreter.createObject(thisInterpreter.ARRAY);\n    for (var i = 0; i < jsList.length; i++) {\n      thisInterpreter.setProperty(pseudoList, i, thisInterpreter.createPrimitive(jsList[i]));\n    }\n    return pseudoList;\n  };\n  this.setNativeFunctionPrototype(this.STRING, 'split', wrapper);\n\n  wrapper = function wrapper(var_args) {\n    var str = this.toString();\n    for (var i = 0; i < arguments.length; i++) {\n      str += arguments[i].toString();\n    }\n    return thisInterpreter.createPrimitive(str);\n  };\n  this.setNativeFunctionPrototype(this.STRING, 'concat', wrapper);\n\n  wrapper = function wrapper(regexp) {\n    var str = this.toString();\n    regexp = regexp ? regexp.data : undefined;\n    var match = str.match(regexp);\n    if (match === null) {\n      return thisInterpreter.NULL;\n    }\n    var pseudoList = thisInterpreter.createObject(thisInterpreter.ARRAY);\n    for (var i = 0; i < match.length; i++) {\n      thisInterpreter.setProperty(pseudoList, i, thisInterpreter.createPrimitive(match[i]));\n    }\n    return pseudoList;\n  };\n  this.setNativeFunctionPrototype(this.STRING, 'match', wrapper);\n\n  wrapper = function wrapper(regexp) {\n    var str = this.toString();\n    regexp = regexp ? regexp.data : undefined;\n    return thisInterpreter.createPrimitive(str.search(regexp));\n  };\n  this.setNativeFunctionPrototype(this.STRING, 'search', wrapper);\n\n  wrapper = function wrapper(substr, newSubStr) {\n    var str = this.toString();\n    substr = (substr || thisInterpreter.UNDEFINED).valueOf();\n    newSubStr = (newSubStr || thisInterpreter.UNDEFINED).toString();\n    return thisInterpreter.createPrimitive(str.replace(substr, newSubStr));\n  };\n  this.setNativeFunctionPrototype(this.STRING, 'replace', wrapper);\n};\n\n/**\n * Initialize the Boolean class.\n * @param {!Interpreter.Object} scope Global scope.\n */\nInterpreter.prototype.initBoolean = function (scope) {\n  var thisInterpreter = this;\n  var wrapper;\n  // Boolean constructor.\n  wrapper = function wrapper(value) {\n    value = value ? value.toBoolean() : false;\n    if (this.parent != thisInterpreter.BOOLEAN) {\n      // Called as Boolean().\n      return thisInterpreter.createPrimitive(value);\n    }\n    // Called as new Boolean().\n    this.data = value;\n    return this;\n  };\n  this.BOOLEAN = this.createNativeFunction(wrapper);\n  this.setProperty(scope, 'Boolean', this.BOOLEAN);\n};\n\n/**\n * Initialize the Date class.\n * @param {!Interpreter.Object} scope Global scope.\n */\nInterpreter.prototype.initDate = function (scope) {\n  var thisInterpreter = this;\n  var wrapper;\n  // Date constructor.\n  wrapper = function wrapper(a, b, c, d, e, f, h) {\n    if (this.parent == thisInterpreter.DATE) {\n      // Called with new.\n      var newDate = this;\n    } else {\n      // Calling Date() as a function returns a string, no arguments are heeded.\n      return thisInterpreter.createPrimitive(Date());\n    }\n    if (!arguments.length) {\n      newDate.data = new Date();\n    } else if (arguments.length == 1 && (a.type == 'string' || thisInterpreter.isa(a, thisInterpreter.STRING))) {\n      newDate.data = new Date(a.toString());\n    } else {\n      var args = [null];\n      for (var i = 0; i < arguments.length; i++) {\n        args[i + 1] = arguments[i] ? arguments[i].toNumber() : undefined;\n      }\n      newDate.data = new (Function.prototype.bind.apply(Date, args))();\n    }\n    return newDate;\n  };\n  this.DATE = this.createNativeFunction(wrapper);\n  this.setProperty(scope, 'Date', this.DATE);\n\n  // Static methods on Date.\n  wrapper = function wrapper() {\n    return thisInterpreter.createPrimitive(new Date().getTime());\n  };\n  this.setProperty(this.DATE, 'now', this.createNativeFunction(wrapper), Interpreter.NONENUMERABLE_DESCRIPTOR);\n\n  wrapper = function wrapper(dateString) {\n    dateString = dateString ? dateString.toString() : undefined;\n    return thisInterpreter.createPrimitive(Date.parse(dateString));\n  };\n  this.setProperty(this.DATE, 'parse', this.createNativeFunction(wrapper), Interpreter.NONENUMERABLE_DESCRIPTOR);\n\n  wrapper = function wrapper(a, b, c, d, e, f, h) {\n    var args = [];\n    for (var i = 0; i < arguments.length; i++) {\n      args[i] = arguments[i] ? arguments[i].toNumber() : undefined;\n    }\n    return thisInterpreter.createPrimitive(Date.UTC.apply(Date, args));\n  };\n  this.setProperty(this.DATE, 'UTC', this.createNativeFunction(wrapper), Interpreter.NONENUMERABLE_DESCRIPTOR);\n\n  // Instance methods on Date.\n  var functions = ['getDate', 'getDay', 'getFullYear', 'getHours', 'getMilliseconds', 'getMinutes', 'getMonth', 'getSeconds', 'getTime', 'getTimezoneOffset', 'getUTCDate', 'getUTCDay', 'getUTCFullYear', 'getUTCHours', 'getUTCMilliseconds', 'getUTCMinutes', 'getUTCMonth', 'getUTCSeconds', 'getYear', 'setDate', 'setFullYear', 'setHours', 'setMilliseconds', 'setMinutes', 'setMonth', 'setSeconds', 'setTime', 'setUTCDate', 'setUTCFullYear', 'setUTCHours', 'setUTCMilliseconds', 'setUTCMinutes', 'setUTCMonth', 'setUTCSeconds', 'setYear', 'toDateString', 'toISOString', 'toJSON', 'toGMTString', 'toLocaleDateString', 'toLocaleString', 'toLocaleTimeString', 'toTimeString', 'toUTCString'];\n  for (var i = 0; i < functions.length; i++) {\n    wrapper = function (nativeFunc) {\n      return function (var_args) {\n        var args = [];\n        for (var i = 0; i < arguments.length; i++) {\n          args[i] = thisInterpreter.pseudoToNative(arguments[i]);\n        }\n        return thisInterpreter.createPrimitive(this.data[nativeFunc].apply(this.data, args));\n      };\n    }(functions[i]);\n    this.setNativeFunctionPrototype(this.DATE, functions[i], wrapper);\n  }\n};\n\n/**\n * Initialize Math object.\n * @param {!Interpreter.Object} scope Global scope.\n */\nInterpreter.prototype.initMath = function (scope) {\n  var thisInterpreter = this;\n  var myMath = this.createObject(this.OBJECT);\n  this.setProperty(scope, 'Math', myMath);\n  var mathConsts = ['E', 'LN2', 'LN10', 'LOG2E', 'LOG10E', 'PI', 'SQRT1_2', 'SQRT2'];\n  for (var i = 0; i < mathConsts.length; i++) {\n    this.setProperty(myMath, mathConsts[i], this.createPrimitive(Math[mathConsts[i]]), Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\n  }\n  var numFunctions = ['abs', 'acos', 'asin', 'atan', 'atan2', 'ceil', 'cos', 'exp', 'floor', 'log', 'max', 'min', 'pow', 'random', 'round', 'sin', 'sqrt', 'tan'];\n  for (var i = 0; i < numFunctions.length; i++) {\n    var wrapper = function (nativeFunc) {\n      return function () {\n        for (var j = 0; j < arguments.length; j++) {\n          arguments[j] = arguments[j].toNumber();\n        }\n        return thisInterpreter.createPrimitive(nativeFunc.apply(Math, arguments));\n      };\n    }(Math[numFunctions[i]]);\n    this.setProperty(myMath, numFunctions[i], this.createNativeFunction(wrapper), Interpreter.NONENUMERABLE_DESCRIPTOR);\n  }\n};\n\n/**\n * Initialize Regular Expression object.\n * @param {!Interpreter.Object} scope Global scope.\n */\nInterpreter.prototype.initRegExp = function (scope) {\n  var thisInterpreter = this;\n  var wrapper;\n  // Regex constructor.\n  wrapper = function wrapper(pattern, flags) {\n    if (this.parent == thisInterpreter.REGEXP) {\n      // Called with new.\n      var rgx = this;\n    } else {\n      var rgx = thisInterpreter.createObject(thisInterpreter.REGEXP);\n    }\n    pattern = pattern ? pattern.toString() : '';\n    flags = flags ? flags.toString() : '';\n    return thisInterpreter.populateRegExp_(rgx, new RegExp(pattern, flags));\n  };\n  this.REGEXP = this.createNativeFunction(wrapper);\n  this.setProperty(scope, 'RegExp', this.REGEXP);\n\n  this.setProperty(this.REGEXP.properties.prototype, 'global', this.UNDEFINED, Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\n  this.setProperty(this.REGEXP.properties.prototype, 'ignoreCase', this.UNDEFINED, Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\n  this.setProperty(this.REGEXP.properties.prototype, 'multiline', this.UNDEFINED, Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\n  this.setProperty(this.REGEXP.properties.prototype, 'source', this.createPrimitive('(?:)'), Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\n\n  wrapper = function wrapper(str) {\n    str = str.toString();\n    return thisInterpreter.createPrimitive(this.data.test(str));\n  };\n  this.setNativeFunctionPrototype(this.REGEXP, 'test', wrapper);\n\n  wrapper = function wrapper(str) {\n    str = str.toString();\n    // Get lastIndex from wrapped regex, since this is settable.\n    this.data.lastIndex = thisInterpreter.getProperty(this, 'lastIndex').toNumber();\n    var match = this.data.exec(str);\n    thisInterpreter.setProperty(this, 'lastIndex', thisInterpreter.createPrimitive(this.data.lastIndex));\n\n    if (match) {\n      var result = thisInterpreter.createObject(thisInterpreter.ARRAY);\n      for (var i = 0; i < match.length; i++) {\n        thisInterpreter.setProperty(result, i, thisInterpreter.createPrimitive(match[i]));\n      }\n      // match has additional properties.\n      thisInterpreter.setProperty(result, 'index', thisInterpreter.createPrimitive(match.index));\n      thisInterpreter.setProperty(result, 'input', thisInterpreter.createPrimitive(match.input));\n      return result;\n    }\n    return thisInterpreter.NULL;\n  };\n  this.setNativeFunctionPrototype(this.REGEXP, 'exec', wrapper);\n};\n\n/**\n * Initialize JSON object.\n * @param {!Interpreter.Object} scope Global scope.\n */\nInterpreter.prototype.initJSON = function (scope) {\n  var thisInterpreter = this;\n  var myJSON = thisInterpreter.createObject(this.OBJECT);\n  this.setProperty(scope, 'JSON', myJSON);\n\n  var wrapper = function wrapper(text) {\n    try {\n      var nativeObj = JSON.parse(text.toString());\n    } catch (e) {\n      thisInterpreter.throwException(thisInterpreter.SYNTAX_ERROR, e.message);\n      return;\n    }\n    return thisInterpreter.nativeToPseudo(nativeObj);\n  };\n  this.setProperty(myJSON, 'parse', this.createNativeFunction(wrapper));\n\n  wrapper = function wrapper(value) {\n    var nativeObj = thisInterpreter.pseudoToNative(value);\n    return thisInterpreter.createPrimitive(JSON.stringify(nativeObj));\n  };\n  this.setProperty(myJSON, 'stringify', this.createNativeFunction(wrapper));\n};\n\n/**\n * Initialize the Error class.\n * @param {!Interpreter.Object} scope Global scope.\n */\nInterpreter.prototype.initError = function (scope) {\n  var thisInterpreter = this;\n  // Error constructor.\n  this.ERROR = this.createNativeFunction(function (opt_message) {\n    if (this.parent == thisInterpreter.ERROR) {\n      // Called with new.\n      var newError = this;\n    } else {\n      var newError = thisInterpreter.createObject(thisInterpreter.ERROR);\n    }\n    if (opt_message) {\n      thisInterpreter.setProperty(newError, 'message', thisInterpreter.createPrimitive(String(opt_message)), Interpreter.NONENUMERABLE_DESCRIPTOR);\n    }\n    return newError;\n  });\n  this.setProperty(scope, 'Error', this.ERROR);\n  this.setProperty(this.ERROR.properties.prototype, 'message', this.STRING_EMPTY, Interpreter.NONENUMERABLE_DESCRIPTOR);\n  this.setProperty(this.ERROR.properties.prototype, 'name', this.createPrimitive('Error'), Interpreter.NONENUMERABLE_DESCRIPTOR);\n\n  var createErrorSubclass = function createErrorSubclass(name) {\n    var constructor = thisInterpreter.createNativeFunction(function (opt_message) {\n      if (thisInterpreter.isa(this.parent, thisInterpreter.ERROR)) {\n        // Called with new.\n        var newError = this;\n      } else {\n        var newError = thisInterpreter.createObject(constructor);\n      }\n      if (opt_message) {\n        thisInterpreter.setProperty(newError, 'message', thisInterpreter.createPrimitive(String(opt_message)), Interpreter.NONENUMERABLE_DESCRIPTOR);\n      }\n      return newError;\n    });\n    thisInterpreter.setProperty(constructor, 'prototype', thisInterpreter.createObject(thisInterpreter.ERROR));\n    thisInterpreter.setProperty(constructor.properties.prototype, 'name', thisInterpreter.createPrimitive(name), Interpreter.NONENUMERABLE_DESCRIPTOR);\n    thisInterpreter.setProperty(scope, name, constructor);\n\n    return constructor;\n  };\n\n  this.EVAL_ERROR = createErrorSubclass('EvalError');\n  this.RANGE_ERROR = createErrorSubclass('RangeError');\n  this.REFERENCE_ERROR = createErrorSubclass('ReferenceError');\n  this.SYNTAX_ERROR = createErrorSubclass('SyntaxError');\n  this.TYPE_ERROR = createErrorSubclass('TypeError');\n  this.URI_ERROR = createErrorSubclass('URIError');\n};\n\n/**\n * Is an object of a certain class?\n * @param {Object} child Object to check.\n * @param {Object} parent Constructor of object.\n * @return {boolean} True if object is the class or inherits from it.\n *     False otherwise.\n */\nInterpreter.prototype.isa = function (child, parent) {\n  if (!child || !parent) {\n    return false;\n  }\n  while (child.parent != parent) {\n    if (!child.parent || !child.parent.properties.prototype) {\n      return false;\n    }\n    child = child.parent.properties.prototype;\n  }\n  return true;\n};\n\n/**\n * Compares two objects against each other.\n * @param {!Object} a First object.\n * @param {!Object} b Second object.\n * @return {number} -1 if a is smaller, 0 if a == b, 1 if a is bigger,\n *     NaN if they are not comparable.\n */\nInterpreter.prototype.comp = function (a, b) {\n  if (a.isPrimitive && typeof a.data == 'number' && isNaN(a.data) || b.isPrimitive && typeof b.data == 'number' && isNaN(b.data)) {\n    // NaN is not comparable to anything, including itself.\n    return NaN;\n  }\n  if (a === b) {\n    return 0;\n  }\n  var aValue = a.isPrimitive ? a.data : a.toString();\n  var bValue = b.isPrimitive ? b.data : b.toString();\n  if (aValue < bValue) {\n    return -1;\n  } else if (aValue > bValue) {\n    return 1;\n  } else if (!a.isPrimitive && !b.isPrimitive) {\n    // Two objects that have equal values are still not equal.\n    // e.g. [1, 2] != [1, 2]\n    return NaN;\n  } else if (aValue == bValue) {\n    return 0;\n  }\n  return NaN;\n};\n\n/**\n * Is a value a legal integer for an array?\n * @param {*} n Value to check.\n * @return {number} Zero, or a positive integer if the value can be\n *     converted to such.  NaN otherwise.\n */\nInterpreter.prototype.arrayIndex = function (n) {\n  n = Number(n);\n  if (!isFinite(n) || n != Math.floor(n) || n < 0 || n >= Math.pow(2, 32)) {\n    return NaN;\n  }\n  return n;\n};\n\n/**\n * Class for a number, string, boolean, null, or undefined.\n * @param {number|string|boolean|null|undefined} data Primitive value.\n * @param {!Interpreter} interpreter The JS Interpreter to bind to.\n * @constructor\n */\nInterpreter.Primitive = function (data, interpreter) {\n  var type = typeof data === 'undefined' ? 'undefined' : _typeof(data);\n  this.data = data;\n  this.type = type;\n  if (type == 'number') {\n    this.parent = interpreter.NUMBER;\n  } else if (type == 'string') {\n    this.parent = interpreter.STRING;\n  } else if (type == 'boolean') {\n    this.parent = interpreter.BOOLEAN;\n  }\n};\n\n/**\n * @type {number|string|boolean|null|undefined}\n */\nInterpreter.Primitive.prototype.data = undefined;\n\n/**\n * @type {string}\n */\nInterpreter.Primitive.prototype.type = 'undefined';\n\n/**\n * @type {Function}\n */\nInterpreter.Primitive.prototype.parent = null;\n\n/**\n * @type {boolean}\n */\nInterpreter.Primitive.prototype.isPrimitive = true;\n\n/**\n * Convert this primitive into a boolean.\n * @return {boolean} Boolean value.\n */\nInterpreter.Primitive.prototype.toBoolean = function () {\n  return Boolean(this.data);\n};\n\n/**\n * Convert this primitive into a number.\n * @return {number} Number value.\n */\nInterpreter.Primitive.prototype.toNumber = function () {\n  return Number(this.data);\n};\n\n/**\n * Convert this primitive into a string.\n * @return {string} String value.\n * @override\n */\nInterpreter.Primitive.prototype.toString = function () {\n  return String(this.data);\n};\n\n/**\n * Return the primitive value.\n * @return {number|string|boolean|null|undefined} Primitive value.\n * @override\n */\nInterpreter.Primitive.prototype.valueOf = function () {\n  return this.data;\n};\n\n/**\n * Create a new data object for a primitive.\n * @param {number|string|boolean|null|undefined|RegExp} data Data to\n *     encapsulate.\n * @return {!Interpreter.Primitive|!Interpreter.Object} New data object.\n */\nInterpreter.prototype.createPrimitive = function (data) {\n  // Reuse a predefined primitive constant if possible.\n  if (data === undefined) {\n    return this.UNDEFINED;\n  } else if (data === null) {\n    return this.NULL;\n  } else if (data === true) {\n    return this.TRUE;\n  } else if (data === false) {\n    return this.FALSE;\n  } else if (data === 0) {\n    return this.NUMBER_ZERO;\n  } else if (data === 1) {\n    return this.NUMBER_ONE;\n  } else if (data === '') {\n    return this.STRING_EMPTY;\n  } else if (data instanceof RegExp) {\n    return this.populateRegExp_(this.createObject(this.REGEXP), data);\n  }\n  return new Interpreter.Primitive(data, this);\n};\n\n/**\n * Class for an object.\n * @param {Interpreter.Object} parent Parent constructor function.\n * @constructor\n */\nInterpreter.Object = function (parent) {\n  this.notConfigurable = Object.create(null);\n  this.notEnumerable = Object.create(null);\n  this.notWritable = Object.create(null);\n  this.getter = Object.create(null);\n  this.setter = Object.create(null);\n  this.properties = Object.create(null);\n  this.parent = parent;\n};\n\n/**\n * @type {string}\n */\nInterpreter.Object.prototype.type = 'object';\n\n/**\n * @type {Interpreter.Object}\n */\nInterpreter.Object.prototype.parent = null;\n\n/**\n * @type {boolean}\n */\nInterpreter.Object.prototype.isPrimitive = false;\n\n/**\n * @type {number|string|boolean|undefined|!RegExp}\n */\nInterpreter.Object.prototype.data = undefined;\n\n/**\n * Convert this object into a boolean.\n * @return {boolean} Boolean value.\n */\nInterpreter.Object.prototype.toBoolean = function () {\n  return true;\n};\n\n/**\n * Convert this object into a number.\n * @return {number} Number value.\n */\nInterpreter.Object.prototype.toNumber = function () {\n  return Number(this.data === undefined ? this.toString() : this.data);\n};\n\n/**\n * Convert this object into a string.\n * @return {string} String value.\n * @override\n */\nInterpreter.Object.prototype.toString = function () {\n  return this.data === undefined ? '[' + this.type + ']' : String(this.data);\n};\n\n/**\n * Return the object value.\n * @return {*} Value.\n * @override\n */\nInterpreter.Object.prototype.valueOf = function () {\n  return this.data === undefined ? this : this.data;\n};\n\n/**\n * Create a new data object.\n * @param {Interpreter.Object} parent Parent constructor function.\n * @return {!Interpreter.Object} New data object.\n */\nInterpreter.prototype.createObject = function (parent) {\n  var obj = new Interpreter.Object(parent);\n  // Functions have prototype objects.\n  if (this.isa(obj, this.FUNCTION)) {\n    obj.type = 'function';\n    this.setProperty(obj, 'prototype', this.createObject(this.OBJECT || null));\n  }\n  // Arrays have length.\n  if (this.isa(obj, this.ARRAY)) {\n    obj.length = 0;\n    obj.toString = function () {\n      var strs = [];\n      for (var i = 0; i < this.length; i++) {\n        var value = this.properties[i];\n        strs[i] = !value || value.isPrimitive && (value.data === null || value.data === undefined) ? '' : value.toString();\n      }\n      return strs.join(',');\n    };\n  }\n  // Errors have a custom toString method.\n  if (this.isa(obj, this.ERROR)) {\n    var thisInterpreter = this;\n    obj.toString = function () {\n      var name = thisInterpreter.getProperty(this, 'name').toString();\n      var message = thisInterpreter.getProperty(this, 'message').toString();\n      return message ? name + ': ' + message : name;\n    };\n  }\n  return obj;\n};\n\n/**\n * Initialize a pseudo regular expression object based on a native regular\n * expression object.\n * @param {!Interpreter.Object} pseudoRegexp The existing object to set.\n * @param {!RegExp} nativeRegexp The native regular expression.\n * @return {!Interpreter.Object} Newly populated regular expression object.\n * @private\n */\nInterpreter.prototype.populateRegExp_ = function (pseudoRegexp, nativeRegexp) {\n  pseudoRegexp.data = nativeRegexp;\n  // lastIndex is settable, all others are read-only attributes\n  this.setProperty(pseudoRegexp, 'lastIndex', this.createPrimitive(nativeRegexp.lastIndex), Interpreter.NONENUMERABLE_DESCRIPTOR);\n  this.setProperty(pseudoRegexp, 'source', this.createPrimitive(nativeRegexp.source), Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\n  this.setProperty(pseudoRegexp, 'global', this.createPrimitive(nativeRegexp.global), Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\n  this.setProperty(pseudoRegexp, 'ignoreCase', this.createPrimitive(nativeRegexp.ignoreCase), Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\n  this.setProperty(pseudoRegexp, 'multiline', this.createPrimitive(nativeRegexp.multiline), Interpreter.READONLY_NONENUMERABLE_DESCRIPTOR);\n  // Override a couple of Object's conversion functions.\n  pseudoRegexp.toString = function () {\n    return String(this.data);\n  };\n  pseudoRegexp.valueOf = function () {\n    return this.data;\n  };\n  return pseudoRegexp;\n};\n\n/**\n * Create a new function.\n * @param {!Object} node AST node defining the function.\n * @param {!Object} scope Parent scope.\n * @return {!Interpreter.Object} New function.\n */\nInterpreter.prototype.createFunction = function (node, scope) {\n  var func = this.createObject(this.FUNCTION);\n  func.parentScope = scope;\n  func.node = node;\n  this.setProperty(func, 'length', this.createPrimitive(func.node.params.length), Interpreter.READONLY_DESCRIPTOR);\n  return func;\n};\n\n/**\n * Create a new native function.\n * @param {!Function} nativeFunc JavaScript function.\n * @return {!Interpreter.Object} New function.\n */\nInterpreter.prototype.createNativeFunction = function (nativeFunc) {\n  var func = this.createObject(this.FUNCTION);\n  func.nativeFunc = nativeFunc;\n  this.setProperty(func, 'length', this.createPrimitive(nativeFunc.length), Interpreter.READONLY_DESCRIPTOR);\n  return func;\n};\n\n/**\n * Create a new native asynchronous function.\n * @param {!Function} asyncFunc JavaScript function.\n * @return {!Interpreter.Object} New function.\n */\nInterpreter.prototype.createAsyncFunction = function (asyncFunc) {\n  var func = this.createObject(this.FUNCTION);\n  func.asyncFunc = asyncFunc;\n  this.setProperty(func, 'length', this.createPrimitive(asyncFunc.length), Interpreter.READONLY_DESCRIPTOR);\n  return func;\n};\n\n/**\n * Converts from a native JS object or value to a JS interpreter object.\n * Can handle JSON-style values.\n * @param {*} nativeObj The native JS object to be converted.\n * @return {!Interpreter.Object|!Interpreter.Primitive} The equivalent\n *     JS interpreter object.\n */\nInterpreter.prototype.nativeToPseudo = function (nativeObj) {\n  if (typeof nativeObj == 'boolean' || typeof nativeObj == 'number' || typeof nativeObj == 'string' || nativeObj === null || nativeObj === undefined || nativeObj instanceof RegExp) {\n    return this.createPrimitive(nativeObj);\n  }\n\n  if (nativeObj instanceof Function) {\n    var interpreter = this;\n    var wrapper = function wrapper() {\n      return interpreter.nativeToPseudo(nativeObj.apply(interpreter, Array.prototype.slice.call(arguments).map(function (i) {\n        return interpreter.pseudoToNative(i);\n      })));\n    };\n    return this.createNativeFunction(wrapper);\n  }\n\n  var pseudoObj;\n  if (nativeObj instanceof Array) {\n    // Array.\n    pseudoObj = this.createObject(this.ARRAY);\n    for (var i = 0; i < nativeObj.length; i++) {\n      this.setProperty(pseudoObj, i, this.nativeToPseudo(nativeObj[i]));\n    }\n  } else {\n    // Object.\n    pseudoObj = this.createObject(this.OBJECT);\n    for (var key in nativeObj) {\n      this.setProperty(pseudoObj, key, this.nativeToPseudo(nativeObj[key]));\n    }\n  }\n  return pseudoObj;\n};\n\n/**\n * Converts from a JS interpreter object to native JS object.\n * Can handle JSON-style values.\n * @param {!Interpreter.Object|!Interpreter.Primitive} pseudoObj The JS\n *     interpreter object to be converted.\n * @return {*} The equivalent native JS object or value.\n */\nInterpreter.prototype.pseudoToNative = function (pseudoObj) {\n  if (pseudoObj.isPrimitive || this.isa(pseudoObj, this.NUMBER) || this.isa(pseudoObj, this.STRING) || this.isa(pseudoObj, this.BOOLEAN)) {\n    return pseudoObj.data;\n  }\n  var nativeObj;\n  if (this.isa(pseudoObj, this.ARRAY)) {\n    // Array.\n    nativeObj = [];\n    for (var i = 0; i < pseudoObj.length; i++) {\n      nativeObj[i] = this.pseudoToNative(pseudoObj.properties[i]);\n    }\n  } else {\n    // Object.\n    nativeObj = {};\n    for (var key in pseudoObj.properties) {\n      nativeObj[key] = this.pseudoToNative(pseudoObj.properties[key]);\n    }\n  }\n  return nativeObj;\n};\n\n/**\n * Fetch a property value from a data object.\n * @param {!Interpreter.Object|!Interpreter.Primitive} obj Data object.\n * @param {*} name Name of property.\n * @return {!Interpreter.Object|!Interpreter.Primitive|null} Property value\n *     (may be UNDEFINED), or null if an error was thrown and will be caught.\n */\nInterpreter.prototype.getProperty = function (obj, name) {\n  name = name.toString();\n  if (obj == this.UNDEFINED || obj == this.NULL) {\n    this.throwException(this.TYPE_ERROR, \"Cannot read property '\" + name + \"' of \" + obj);\n    return null;\n  }\n  // Special cases for magic length property.\n  if (this.isa(obj, this.STRING)) {\n    if (name == 'length') {\n      return this.createPrimitive(obj.data.length);\n    }\n    var n = this.arrayIndex(name);\n    if (!isNaN(n) && n < obj.data.length) {\n      return this.createPrimitive(obj.data[n]);\n    }\n  } else if (this.isa(obj, this.ARRAY) && name == 'length') {\n    return this.createPrimitive(obj.length);\n  }\n  while (true) {\n    if (obj.properties && name in obj.properties) {\n      var getter = obj.getter[name];\n      if (getter) {\n        // Flag this function as being a getter and thus needing immediate\n        // execution (rather than being the value of the property).\n        getter.isGetter = true;\n        return getter;\n      }\n      return obj.properties[name];\n    }\n    if (obj.parent && obj.parent.properties && obj.parent.properties.prototype) {\n      obj = obj.parent.properties.prototype;\n    } else {\n      // No parent, reached the top.\n      break;\n    }\n  }\n  return this.UNDEFINED;\n};\n\n/**\n * Does the named property exist on a data object.\n * @param {!Interpreter.Object|!Interpreter.Primitive} obj Data object.\n * @param {*} name Name of property.\n * @return {boolean} True if property exists.\n */\nInterpreter.prototype.hasProperty = function (obj, name) {\n  name = name.toString();\n  if (obj.isPrimitive) {\n    throw TypeError('Primitive data type has no properties');\n  }\n  if (name == 'length' && (this.isa(obj, this.STRING) || this.isa(obj, this.ARRAY))) {\n    return true;\n  }\n  if (this.isa(obj, this.STRING)) {\n    var n = this.arrayIndex(name);\n    if (!isNaN(n) && n < obj.data.length) {\n      return true;\n    }\n  }\n  while (true) {\n    if (obj.properties && name in obj.properties) {\n      return true;\n    }\n    if (obj.parent && obj.parent.properties && obj.parent.properties.prototype) {\n      obj = obj.parent.properties.prototype;\n    } else {\n      // No parent, reached the top.\n      break;\n    }\n  }\n  return false;\n};\n\n/**\n * Set a property value on a data object.\n * @param {!Interpreter.Object} obj Data object.\n * @param {*} name Name of property.\n * @param {Interpreter.Object|Interpreter.Primitive} value\n *     New property value or null if getter/setter is described.\n * @param {Object=} opt_descriptor Optional descriptor object.\n * @return {!Interpreter.Object|undefined} Returns a setter function if one\n *     needs to be called, otherwise undefined.\n */\nInterpreter.prototype.setProperty = function (obj, name, value, opt_descriptor) {\n  name = name.toString();\n  if (opt_descriptor && obj.notConfigurable[name]) {\n    this.throwException(this.TYPE_ERROR, 'Cannot redefine property: ' + name);\n  }\n  if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) != 'object') {\n    throw Error('Failure to wrap a value: ' + value);\n  }\n  if (obj == this.UNDEFINED || obj == this.NULL) {\n    this.throwException(this.TYPE_ERROR, \"Cannot set property '\" + name + \"' of \" + obj);\n  }\n  if (opt_descriptor && (opt_descriptor.get || opt_descriptor.set) && (value || opt_descriptor.writable !== undefined)) {\n    this.throwException(this.TYPE_ERROR, 'Invalid property descriptor. ' + 'Cannot both specify accessors and a value or writable attribute');\n  }\n  var strict = !this.stateStack || this.getScope().strict;\n  if (obj.isPrimitive) {\n    if (strict) {\n      this.throwException(this.TYPE_ERROR, 'Can\\'t create property \\'' + name + '\\' on \\'' + obj.data + '\\'');\n    }\n    return;\n  }\n  if (this.isa(obj, this.STRING)) {\n    var n = this.arrayIndex(name);\n    if (name == 'length' || !isNaN(n) && n < obj.data.length) {\n      // Can't set length or letters on String objects.\n      if (strict) {\n        this.throwException(this.TYPE_ERROR, 'Cannot assign to read only ' + 'property \\'' + name + '\\' of String \\'' + obj.data + '\\'');\n      }\n      return;\n    }\n  }\n  if (this.isa(obj, this.ARRAY)) {\n    // Arrays have a magic length variable that is bound to the elements.\n    var i;\n    if (name == 'length') {\n      // Delete elements if length is smaller.\n      var newLength = this.arrayIndex(value.toNumber());\n      if (isNaN(newLength)) {\n        this.throwException(this.RANGE_ERROR, 'Invalid array length');\n      }\n      if (newLength < obj.length) {\n        for (i in obj.properties) {\n          i = this.arrayIndex(i);\n          if (!isNaN(i) && newLength <= i) {\n            delete obj.properties[i];\n          }\n        }\n      }\n      obj.length = newLength;\n      return; // Don't set a real length property.\n    } else if (!isNaN(i = this.arrayIndex(name))) {\n      // Increase length if this index is larger.\n      obj.length = Math.max(obj.length, i + 1);\n    }\n  }\n  if (!obj.properties[name] && obj.preventExtensions) {\n    if (strict) {\n      this.throwException(this.TYPE_ERROR, 'Can\\'t add property ' + name + ', object is not extensible');\n    }\n    return;\n  }\n  if (opt_descriptor) {\n    // Define the property.\n    obj.properties[name] = value;\n    if (!opt_descriptor.configurable) {\n      obj.notConfigurable[name] = true;\n    }\n    var getter = opt_descriptor.get;\n    if (getter) {\n      obj.getter[name] = getter;\n    } else {\n      delete obj.getter[name];\n    }\n    var setter = opt_descriptor.set;\n    if (setter) {\n      obj.setter[name] = setter;\n    } else {\n      delete obj.setter[name];\n    }\n    var enumerable = opt_descriptor.enumerable || false;\n    if (enumerable) {\n      delete obj.notEnumerable[name];\n    } else {\n      obj.notEnumerable[name] = true;\n    }\n    if (getter || setter) {\n      delete obj.notWritable[name];\n      obj.properties[name] = this.UNDEFINED;\n    } else {\n      var writable = opt_descriptor.writable || false;\n      if (writable) {\n        delete obj.notWritable[name];\n      } else {\n        obj.notWritable[name] = true;\n      }\n    }\n  } else {\n    // Set the property.\n    // Determine if there is a setter anywhere in the parent chain.\n    var parent = obj;\n    while (true) {\n      if (parent.setter && parent.setter[name]) {\n        return parent.setter[name];\n      }\n      if (parent.parent && parent.parent.properties && parent.parent.properties.prototype) {\n        parent = parent.parent.properties.prototype;\n      } else {\n        // No parent, reached the top.\n        break;\n      }\n    }\n    if (obj.getter && obj.getter[name]) {\n      if (strict) {\n        this.throwException(this.TYPE_ERROR, 'Cannot set property \\'' + name + '\\' of object \\'' + obj + '\\' which only has a getter');\n      }\n    } else {\n      // No setter, simple assignment.\n      if (!obj.notWritable[name]) {\n        obj.properties[name] = value;\n      } else if (strict) {\n        this.throwException(this.TYPE_ERROR, 'Cannot assign to read only ' + 'property \\'' + name + '\\' of object \\'' + obj + '\\'');\n      }\n    }\n  }\n};\n\n/**\n * Convenience method for adding a native function as a non-enumerable property\n * onto an object's prototype.\n * @param {!Interpreter.Object} obj Data object.\n * @param {*} name Name of property.\n * @param {!Function} wrapper Function object.\n */\nInterpreter.prototype.setNativeFunctionPrototype = function (obj, name, wrapper) {\n  this.setProperty(obj.properties.prototype, name, this.createNativeFunction(wrapper), Interpreter.NONENUMERABLE_DESCRIPTOR);\n};\n\n/**\n * Delete a property value on a data object.\n * @param {!Interpreter.Object} obj Data object.\n * @param {*} name Name of property.\n * @return {boolean} True if deleted, false if undeletable.\n */\nInterpreter.prototype.deleteProperty = function (obj, name) {\n  name = name.toString();\n  if (obj.isPrimitive || obj.notWritable[name]) {\n    return false;\n  }\n  if (name == 'length' && this.isa(obj, this.ARRAY)) {\n    return false;\n  }\n  return delete obj.properties[name];\n};\n\n/**\n * Returns the current scope from the stateStack.\n * @return {!Interpreter.Object} Current scope dictionary.\n */\nInterpreter.prototype.getScope = function () {\n  for (var i = this.stateStack.length - 1; i >= 0; i--) {\n    if (this.stateStack[i].scope) {\n      return this.stateStack[i].scope;\n    }\n  }\n  throw Error('No scope found.');\n};\n\n/**\n * Create a new scope dictionary.\n * @param {!Object} node AST node defining the scope container\n *     (e.g. a function).\n * @param {Interpreter.Object} parentScope Scope to link to.\n * @return {!Interpreter.Object} New scope.\n */\nInterpreter.prototype.createScope = function (node, parentScope) {\n  var scope = this.createObject(null);\n  scope.parentScope = parentScope;\n  if (!parentScope) {\n    this.initGlobalScope(scope);\n  }\n  this.populateScope_(node, scope);\n\n  // Determine if this scope starts with 'use strict'.\n  scope.strict = false;\n  if (parentScope && parentScope.strict) {\n    scope.strict = true;\n  } else {\n    var firstNode = node.body && node.body[0];\n    if (firstNode && firstNode.expression && firstNode.expression.type == 'Literal' && firstNode.expression.value == 'use strict') {\n      scope.strict = true;\n    }\n  }\n  return scope;\n};\n\n/**\n * Create a new special scope dictionary. Similar to createScope(), but\n * doesn't assume that the scope is for a function body. This is used for\n * the catch clause and with statement.\n * @param {!Interpreter.Object} parentScope Scope to link to.\n * @param {Interpreter.Object=} opt_scope Optional object to transform into\n *     scope.\n * @return {!Interpreter.Object} New scope.\n */\nInterpreter.prototype.createSpecialScope = function (parentScope, opt_scope) {\n  if (!parentScope) {\n    throw Error('parentScope required');\n  }\n  var scope = opt_scope || this.createObject(null);\n  scope.parentScope = parentScope;\n  scope.strict = parentScope.strict;\n  return scope;\n};\n\n/**\n * Retrieves a value from the scope chain.\n * @param {!Interpreter.Object|!Interpreter.Primitive} name Name of variable.\n * @return {!Interpreter.Object|!Interpreter.Primitive|null} The value\n *     or null if an error was thrown and will be caught.\n */\nInterpreter.prototype.getValueFromScope = function (name) {\n  var scope = this.getScope();\n  var nameStr = name.toString();\n  while (scope && scope != this.global) {\n    if (nameStr in scope.properties) {\n      return scope.properties[nameStr];\n    }\n    scope = scope.parentScope;\n  }\n  // The root scope is also an object which has inherited properties and\n  // could also have getters.\n  if (scope == this.global && this.hasProperty(scope, nameStr)) {\n    return this.getProperty(scope, nameStr);\n  }\n  // Typeof operator is unique: it can safely look at non-defined variables.\n  var prevNode = this.stateStack[this.stateStack.length - 1].node;\n  if (prevNode.type == 'UnaryExpression' && prevNode.operator == 'typeof') {\n    return this.UNDEFINED;\n  }\n  this.throwException(this.REFERENCE_ERROR, nameStr + ' is not defined');\n  return null;\n};\n\n/**\n * Sets a value to the current scope.\n * @param {!Interpreter.Object|!Interpreter.Primitive} name Name of variable.\n * @param {!Interpreter.Object|!Interpreter.Primitive} value Value.\n * @return {!Interpreter.Object|undefined} Returns a setter function if one\n *     needs to be called, otherwise undefined.\n */\nInterpreter.prototype.setValueToScope = function (name, value) {\n  var scope = this.getScope();\n  var nameStr = name.toString();\n  while (scope && scope != this.global) {\n    if (nameStr in scope.properties) {\n      scope.properties[nameStr] = value;\n      return undefined;\n    }\n    scope = scope.parentScope;\n  }\n  // The root scope is also an object which has readonly properties and\n  // could also have setters.\n  if (scope == this.global && (!scope.strict || this.hasProperty(scope, nameStr))) {\n    return this.setProperty(scope, nameStr, value);\n  }\n  this.throwException(this.REFERENCE_ERROR, nameStr + ' is not defined');\n};\n\n/**\n * Create a new scope for the given node.\n * @param {!Object} node AST node (program or function).\n * @param {!Interpreter.Object} scope Scope dictionary to populate.\n * @private\n */\nInterpreter.prototype.populateScope_ = function (node, scope) {\n  if (node.type == 'VariableDeclaration') {\n    for (var i = 0; i < node.declarations.length; i++) {\n      this.setProperty(scope, node.declarations[i].id.name, this.UNDEFINED);\n    }\n  } else if (node.type == 'FunctionDeclaration') {\n    this.setProperty(scope, node.id.name, this.createFunction(node, scope));\n    return; // Do not recurse into function.\n  } else if (node.type == 'FunctionExpression') {\n    return; // Do not recurse into function.\n  } else if (node.type == 'ExpressionStatement') {\n    return; // Expressions can't contain variable/function declarations.\n  }\n  var nodeClass = node.constructor;\n  for (var name in node) {\n    var prop = node[name];\n    if (prop && (typeof prop === 'undefined' ? 'undefined' : _typeof(prop)) == 'object') {\n      if (prop instanceof Array) {\n        for (var i = 0; i < prop.length; i++) {\n          if (prop[i] && prop[i].constructor == nodeClass) {\n            this.populateScope_(prop[i], scope);\n          }\n        }\n      } else {\n        if (prop.constructor == nodeClass) {\n          this.populateScope_(prop, scope);\n        }\n      }\n    }\n  }\n};\n\n/**\n * Remove start and end values from AST, or set start and end values to a\n * constant value.  Used to remove highlighting from polyfills and to set\n * highlighting in an eval to cover the entire eval expression.\n * @param {!Object} node AST node.\n * @param {number=} start Starting character of all nodes, or undefined.\n * @param {number=} end Ending character of all nodes, or undefined.\n * @private\n */\nInterpreter.prototype.stripLocations_ = function (node, start, end) {\n  if (start) {\n    node.start = start;\n  } else {\n    delete node.start;\n  }\n  if (end) {\n    node.end = end;\n  } else {\n    delete node.end;\n  }\n  for (var name in node) {\n    if (node.hasOwnProperty(name)) {\n      var prop = node[name];\n      if (prop && (typeof prop === 'undefined' ? 'undefined' : _typeof(prop)) == 'object') {\n        this.stripLocations_(prop, start, end);\n      }\n    }\n  }\n};\n\n/**\n * Gets a value from the scope chain or from an object property.\n * @param {!Interpreter.Object|!Interpreter.Primitive|!Array} left\n *     Name of variable or object/propname tuple.\n * @return {!Interpreter.Object|!Interpreter.Primitive|null} Value\n *     or null if an error was thrown and will be caught.\n */\nInterpreter.prototype.getValue = function (left) {\n  if (left instanceof Array) {\n    var obj = left[0];\n    var prop = left[1];\n    return this.getProperty(obj, prop);\n  } else {\n    return this.getValueFromScope(left);\n  }\n};\n\n/**\n * Sets a value to the scope chain or to an object property.\n * @param {!Interpreter.Object|!Interpreter.Primitive|!Array} left\n *     Name of variable or object/propname tuple.\n * @param {!Interpreter.Object|!Interpreter.Primitive} value Value.\n * @return {!Interpreter.Object|undefined} Returns a setter function if one\n *     needs to be called, otherwise undefined.\n */\nInterpreter.prototype.setValue = function (left, value) {\n  if (left instanceof Array) {\n    var obj = left[0];\n    var prop = left[1];\n    return this.setProperty(obj, prop, value);\n  } else {\n    return this.setValueToScope(left, value);\n  }\n};\n\n/**\n * Throw an exception in the interpreter that can be handled by a\n * interpreter try/catch statement.  If unhandled, a real exception will\n * be thrown.  Can be called with either an error class and a message, or\n * with an actual object to be thrown.\n * @param {!Interpreter.Object} errorClass Type of error (if message is\n *   provided) or the value to throw (if no message).\n * @param {string=} opt_message Message being thrown.\n */\nInterpreter.prototype.throwException = function (errorClass, opt_message) {\n  if (opt_message === undefined) {\n    var error = errorClass; // This is a value to throw, not an error class.\n  } else {\n    var error = this.createObject(errorClass);\n    this.setProperty(error, 'message', this.createPrimitive(opt_message), Interpreter.NONENUMERABLE_DESCRIPTOR);\n  }\n  this.executeException(error);\n};\n\n/**\n * Throw an exception in the interpreter that can be handled by a\n * interpreter try/catch statement.  If unhandled, a real exception will\n * be thrown.\n * @param {!Interpreter.Object} error Error object to execute.\n */\nInterpreter.prototype.executeException = function (error) {\n  // Search for a try statement.\n  do {\n    this.stateStack.pop();\n    var state = this.stateStack[this.stateStack.length - 1];\n    if (state.node.type == 'TryStatement') {\n      state.throwValue = error;\n      return;\n    }\n  } while (state && state.node.type != 'Program');\n\n  // Throw a real error.\n  var realError;\n  if (this.isa(error, this.ERROR)) {\n    var errorTable = {\n      'EvalError': EvalError,\n      'RangeError': RangeError,\n      'ReferenceError': ReferenceError,\n      'SyntaxError': SyntaxError,\n      'TypeError': TypeError,\n      'URIError': URIError\n    };\n    var name = this.getProperty(error, 'name').toString();\n    var message = this.getProperty(error, 'message').valueOf();\n    var type = errorTable[name] || Error;\n    realError = type(message);\n  } else {\n    realError = error.toString();\n  }\n  throw realError;\n};\n\n/**\n * Push a call to a getter onto the statestack.\n * @param {!Interpreter.Object} func Function to execute.\n * @param {!Interpreter.Object|!Array} left\n *     Name of variable or object/propname tuple.\n * @private\n */\nInterpreter.prototype.pushGetter_ = function (func, left) {\n  // Normally 'this' will be specified as the object component (o.x).\n  // Sometimes 'this' is explicitly provided (o).\n  var funcThis = left instanceof Array ? left[0] : left;\n  this.stateStack.push({\n    node: { type: 'CallExpression' },\n    doneCallee_: true,\n    funcThis_: funcThis,\n    func_: func,\n    doneArgs_: true,\n    arguments_: []\n  });\n};\n\n/**\n * Push a call to a setter onto the statestack.\n * @param {!Interpreter.Object} func Function to execute.\n * @param {!Interpreter.Object|!Array} left\n *     Name of variable or object/propname tuple.\n * @param {!Interpreter.Object|Interpreter.Primitive} value Value to set.\n * @private\n */\nInterpreter.prototype.pushSetter_ = function (func, left, value) {\n  // Normally 'this' will be specified as the object component (o.x).\n  // Sometimes 'this' is implicitly the global object (x).\n  var funcThis = left instanceof Array ? left[0] : this.global;\n  this.stateStack.push({\n    node: { type: 'CallExpression' },\n    doneCallee_: true,\n    funcThis_: funcThis,\n    func_: func,\n    doneArgs_: true,\n    arguments_: [value]\n  });\n};\n\n/**\n * Take a snapshot from current stateStack. Restore by restoreStateSnapshot\n */\nInterpreter.prototype.takeStateSnapshot = function () {\n  var newStateStack = clone(this.stateStack, undefined, undefined, undefined, true);\n  this.global = newStateStack[0].scope;\n  return newStateStack;\n};\n\n/**\n * Restore a state snapshot\n */\nInterpreter.prototype.restoreStateSnapshot = function (snapshot) {\n  this.stateStack = clone(snapshot, undefined, undefined, undefined, true);\n  this.global = this.stateStack[0].scope;\n  this.initFunc_(this, this.global);\n};\n\n///////////////////////////////////////////////////////////////////////////////\n// Functions to handle each node type.\n///////////////////////////////////////////////////////////////////////////////\n\nInterpreter.prototype['stepArrayExpression'] = function () {\n  var state = this.stateStack[this.stateStack.length - 1];\n  var node = state.node;\n  var n = state.n_ || 0;\n  if (!state.array_) {\n    state.array_ = this.createObject(this.ARRAY);\n  } else if (state.value) {\n    this.setProperty(state.array_, n - 1, state.value);\n  }\n  if (n < node.elements.length) {\n    state.n_ = n + 1;\n    if (node.elements[n]) {\n      this.stateStack.push({ node: node.elements[n] });\n    } else {\n      // [0, 1, , 3][2] -> undefined\n      // Missing elements are not defined, they aren't undefined.\n      state.value = undefined;\n    }\n  } else {\n    state.array_.length = state.n_ || 0;\n    this.stateStack.pop();\n    this.stateStack[this.stateStack.length - 1].value = state.array_;\n  }\n};\n\nInterpreter.prototype['stepAssignmentExpression'] = function () {\n  var state = this.stateStack[this.stateStack.length - 1];\n  var node = state.node;\n  if (!state.doneLeft_) {\n    state.doneLeft_ = true;\n    this.stateStack.push({ node: node.left, components: true });\n    return;\n  }\n  if (!state.doneRight_) {\n    if (!state.leftSide_) {\n      state.leftSide_ = state.value;\n    }\n    if (state.doneGetter_) {\n      state.leftValue_ = state.value;\n    }\n    if (!state.doneGetter_ && node.operator != '=') {\n      state.leftValue_ = this.getValue(state.leftSide_);\n      if (state.leftValue_.isGetter) {\n        // Clear the getter flag and call the getter function.\n        state.leftValue_.isGetter = false;\n        state.doneGetter_ = true;\n        var func = /** @type {!Interpreter.Object} */state.leftValue_;\n        this.pushGetter_(func, state.leftSide_);\n        return;\n      }\n    }\n    state.doneRight_ = true;\n    this.stateStack.push({ node: node.right });\n    return;\n  }\n  if (state.doneSetter_) {\n    // Return if setter function.\n    // Setter method on property has completed.\n    // Ignore its return value, and use the original set value instead.\n    this.stateStack.pop();\n    this.stateStack[this.stateStack.length - 1].value = state.doneSetter_;\n    return;\n  }\n  var rightSide = state.value;\n  var value;\n  if (node.operator == '=') {\n    value = rightSide;\n  } else {\n    var rightValue = rightSide;\n    var leftNumber = state.leftValue_.toNumber();\n    var rightNumber = rightValue.toNumber();\n    if (node.operator == '+=') {\n      var left, right;\n      if (state.leftValue_.type == 'string' || rightValue.type == 'string') {\n        left = state.leftValue_.toString();\n        right = rightValue.toString();\n      } else {\n        left = leftNumber;\n        right = rightNumber;\n      }\n      value = left + right;\n    } else if (node.operator == '-=') {\n      value = leftNumber - rightNumber;\n    } else if (node.operator == '*=') {\n      value = leftNumber * rightNumber;\n    } else if (node.operator == '/=') {\n      value = leftNumber / rightNumber;\n    } else if (node.operator == '%=') {\n      value = leftNumber % rightNumber;\n    } else if (node.operator == '<<=') {\n      value = leftNumber << rightNumber;\n    } else if (node.operator == '>>=') {\n      value = leftNumber >> rightNumber;\n    } else if (node.operator == '>>>=') {\n      value = leftNumber >>> rightNumber;\n    } else if (node.operator == '&=') {\n      value = leftNumber & rightNumber;\n    } else if (node.operator == '^=') {\n      value = leftNumber ^ rightNumber;\n    } else if (node.operator == '|=') {\n      value = leftNumber | rightNumber;\n    } else {\n      throw SyntaxError('Unknown assignment expression: ' + node.operator);\n    }\n    value = this.createPrimitive(value);\n  }\n  var setter = this.setValue(state.leftSide_, value);\n  if (setter) {\n    state.doneSetter_ = value;\n    this.pushSetter_(setter, state.leftSide_, value);\n    return;\n  }\n  // Return if no setter function.\n  this.stateStack.pop();\n  this.stateStack[this.stateStack.length - 1].value = value;\n};\n\nInterpreter.prototype['stepBinaryExpression'] = function () {\n  var state = this.stateStack[this.stateStack.length - 1];\n  var node = state.node;\n  if (!state.doneLeft_) {\n    state.doneLeft_ = true;\n    this.stateStack.push({ node: node.left });\n    return;\n  }\n  if (!state.doneRight_) {\n    state.doneRight_ = true;\n    state.leftValue_ = state.value;\n    this.stateStack.push({ node: node.right });\n    return;\n  }\n  this.stateStack.pop();\n  var leftSide = state.leftValue_;\n  var rightSide = state.value;\n  var value;\n  var comp = this.comp(leftSide, rightSide);\n  if (node.operator == '==' || node.operator == '!=') {\n    if (leftSide.isPrimitive && rightSide.isPrimitive) {\n      value = leftSide.data == rightSide.data;\n    } else {\n      value = comp === 0;\n    }\n    if (node.operator == '!=') {\n      value = !value;\n    }\n  } else if (node.operator == '===' || node.operator == '!==') {\n    if (leftSide.isPrimitive && rightSide.isPrimitive) {\n      value = leftSide.data === rightSide.data;\n    } else {\n      value = leftSide === rightSide;\n    }\n    if (node.operator == '!==') {\n      value = !value;\n    }\n  } else if (node.operator == '>') {\n    value = comp == 1;\n  } else if (node.operator == '>=') {\n    value = comp == 1 || comp === 0;\n  } else if (node.operator == '<') {\n    value = comp == -1;\n  } else if (node.operator == '<=') {\n    value = comp == -1 || comp === 0;\n  } else if (node.operator == '+') {\n    var leftValue = leftSide.isPrimitive ? leftSide.data : leftSide.toString();\n    var rightValue = rightSide.isPrimitive ? rightSide.data : rightSide.toString();\n    value = leftValue + rightValue;\n  } else if (node.operator == 'in') {\n    value = this.hasProperty(rightSide, leftSide);\n  } else if (node.operator == 'instanceof') {\n    if (!this.isa(rightSide, this.FUNCTION)) {\n      this.throwException(this.TYPE_ERROR, 'Expecting a function in instanceof check');\n    }\n    value = this.isa(leftSide, rightSide);\n  } else {\n    var leftValue = leftSide.toNumber();\n    var rightValue = rightSide.toNumber();\n    if (node.operator == '-') {\n      value = leftValue - rightValue;\n    } else if (node.operator == '*') {\n      value = leftValue * rightValue;\n    } else if (node.operator == '/') {\n      value = leftValue / rightValue;\n    } else if (node.operator == '%') {\n      value = leftValue % rightValue;\n    } else if (node.operator == '&') {\n      value = leftValue & rightValue;\n    } else if (node.operator == '|') {\n      value = leftValue | rightValue;\n    } else if (node.operator == '^') {\n      value = leftValue ^ rightValue;\n    } else if (node.operator == '<<') {\n      value = leftValue << rightValue;\n    } else if (node.operator == '>>') {\n      value = leftValue >> rightValue;\n    } else if (node.operator == '>>>') {\n      value = leftValue >>> rightValue;\n    } else {\n      throw SyntaxError('Unknown binary operator: ' + node.operator);\n    }\n  }\n  this.stateStack[this.stateStack.length - 1].value = this.createPrimitive(value);\n};\n\nInterpreter.prototype['stepBlockStatement'] = function () {\n  var state = this.stateStack[this.stateStack.length - 1];\n  var node = state.node;\n  var n = state.n_ || 0;\n  if (node.body[n]) {\n    state.n_ = n + 1;\n    this.stateStack.push({ node: node.body[n] });\n  } else {\n    this.stateStack.pop();\n  }\n};\n\nInterpreter.prototype['stepBreakStatement'] = function () {\n  var state = this.stateStack.pop();\n  var node = state.node;\n  var label = null;\n  if (node.label) {\n    label = node.label.name;\n  }\n  state = this.stateStack.pop();\n  while (state && state.node.type != 'CallExpression' && state.node.type != 'NewExpression') {\n    if (label ? label == state.label : state.isLoop || state.isSwitch) {\n      return;\n    }\n    state = this.stateStack.pop();\n  }\n  // Syntax error, do not allow this error to be trapped.\n  throw SyntaxError('Illegal break statement');\n};\n\nInterpreter.prototype['stepCallExpression'] = function () {\n  var state = this.stateStack[this.stateStack.length - 1];\n  var node = state.node;\n  if (!state.doneCallee_) {\n    state.doneCallee_ = true;\n    this.stateStack.push({ node: node.callee, components: true });\n    return;\n  }\n  if (!state.func_) {\n    // Determine value of the function.\n    if (state.value.type == 'function') {\n      state.func_ = state.value;\n    } else {\n      state.func_ = this.getValue(state.value);\n      if (state.func_.isGetter) {\n        // Clear the getter flag and call the getter function.\n        state.func_.isGetter = false;\n        this.pushGetter_(state.func_, state.value);\n        state.func_ = null;\n        return;\n      }\n      if (!state.func_) {\n        return; // Thrown error, but trapped.\n      } else if (state.func_.type != 'function') {\n        this.throwException(this.TYPE_ERROR, (state.func_ && state.func_.type) + ' is not a function');\n        return;\n      }\n    }\n    // Determine value of 'this' in function.\n    if (state.node.type == 'NewExpression') {\n      // Constructor, 'this' is new object.\n      state.funcThis_ = this.createObject(state.func_);\n      state.isConstructor_ = true;\n    } else if (state.value.length) {\n      // Method function, 'this' is object.\n      state.funcThis_ = state.value[0];\n    } else {\n      // Global function, 'this' is global object (or 'undefined' if strict).\n      state.funcThis_ = this.getScope().strict ? this.UNDEFINED : this.global;\n    }\n    state.arguments_ = [];\n    state.n_ = 0;\n  }\n  if (!state.doneArgs_) {\n    if (state.n_ != 0) {\n      state.arguments_.push(state.value);\n    }\n    if (node.arguments[state.n_]) {\n      this.stateStack.push({ node: node.arguments[state.n_] });\n      state.n_++;\n      return;\n    }\n    state.doneArgs_ = true;\n  }\n  if (!state.doneExec_) {\n    state.doneExec_ = true;\n    if (state.func_.node) {\n      var scope = this.createScope(state.func_.node.body, state.func_.parentScope);\n      // Add all arguments.\n      for (var i = 0; i < state.func_.node.params.length; i++) {\n        var paramName = this.createPrimitive(state.func_.node.params[i].name);\n        var paramValue = state.arguments_.length > i ? state.arguments_[i] : this.UNDEFINED;\n        this.setProperty(scope, paramName, paramValue);\n      }\n      // Build arguments variable.\n      var argsList = this.createObject(this.ARRAY);\n      for (var i = 0; i < state.arguments_.length; i++) {\n        this.setProperty(argsList, this.createPrimitive(i), state.arguments_[i]);\n      }\n      this.setProperty(scope, 'arguments', argsList);\n      var funcState = {\n        node: state.func_.node.body,\n        scope: scope,\n        thisExpression: state.funcThis_\n      };\n      this.stateStack.push(funcState);\n      state.value = this.UNDEFINED; // Default value if no explicit return.\n    } else if (state.func_.nativeFunc) {\n      state.value = state.func_.nativeFunc.apply(state.funcThis_, state.arguments_);\n    } else if (state.func_.asyncFunc) {\n      var thisInterpreter = this;\n      var callback = function callback(value) {\n        state.value = value || thisInterpreter.UNDEFINED;\n        thisInterpreter.paused_ = false;\n      };\n      var argsWithCallback = state.arguments_.concat(callback);\n      state.func_.asyncFunc.apply(state.funcThis_, argsWithCallback);\n      this.paused_ = true;\n      return;\n    } else if (state.func_.eval) {\n      var code = state.arguments_[0];\n      if (!code) {\n        // eval()\n        state.value = this.UNDEFINED;\n      } else if (!code.isPrimitive) {\n        // JS does not parse String objects:\n        // eval(new String('1 + 1')) -> '1 + 1'\n        state.value = code;\n      } else {\n        var ast = acorn.parse(code.toString(), Interpreter.PARSE_OPTIONS);\n        state = {\n          node: {\n            type: 'EvalProgram_',\n            body: ast.body\n          }\n        };\n        this.stripLocations_(state.node, node.start, node.end);\n        // Update current scope with definitions in eval().\n        var scope = this.getScope();\n        this.populateScope_(ast, scope);\n        this.stateStack.push(state);\n      }\n    } else {\n      /* A child of a function is a function but is not callable.  For example:\n      var F = function() {};\n      F.prototype = escape;\n      var f = new F();\n      f();\n      */\n      this.throwException(this.TYPE_ERROR, 'function is not a function');\n    }\n  } else {\n    // Execution complete.  Put the return value on the stack.\n    this.stateStack.pop();\n    if (state.isConstructor_ && state.value.type !== 'object') {\n      this.stateStack[this.stateStack.length - 1].value = state.funcThis_;\n    } else {\n      this.stateStack[this.stateStack.length - 1].value = state.value;\n    }\n  }\n};\n\nInterpreter.prototype['stepCatchClause'] = function () {\n  var state = this.stateStack[this.stateStack.length - 1];\n  var node = state.node;\n  if (!state.done_) {\n    state.done_ = true;\n    var scope;\n    if (node.param) {\n      scope = this.createSpecialScope(this.getScope());\n      // Add the argument.\n      var paramName = this.createPrimitive(node.param.name);\n      this.setProperty(scope, paramName, state.throwValue);\n    }\n    this.stateStack.push({ node: node.body, scope: scope });\n  } else {\n    this.stateStack.pop();\n  }\n};\n\nInterpreter.prototype['stepConditionalExpression'] = function () {\n  var state = this.stateStack[this.stateStack.length - 1];\n  var mode = state.mode_ || 0;\n  if (mode == 0) {\n    state.mode_ = 1;\n    this.stateStack.push({ node: state.node.test });\n    return;\n  }\n  if (mode == 1) {\n    state.mode_ = 2;\n    var value = state.value.toBoolean();\n    if (value && state.node.consequent) {\n      this.stateStack.push({ node: state.node.consequent });\n      return; // Execute 'if' block.\n    } else if (!value && state.node.alternate) {\n      this.stateStack.push({ node: state.node.alternate });\n      return; // Execute 'else' block.\n    }\n    // eval('1;if(false){2}') -> undefined\n    this.value = this.UNDEFINED;\n  }\n  this.stateStack.pop();\n  if (state.node.type == 'ConditionalExpression') {\n    this.stateStack[this.stateStack.length - 1].value = state.value;\n  }\n};\n\nInterpreter.prototype['stepContinueStatement'] = function () {\n  var state = this.stateStack[this.stateStack.length - 1];\n  var label = null;\n  if (state.node.label) {\n    label = state.node.label.name;\n  }\n  while (state && state.node.type != 'CallExpression' && state.node.type != 'NewExpression') {\n    if (state.isLoop) {\n      if (!label || label == state.label) {\n        return;\n      }\n    }\n    this.stateStack.pop();\n    state = this.stateStack[this.stateStack.length - 1];\n  }\n  // Syntax error, do not allow this error to be trapped.\n  throw SyntaxError('Illegal continue statement');\n};\n\nInterpreter.prototype['stepDoWhileStatement'] = function () {\n  var state = this.stateStack[this.stateStack.length - 1];\n  if (state.node.type == 'DoWhileStatement' && state.test === undefined) {\n    // First iteration of do/while executes without checking test.\n    state.value = this.TRUE;\n    state.test_ = true;\n  }\n  if (!state.test_) {\n    state.test_ = true;\n    this.stateStack.push({ node: state.node.test });\n  } else {\n    if (!state.value.toBoolean()) {\n      // Done, exit loop.\n      this.stateStack.pop();\n    } else if (state.node.body) {\n      // Execute the body.\n      state.test_ = false;\n      state.isLoop = true;\n      this.stateStack.push({ node: state.node.body });\n    }\n  }\n};\n\nInterpreter.prototype['stepEmptyStatement'] = function () {\n  this.stateStack.pop();\n};\n\nInterpreter.prototype['stepEvalProgram_'] = function () {\n  var state = this.stateStack[this.stateStack.length - 1];\n  var node = state.node;\n  var n = state.n_ || 0;\n  if (node.body[n]) {\n    state.n_ = n + 1;\n    this.stateStack.push({ node: node.body[n] });\n  } else {\n    this.stateStack.pop();\n    this.stateStack[this.stateStack.length - 1].value = this.value;\n  }\n};\n\nInterpreter.prototype['stepExpressionStatement'] = function () {\n  var state = this.stateStack[this.stateStack.length - 1];\n  if (!state.done_) {\n    state.done_ = true;\n    this.stateStack.push({ node: state.node.expression });\n  } else {\n    this.stateStack.pop();\n    // Save this value to interpreter.value for use as a return value if\n    // this code is inside an eval function.\n    this.value = state.value;\n  }\n};\n\nInterpreter.prototype['stepForInStatement'] = function () {\n  var state = this.stateStack[this.stateStack.length - 1];\n  var node = state.node;\n  if (!state.doneVariable_) {\n    state.doneVariable_ = true;\n    var left = node.left;\n    if (left.type == 'VariableDeclaration') {\n      // Inline variable declaration: for (var x in y)\n      left = left.declarations[0].id;\n    }\n    this.stateStack.push({ node: left, components: true });\n    return;\n  }\n  if (!state.doneObject_) {\n    state.doneObject_ = true;\n    state.variable_ = state.value;\n    this.stateStack.push({ node: node.right });\n    return;\n  }\n  if (typeof state.iterator_ == 'undefined') {\n    // First iteration.\n    state.object_ = state.value;\n    state.iterator_ = 0;\n  }\n  var name = null;\n  done: do {\n    var i = state.iterator_;\n    for (var prop in state.object_.properties) {\n      if (state.object_.notEnumerable[prop]) {\n        continue;\n      }\n      if (i == 0) {\n        // Found the i'th enumerable property.\n        name = prop;\n        break done;\n      }\n      i--;\n    }\n    state.object_ = state.object_.parent && state.object_.parent.properties.prototype;\n    state.iterator_ = 0;\n  } while (state.object_);\n\n  if (name === null) {\n    // Done, exit loop.\n    this.stateStack.pop();\n  } else {\n    // Execute the body.\n    if (!state.doneSetter_) {\n      var value = this.createPrimitive(name);\n      var setter = this.setValue(state.variable_, value);\n      if (setter) {\n        state.doneSetter_ = true;\n        this.pushSetter_(setter, state.variable_, value);\n        return;\n      }\n    }\n    state.doneSetter_ = false;\n    if (node.body) {\n      state.isLoop = true;\n      this.stateStack.push({ node: node.body });\n    }\n    state.iterator_++;\n  }\n};\n\nInterpreter.prototype['stepForStatement'] = function () {\n  var state = this.stateStack[this.stateStack.length - 1];\n  var node = state.node;\n  var mode = state.mode_ || 0;\n  if (mode == 0) {\n    state.mode_ = 1;\n    if (node.init) {\n      this.stateStack.push({ node: node.init });\n    }\n  } else if (mode == 1) {\n    state.mode_ = 2;\n    if (node.test) {\n      this.stateStack.push({ node: node.test });\n    }\n  } else if (mode == 2) {\n    state.mode_ = 3;\n    if (node.test && state.value && !state.value.toBoolean()) {\n      // Done, exit loop.\n      this.stateStack.pop();\n    } else if (node.body) {\n      // Execute the body.\n      state.isLoop = true;\n      this.stateStack.push({ node: node.body });\n    }\n  } else if (mode == 3) {\n    state.mode_ = 1;\n    if (node.update) {\n      this.stateStack.push({ node: node.update });\n    }\n  }\n};\n\nInterpreter.prototype['stepFunctionDeclaration'] = function () {\n  // This was found and handled when the scope was populated.\n  this.stateStack.pop();\n};\n\nInterpreter.prototype['stepFunctionExpression'] = function () {\n  var state = this.stateStack.pop();\n  this.stateStack[this.stateStack.length - 1].value = this.createFunction(state.node, this.getScope());\n};\n\nInterpreter.prototype['stepIdentifier'] = function () {\n  var state = this.stateStack.pop();\n  var nameStr = state.node.name;\n  var name = this.createPrimitive(nameStr);\n  var value = state.components ? name : this.getValueFromScope(name);\n  // An identifier could be a getter if it's a property on the global object.\n  if (value && value.isGetter) {\n    // Clear the getter flag and call the getter function.\n    value.isGetter = false;\n    var scope = this.getScope();\n    while (!this.hasProperty(scope, nameStr)) {\n      scope = scope.parentScope;\n    }\n    var func = /** @type {!Interpreter.Object} */value;\n    this.pushGetter_(func, this.global);\n  } else {\n    this.stateStack[this.stateStack.length - 1].value = value;\n  }\n};\n\nInterpreter.prototype['stepIfStatement'] = Interpreter.prototype['stepConditionalExpression'];\n\nInterpreter.prototype['stepLabeledStatement'] = function () {\n  // No need to hit this node again on the way back up the stack.\n  var state = this.stateStack.pop();\n  this.stateStack.push({ node: state.node.body,\n    label: state.node.label.name });\n};\n\nInterpreter.prototype['stepLiteral'] = function () {\n  var state = this.stateStack.pop();\n  this.stateStack[this.stateStack.length - 1].value = this.createPrimitive(state.node.value);\n};\n\nInterpreter.prototype['stepLogicalExpression'] = function () {\n  var state = this.stateStack[this.stateStack.length - 1];\n  var node = state.node;\n  if (node.operator != '&&' && node.operator != '||') {\n    throw SyntaxError('Unknown logical operator: ' + node.operator);\n  }\n  if (!state.doneLeft_) {\n    state.doneLeft_ = true;\n    this.stateStack.push({ node: node.left });\n  } else if (!state.doneRight_) {\n    if (node.operator == '&&' && !state.value.toBoolean() || node.operator == '||' && state.value.toBoolean()) {\n      // Shortcut evaluation.\n      this.stateStack.pop();\n      this.stateStack[this.stateStack.length - 1].value = state.value;\n    } else {\n      state.doneRight_ = true;\n      this.stateStack.push({ node: node.right });\n    }\n  } else {\n    this.stateStack.pop();\n    this.stateStack[this.stateStack.length - 1].value = state.value;\n  }\n};\n\nInterpreter.prototype['stepMemberExpression'] = function () {\n  var state = this.stateStack[this.stateStack.length - 1];\n  var node = state.node;\n  if (!state.doneObject_) {\n    state.doneObject_ = true;\n    this.stateStack.push({ node: node.object });\n  } else if (!state.doneProperty_) {\n    state.doneProperty_ = true;\n    state.object_ = state.value;\n    this.stateStack.push({\n      node: node.property,\n      components: !node.computed\n    });\n  } else {\n    this.stateStack.pop();\n    if (state.components) {\n      this.stateStack[this.stateStack.length - 1].value = [state.object_, state.value];\n    } else {\n      var value = this.getProperty(state.object_, state.value);\n      if (!value) {\n        this.stateStack.push({});\n        this.throwException(this.TYPE_ERROR, \"Cannot read property '\" + state.value + \"' of \" + state.object_.toString());\n        return;\n      }\n      if (value.isGetter) {\n        // Clear the getter flag and call the getter function.\n        value.isGetter = false;\n        var func = /** @type {!Interpreter.Object} */value;\n        this.pushGetter_(func, state.object_);\n      } else {\n        this.stateStack[this.stateStack.length - 1].value = value;\n      }\n    }\n  }\n};\n\nInterpreter.prototype['stepNewExpression'] = Interpreter.prototype['stepCallExpression'];\n\nInterpreter.prototype['stepObjectExpression'] = function () {\n  var state = this.stateStack[this.stateStack.length - 1];\n  var node = state.node;\n  var valueToggle = state.valueToggle_;\n  var n = state.n_ || 0;\n  if (!state.object) {\n    state.object = this.createObject(this.OBJECT);\n    state.properties = Object.create(null);\n  } else {\n    if (valueToggle) {\n      state.key_ = state.value;\n    } else {\n      if (!state.properties[state.key_]) {\n        // Create temp object to collect value, getter, and/or setter.\n        state.properties[state.key_] = {};\n      }\n      state.properties[state.key_][state.kind_] = state.value;\n    }\n  }\n  if (node.properties[n]) {\n    if (valueToggle) {\n      state.n_ = n + 1;\n      this.stateStack.push({ node: node.properties[n].value });\n    } else {\n      state.kind_ = node.properties[n].kind;\n      this.stateStack.push({ node: node.properties[n].key, components: true });\n    }\n    state.valueToggle_ = !valueToggle;\n  } else {\n    for (var key in state.properties) {\n      var kinds = state.properties[key];\n      if ('get' in kinds || 'set' in kinds) {\n        // Set a property with a getter or setter.\n        var descriptor = {\n          configurable: true,\n          enumerable: true,\n          get: kinds['get'],\n          set: kinds['set']\n        };\n        this.setProperty(state.object, key, null, descriptor);\n      } else {\n        // Set a normal property with a value.\n        this.setProperty(state.object, key, kinds['init']);\n      }\n    }\n    this.stateStack.pop();\n    this.stateStack[this.stateStack.length - 1].value = state.object;\n  }\n};\n\nInterpreter.prototype['stepProgram'] = function () {\n  var state = this.stateStack[this.stateStack.length - 1];\n  var node = state.node;\n  var n = state.n_ || 0;\n  if (node.body[n]) {\n    state.done = false;\n    state.n_ = n + 1;\n    this.stateStack.push({ node: node.body[n] });\n  } else {\n    state.done = true;\n    // Don't pop the stateStack.\n    // Leave the root scope on the tree in case the program is appended to.\n  }\n};\n\nInterpreter.prototype['stepReturnStatement'] = function () {\n  var state = this.stateStack[this.stateStack.length - 1];\n  var node = state.node;\n  if (node.argument && !state.done_) {\n    state.done_ = true;\n    this.stateStack.push({ node: node.argument });\n  } else {\n    var value = state.value || this.UNDEFINED;\n    var i = this.stateStack.length - 1;\n    state = this.stateStack[i];\n    while (state.node.type != 'CallExpression' && state.node.type != 'NewExpression') {\n      if (state.node.type != 'TryStatement') {\n        this.stateStack.splice(i, 1);\n      }\n      i--;\n      if (i < 0) {\n        // Syntax error, do not allow this error to be trapped.\n        throw SyntaxError('Illegal return statement');\n      }\n      state = this.stateStack[i];\n    }\n    state.value = value;\n  }\n};\n\nInterpreter.prototype['stepSequenceExpression'] = function () {\n  var state = this.stateStack[this.stateStack.length - 1];\n  var node = state.node;\n  var n = state.n_ || 0;\n  if (node.expressions[n]) {\n    state.n_ = n + 1;\n    this.stateStack.push({ node: node.expressions[n] });\n  } else {\n    this.stateStack.pop();\n    this.stateStack[this.stateStack.length - 1].value = state.value;\n  }\n};\n\nInterpreter.prototype['stepSwitchStatement'] = function () {\n  var state = this.stateStack[this.stateStack.length - 1];\n\n  if (!state.test_) {\n    state.test_ = true;\n    this.stateStack.push({ node: state.node.discriminant });\n    return;\n  }\n  if (!state.switchValue_) {\n    // Preserve switch value between case tests.\n    state.switchValue_ = state.value;\n    state.checked_ = [];\n  }\n\n  var index = state.index_ || 0;\n  var switchCase = state.node.cases[index];\n  if (switchCase) {\n    if (!state.done_ && !state.checked_[index] && switchCase.test) {\n      state.checked_[index] = true;\n      this.stateStack.push({ node: switchCase.test });\n      return;\n    }\n    // Test on the default case will be null.\n    if (state.done_ || !switchCase.test || this.comp(state.value, state.switchValue_) == 0) {\n      state.done_ = true;\n      var n = state.n_ || 0;\n      if (switchCase.consequent[n]) {\n        state.isSwitch = true;\n        this.stateStack.push({ node: switchCase.consequent[n] });\n        state.n_ = n + 1;\n        return;\n      }\n    }\n    state.n_ = 0;\n    state.index_ = index + 1;\n  } else {\n    this.stateStack.pop();\n  }\n};\n\nInterpreter.prototype['stepThisExpression'] = function () {\n  this.stateStack.pop();\n  for (var i = this.stateStack.length - 1; i >= 0; i--) {\n    if (this.stateStack[i].thisExpression) {\n      this.stateStack[this.stateStack.length - 1].value = this.stateStack[i].thisExpression;\n      return;\n    }\n  }\n  throw Error('No this expression found.');\n};\n\nInterpreter.prototype['stepThrowStatement'] = function () {\n  var state = this.stateStack[this.stateStack.length - 1];\n  var node = state.node;\n  if (!state.done_) {\n    state.done_ = true;\n    this.stateStack.push({ node: node.argument });\n  } else {\n    this.throwException(state.value);\n  }\n};\n\nInterpreter.prototype['stepTryStatement'] = function () {\n  var state = this.stateStack[this.stateStack.length - 1];\n  var node = state.node;\n  if (!state.doneBlock_) {\n    state.doneBlock_ = true;\n    this.stateStack.push({ node: node.block });\n  } else if (state.throwValue && !state.doneHandler_ && node.handler) {\n    state.doneHandler_ = true;\n    this.stateStack.push({ node: node.handler, throwValue: state.throwValue });\n    state.throwValue = null; // This error has been handled, don't rethrow.\n  } else if (!state.doneFinalizer_ && node.finalizer) {\n    state.doneFinalizer_ = true;\n    this.stateStack.push({ node: node.finalizer });\n  } else if (state.throwValue) {\n    // There was no catch handler, or the catch/finally threw an error.\n    // Throw the error up to a higher try.\n    this.executeException(state.throwValue);\n  } else {\n    this.stateStack.pop();\n  }\n};\n\nInterpreter.prototype['stepUnaryExpression'] = function () {\n  var state = this.stateStack[this.stateStack.length - 1];\n  var node = state.node;\n  if (!state.done_) {\n    state.done_ = true;\n    var nextState = {\n      node: node.argument,\n      components: node.operator == 'delete'\n    };\n    this.stateStack.push(nextState);\n    return;\n  }\n  this.stateStack.pop();\n  var value = state.value;\n  if (node.operator == '-') {\n    value = -value.toNumber();\n  } else if (node.operator == '+') {\n    value = value.toNumber();\n  } else if (node.operator == '!') {\n    value = !value.toBoolean();\n  } else if (node.operator == '~') {\n    value = ~value.toNumber();\n  } else if (node.operator == 'delete') {\n    if (value.length) {\n      var obj = value[0];\n      var name = value[1];\n    } else {\n      var obj = this.getScope();\n      var name = value;\n    }\n    value = this.deleteProperty(obj, name);\n    if (!value && this.getScope().strict) {\n      this.throwException(this.TYPE_ERROR, 'Cannot delete property \\'' + name + '\\' of \\'' + obj + '\\'');\n      return;\n    }\n  } else if (node.operator == 'typeof') {\n    value = value.type;\n  } else if (node.operator == 'void') {\n    value = undefined;\n  } else {\n    throw SyntaxError('Unknown unary operator: ' + node.operator);\n  }\n  this.stateStack[this.stateStack.length - 1].value = this.createPrimitive(value);\n};\n\nInterpreter.prototype['stepUpdateExpression'] = function () {\n  var state = this.stateStack[this.stateStack.length - 1];\n  var node = state.node;\n  if (!state.doneLeft_) {\n    state.doneLeft_ = true;\n    this.stateStack.push({ node: node.argument, components: true });\n    return;\n  }\n  if (!state.leftSide_) {\n    state.leftSide_ = state.value;\n  }\n  if (state.doneGetter_) {\n    state.leftValue_ = state.value;\n  }\n  if (!state.doneGetter_) {\n    state.leftValue_ = this.getValue(state.leftSide_);\n    if (!state.leftValue_) {\n      return; // Thrown error, but trapped.\n    }\n    if (state.leftValue_.isGetter) {\n      // Clear the getter flag and call the getter function.\n      state.leftValue_.isGetter = false;\n      state.doneGetter_ = true;\n      var func = /** @type {!Interpreter.Object} */state.leftValue_;\n      this.pushGetter_(func, state.leftSide_);\n      return;\n    }\n  }\n  if (state.doneSetter_) {\n    // Return if setter function.\n    // Setter method on property has completed.\n    // Ignore its return value, and use the original set value instead.\n    this.stateStack.pop();\n    this.stateStack[this.stateStack.length - 1].value = state.doneSetter_;\n    return;\n  }\n  var leftValue = state.leftValue_.toNumber();\n  var changeValue;\n  if (node.operator == '++') {\n    changeValue = this.createPrimitive(leftValue + 1);\n  } else if (node.operator == '--') {\n    changeValue = this.createPrimitive(leftValue - 1);\n  } else {\n    throw SyntaxError('Unknown update expression: ' + node.operator);\n  }\n  var returnValue = node.prefix ? changeValue : this.createPrimitive(leftValue);\n  var setter = this.setValue(state.leftSide_, changeValue);\n  if (setter) {\n    state.doneSetter_ = returnValue;\n    this.pushSetter_(setter, state.leftSide_, changeValue);\n    return;\n  }\n  // Return if no setter function.\n  this.stateStack.pop();\n  this.stateStack[this.stateStack.length - 1].value = returnValue;\n};\n\nInterpreter.prototype['stepVariableDeclaration'] = function () {\n  var state = this.stateStack[this.stateStack.length - 1];\n  var node = state.node;\n  var n = state.n_ || 0;\n  var declarationNode = node.declarations[n];\n  if (state.value && declarationNode) {\n    // This setValue call never needs to deal with calling a setter function.\n    this.setValue(this.createPrimitive(declarationNode.id.name), state.value);\n    state.value = null;\n    declarationNode = node.declarations[++n];\n  }\n  while (declarationNode) {\n    // Skip any declarations that are not initialized.  They have already\n    // been defined as undefined in populateScope_.\n    if (declarationNode.init) {\n      state.n_ = n;\n      this.stateStack.push({ node: declarationNode.init });\n      return;\n    }\n    declarationNode = node.declarations[++n];\n  }\n  this.stateStack.pop();\n};\n\nInterpreter.prototype['stepWithStatement'] = function () {\n  var state = this.stateStack[this.stateStack.length - 1];\n  var node = state.node;\n  if (!state.doneObject_) {\n    state.doneObject_ = true;\n    this.stateStack.push({ node: node.object });\n  } else if (!state.doneBody_) {\n    state.doneBody_ = true;\n    var scope = this.createSpecialScope(this.getScope(), state.value);\n    this.stateStack.push({ node: node.body, scope: scope });\n  } else {\n    this.stateStack.pop();\n  }\n};\n\nInterpreter.prototype['stepWhileStatement'] = Interpreter.prototype['stepDoWhileStatement'];\n\n// Preserve top-level API functions from being pruned by JS compilers.\n// Add others as needed.\nif (typeof window !== 'undefined') {\n  window.Interpreter = Interpreter;\n}\nInterpreter.prototype['appendCode'] = Interpreter.prototype.appendCode;\nInterpreter.prototype['createAsyncFunction'] = Interpreter.prototype.createAsyncFunction;\nInterpreter.prototype['step'] = Interpreter.prototype.step;\nInterpreter.prototype['run'] = Interpreter.prototype.run;\n\nmodule.exports = Interpreter;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n(function (global, factory) {\n   true ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.acorn = global.acorn || {})));\n}(this, (function (exports) { 'use strict';\n\n// Reserved word lists for various dialects of the language\n\nvar reservedWords = {\n  3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n  5: \"class enum extends super const export import\",\n  6: \"enum\",\n  strict: \"implements interface let package private protected public static yield\",\n  strictBind: \"eval arguments\"\n}\n\n// And the keywords\n\nvar ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\"\n\nvar keywords = {\n  5: ecma5AndLessKeywords,\n  6: ecma5AndLessKeywords + \" const class extends export import super\"\n}\n\n// ## Character categories\n\n// Big ugly regular expressions that match characters in the\n// whitespace, identifier, and identifier-start categories. These\n// are only applied when a character is found to actually have a\n// code point above 128.\n// Generated by `bin/generate-identifier-regex.js`.\n\nvar nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05d0-\\u05ea\\u05f0-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u08a0-\\u08b4\\u08b6-\\u08bd\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1877\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312d\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fd5\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7ae\\ua7b0-\\ua7b7\\ua7f7-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab65\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\"\nvar nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08d4-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c03\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d01-\\u0d03\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf2-\\u1cf4\\u1cf8\\u1cf9\\u1dc0-\\u1df5\\u1dfb-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua900-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\"\n\nvar nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\")\nvar nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\")\n\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null\n\n// These are a run-length and offset encoded representation of the\n// >0xffff code points that are a valid part of identifiers. The\n// offset starts at 0x10000, and each pair of numbers represents an\n// offset to the next range, and then a size of the range. They were\n// generated by bin/generate-identifier-regex.js\nvar astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,17,26,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,26,45,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,785,52,76,44,33,24,27,35,42,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,54,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,86,25,391,63,32,0,449,56,264,8,2,36,18,0,50,29,881,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,881,68,12,0,67,12,65,0,32,6124,20,754,9486,1,3071,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,4149,196,60,67,1213,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,10591,541]\nvar astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,1306,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,52,0,13,2,49,13,10,2,4,9,83,11,7,0,161,11,6,9,7,3,57,0,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,87,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,423,9,838,7,2,7,17,9,57,21,2,13,19882,9,135,4,60,6,26,9,1016,45,17,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,2214,6,110,6,6,9,792487,239]\n\n// This has a complexity linear to the value of the code. The\n// assumption is that looking up astral identifier characters is\n// rare.\nfunction isInAstralSet(code, set) {\n  var pos = 0x10000\n  for (var i = 0; i < set.length; i += 2) {\n    pos += set[i]\n    if (pos > code) return false\n    pos += set[i + 1]\n    if (pos >= code) return true\n  }\n}\n\n// Test whether a given character code starts an identifier.\n\nfunction isIdentifierStart(code, astral) {\n  if (code < 65) return code === 36\n  if (code < 91) return true\n  if (code < 97) return code === 95\n  if (code < 123) return true\n  if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code))\n  if (astral === false) return false\n  return isInAstralSet(code, astralIdentifierStartCodes)\n}\n\n// Test whether a given character is part of an identifier.\n\nfunction isIdentifierChar(code, astral) {\n  if (code < 48) return code === 36\n  if (code < 58) return true\n  if (code < 65) return false\n  if (code < 91) return true\n  if (code < 97) return code === 95\n  if (code < 123) return true\n  if (code <= 0xffff) return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code))\n  if (astral === false) return false\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)\n}\n\n// ## Token types\n\n// The assignment of fine-grained, information-carrying type objects\n// allows the tokenizer to store the information it has about a\n// token in a way that is very cheap for the parser to look up.\n\n// All token type variables start with an underscore, to make them\n// easy to recognize.\n\n// The `beforeExpr` property is used to disambiguate between regular\n// expressions and divisions. It is set on all token types that can\n// be followed by an expression (thus, a slash after them would be a\n// regular expression).\n//\n// The `startsExpr` property is used to check if the token ends a\n// `yield` expression. It is set on all token types that either can\n// directly start an expression (like a quotation mark) or can\n// continue an expression (like the body of a string).\n//\n// `isLoop` marks a keyword as starting a loop, which is important\n// to know when parsing a label, in order to allow or disallow\n// continue jumps to that label.\n\nvar TokenType = function TokenType(label, conf) {\n  if ( conf === void 0 ) conf = {};\n\n  this.label = label\n  this.keyword = conf.keyword\n  this.beforeExpr = !!conf.beforeExpr\n  this.startsExpr = !!conf.startsExpr\n  this.isLoop = !!conf.isLoop\n  this.isAssign = !!conf.isAssign\n  this.prefix = !!conf.prefix\n  this.postfix = !!conf.postfix\n  this.binop = conf.binop || null\n  this.updateContext = null\n};\n\nfunction binop(name, prec) {\n  return new TokenType(name, {beforeExpr: true, binop: prec})\n}\nvar beforeExpr = {beforeExpr: true};\nvar startsExpr = {startsExpr: true};\n// Map keyword names to token types.\n\nvar keywordTypes = {}\n\n// Succinct definitions of keyword token types\nfunction kw(name, options) {\n  if ( options === void 0 ) options = {};\n\n  options.keyword = name\n  return keywordTypes[name] = new TokenType(name, options)\n}\n\nvar tt = {\n  num: new TokenType(\"num\", startsExpr),\n  regexp: new TokenType(\"regexp\", startsExpr),\n  string: new TokenType(\"string\", startsExpr),\n  name: new TokenType(\"name\", startsExpr),\n  eof: new TokenType(\"eof\"),\n\n  // Punctuation token types.\n  bracketL: new TokenType(\"[\", {beforeExpr: true, startsExpr: true}),\n  bracketR: new TokenType(\"]\"),\n  braceL: new TokenType(\"{\", {beforeExpr: true, startsExpr: true}),\n  braceR: new TokenType(\"}\"),\n  parenL: new TokenType(\"(\", {beforeExpr: true, startsExpr: true}),\n  parenR: new TokenType(\")\"),\n  comma: new TokenType(\",\", beforeExpr),\n  semi: new TokenType(\";\", beforeExpr),\n  colon: new TokenType(\":\", beforeExpr),\n  dot: new TokenType(\".\"),\n  question: new TokenType(\"?\", beforeExpr),\n  arrow: new TokenType(\"=>\", beforeExpr),\n  template: new TokenType(\"template\"),\n  ellipsis: new TokenType(\"...\", beforeExpr),\n  backQuote: new TokenType(\"`\", startsExpr),\n  dollarBraceL: new TokenType(\"${\", {beforeExpr: true, startsExpr: true}),\n\n  // Operators. These carry several kinds of properties to help the\n  // parser use them properly (the presence of these properties is\n  // what categorizes them as operators).\n  //\n  // `binop`, when present, specifies that this operator is a binary\n  // operator, and will refer to its precedence.\n  //\n  // `prefix` and `postfix` mark the operator as a prefix or postfix\n  // unary operator.\n  //\n  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n  // binary operators with a very low precedence, that should result\n  // in AssignmentExpression nodes.\n\n  eq: new TokenType(\"=\", {beforeExpr: true, isAssign: true}),\n  assign: new TokenType(\"_=\", {beforeExpr: true, isAssign: true}),\n  incDec: new TokenType(\"++/--\", {prefix: true, postfix: true, startsExpr: true}),\n  prefix: new TokenType(\"prefix\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  logicalOR: binop(\"||\", 1),\n  logicalAND: binop(\"&&\", 2),\n  bitwiseOR: binop(\"|\", 3),\n  bitwiseXOR: binop(\"^\", 4),\n  bitwiseAND: binop(\"&\", 5),\n  equality: binop(\"==/!=\", 6),\n  relational: binop(\"</>\", 7),\n  bitShift: binop(\"<</>>\", 8),\n  plusMin: new TokenType(\"+/-\", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),\n  modulo: binop(\"%\", 10),\n  star: binop(\"*\", 10),\n  slash: binop(\"/\", 10),\n  starstar: new TokenType(\"**\", {beforeExpr: true}),\n\n  // Keyword token types.\n  _break: kw(\"break\"),\n  _case: kw(\"case\", beforeExpr),\n  _catch: kw(\"catch\"),\n  _continue: kw(\"continue\"),\n  _debugger: kw(\"debugger\"),\n  _default: kw(\"default\", beforeExpr),\n  _do: kw(\"do\", {isLoop: true, beforeExpr: true}),\n  _else: kw(\"else\", beforeExpr),\n  _finally: kw(\"finally\"),\n  _for: kw(\"for\", {isLoop: true}),\n  _function: kw(\"function\", startsExpr),\n  _if: kw(\"if\"),\n  _return: kw(\"return\", beforeExpr),\n  _switch: kw(\"switch\"),\n  _throw: kw(\"throw\", beforeExpr),\n  _try: kw(\"try\"),\n  _var: kw(\"var\"),\n  _const: kw(\"const\"),\n  _while: kw(\"while\", {isLoop: true}),\n  _with: kw(\"with\"),\n  _new: kw(\"new\", {beforeExpr: true, startsExpr: true}),\n  _this: kw(\"this\", startsExpr),\n  _super: kw(\"super\", startsExpr),\n  _class: kw(\"class\"),\n  _extends: kw(\"extends\", beforeExpr),\n  _export: kw(\"export\"),\n  _import: kw(\"import\"),\n  _null: kw(\"null\", startsExpr),\n  _true: kw(\"true\", startsExpr),\n  _false: kw(\"false\", startsExpr),\n  _in: kw(\"in\", {beforeExpr: true, binop: 7}),\n  _instanceof: kw(\"instanceof\", {beforeExpr: true, binop: 7}),\n  _typeof: kw(\"typeof\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  _void: kw(\"void\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  _delete: kw(\"delete\", {beforeExpr: true, prefix: true, startsExpr: true})\n}\n\n// Matches a whole line break (where CRLF is considered a single\n// line break). Used to count lines.\n\nvar lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/\nvar lineBreakG = new RegExp(lineBreak.source, \"g\")\n\nfunction isNewLine(code) {\n  return code === 10 || code === 13 || code === 0x2028 || code === 0x2029\n}\n\nvar nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/\n\nvar skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g\n\nfunction isArray(obj) {\n  return Object.prototype.toString.call(obj) === \"[object Array]\"\n}\n\n// Checks if an object has a property.\n\nfunction has(obj, propName) {\n  return Object.prototype.hasOwnProperty.call(obj, propName)\n}\n\n// These are used when `options.locations` is on, for the\n// `startLoc` and `endLoc` properties.\n\nvar Position = function Position(line, col) {\n  this.line = line\n  this.column = col\n};\n\nPosition.prototype.offset = function offset (n) {\n  return new Position(this.line, this.column + n)\n};\n\nvar SourceLocation = function SourceLocation(p, start, end) {\n  this.start = start\n  this.end = end\n  if (p.sourceFile !== null) this.source = p.sourceFile\n};\n\n// The `getLineInfo` function is mostly useful when the\n// `locations` option is off (for performance reasons) and you\n// want to find the line/column position for a given character\n// offset. `input` should be the code string that the offset refers\n// into.\n\nfunction getLineInfo(input, offset) {\n  for (var line = 1, cur = 0;;) {\n    lineBreakG.lastIndex = cur\n    var match = lineBreakG.exec(input)\n    if (match && match.index < offset) {\n      ++line\n      cur = match.index + match[0].length\n    } else {\n      return new Position(line, offset - cur)\n    }\n  }\n}\n\n// A second optional argument can be given to further configure\n// the parser process. These options are recognized:\n\nvar defaultOptions = {\n  // `ecmaVersion` indicates the ECMAScript version to parse. Must\n  // be either 3, 5, 6 (2015), 7 (2016), or 8 (2017). This influences support\n  // for strict mode, the set of reserved words, and support for\n  // new syntax features. The default is 7.\n  ecmaVersion: 7,\n  // `sourceType` indicates the mode the code should be parsed in.\n  // Can be either `\"script\"` or `\"module\"`. This influences global\n  // strict mode and parsing of `import` and `export` declarations.\n  sourceType: \"script\",\n  // `onInsertedSemicolon` can be a callback that will be called\n  // when a semicolon is automatically inserted. It will be passed\n  // th position of the comma as an offset, and if `locations` is\n  // enabled, it is given the location as a `{line, column}` object\n  // as second argument.\n  onInsertedSemicolon: null,\n  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n  // trailing commas.\n  onTrailingComma: null,\n  // By default, reserved words are only enforced if ecmaVersion >= 5.\n  // Set `allowReserved` to a boolean value to explicitly turn this on\n  // an off. When this option has the value \"never\", reserved words\n  // and keywords can also not be used as property names.\n  allowReserved: null,\n  // When enabled, a return at the top level is not considered an\n  // error.\n  allowReturnOutsideFunction: false,\n  // When enabled, import/export statements are not constrained to\n  // appearing at the top of the program.\n  allowImportExportEverywhere: false,\n  // When enabled, hashbang directive in the beginning of file\n  // is allowed and treated as a line comment.\n  allowHashBang: false,\n  // When `locations` is on, `loc` properties holding objects with\n  // `start` and `end` properties in `{line, column}` form (with\n  // line being 1-based and column 0-based) will be attached to the\n  // nodes.\n  locations: false,\n  // A function can be passed as `onToken` option, which will\n  // cause Acorn to call that function with object in the same\n  // format as tokens returned from `tokenizer().getToken()`. Note\n  // that you are not allowed to call the parser from the\n  // callbackthat will corrupt its internal state.\n  onToken: null,\n  // A function can be passed as `onComment` option, which will\n  // cause Acorn to call that function with `(block, text, start,\n  // end)` parameters whenever a comment is skipped. `block` is a\n  // boolean indicating whether this is a block (`/* */`) comment,\n  // `text` is the content of the comment, and `start` and `end` are\n  // character offsets that denote the start and end of the comment.\n  // When the `locations` option is on, two more parameters are\n  // passed, the full `{line, column}` locations of the start and\n  // end of the comments. Note that you are not allowed to call the\n  // parser from the callbackthat will corrupt its internal state.\n  onComment: null,\n  // Nodes have their start and end characters offsets recorded in\n  // `start` and `end` properties (directly on the node, rather than\n  // the `loc` object, which holds line/column data. To also add a\n  // [semi-standardized][range] `range` property holding a `[start,\n  // end]` array with the same numbers, set the `ranges` option to\n  // `true`.\n  //\n  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n  ranges: false,\n  // It is possible to parse multiple files into a single AST by\n  // passing the tree produced by parsing the first file as\n  // `program` option in subsequent parses. This will add the\n  // toplevel forms of the parsed file to the `Program` (top) node\n  // of an existing parse tree.\n  program: null,\n  // When `locations` is on, you can pass this to record the source\n  // file in every node's `loc` object.\n  sourceFile: null,\n  // This value, if given, is stored in every node, whether\n  // `locations` is on or off.\n  directSourceFile: null,\n  // When enabled, parenthesized expressions are represented by\n  // (non-standard) ParenthesizedExpression nodes\n  preserveParens: false,\n  plugins: {}\n}\n\n// Interpret and default an options object\n\nfunction getOptions(opts) {\n  var options = {}\n\n  for (var opt in defaultOptions)\n    options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]\n\n  if (options.ecmaVersion >= 2015)\n    options.ecmaVersion -= 2009\n\n  if (options.allowReserved == null)\n    options.allowReserved = options.ecmaVersion < 5\n\n  if (isArray(options.onToken)) {\n    var tokens = options.onToken\n    options.onToken = function (token) { return tokens.push(token); }\n  }\n  if (isArray(options.onComment))\n    options.onComment = pushComment(options, options.onComment)\n\n  return options\n}\n\nfunction pushComment(options, array) {\n  return function (block, text, start, end, startLoc, endLoc) {\n    var comment = {\n      type: block ? 'Block' : 'Line',\n      value: text,\n      start: start,\n      end: end\n    }\n    if (options.locations)\n      comment.loc = new SourceLocation(this, startLoc, endLoc)\n    if (options.ranges)\n      comment.range = [start, end]\n    array.push(comment)\n  }\n}\n\n// Registered plugins\nvar plugins = {}\n\nfunction keywordRegexp(words) {\n  return new RegExp(\"^(\" + words.replace(/ /g, \"|\") + \")$\")\n}\n\nvar Parser = function Parser(options, input, startPos) {\n  this.options = options = getOptions(options)\n  this.sourceFile = options.sourceFile\n  this.keywords = keywordRegexp(keywords[options.ecmaVersion >= 6 ? 6 : 5])\n  var reserved = \"\"\n  if (!options.allowReserved) {\n    for (var v = options.ecmaVersion;; v--)\n      if (reserved = reservedWords[v]) break\n    if (options.sourceType == \"module\") reserved += \" await\"\n  }\n  this.reservedWords = keywordRegexp(reserved)\n  var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict\n  this.reservedWordsStrict = keywordRegexp(reservedStrict)\n  this.reservedWordsStrictBind = keywordRegexp(reservedStrict + \" \" + reservedWords.strictBind)\n  this.input = String(input)\n\n  // Used to signal to callers of `readWord1` whether the word\n  // contained any escape sequences. This is needed because words with\n  // escape sequences must not be interpreted as keywords.\n  this.containsEsc = false\n\n  // Load plugins\n  this.loadPlugins(options.plugins)\n\n  // Set up token state\n\n  // The current position of the tokenizer in the input.\n  if (startPos) {\n    this.pos = startPos\n    this.lineStart = this.input.lastIndexOf(\"\\n\", startPos - 1) + 1\n    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length\n  } else {\n    this.pos = this.lineStart = 0\n    this.curLine = 1\n  }\n\n  // Properties of the current token:\n  // Its type\n  this.type = tt.eof\n  // For tokens that include more information than their type, the value\n  this.value = null\n  // Its start and end offset\n  this.start = this.end = this.pos\n  // And, if locations are used, the {line, column} object\n  // corresponding to those offsets\n  this.startLoc = this.endLoc = this.curPosition()\n\n  // Position information for the previous token\n  this.lastTokEndLoc = this.lastTokStartLoc = null\n  this.lastTokStart = this.lastTokEnd = this.pos\n\n  // The context stack is used to superficially track syntactic\n  // context to predict whether a regular expression is allowed in a\n  // given position.\n  this.context = this.initialContext()\n  this.exprAllowed = true\n\n  // Figure out if it's a module code.\n  this.inModule = options.sourceType === \"module\"\n  this.strict = this.inModule || this.strictDirective(this.pos)\n\n  // Used to signify the start of a potential arrow function\n  this.potentialArrowAt = -1\n\n  // Flags to track whether we are in a function, a generator, an async function.\n  this.inFunction = this.inGenerator = this.inAsync = false\n  // Positions to delayed-check that yield/await does not exist in default parameters.\n  this.yieldPos = this.awaitPos = 0\n  // Labels in scope.\n  this.labels = []\n\n  // If enabled, skip leading hashbang line.\n  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === '#!')\n    this.skipLineComment(2)\n};\n\n// DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them\nParser.prototype.isKeyword = function isKeyword (word) { return this.keywords.test(word) };\nParser.prototype.isReservedWord = function isReservedWord (word) { return this.reservedWords.test(word) };\n\nParser.prototype.extend = function extend (name, f) {\n  this[name] = f(this[name])\n};\n\nParser.prototype.loadPlugins = function loadPlugins (pluginConfigs) {\n    var this$1 = this;\n\n  for (var name in pluginConfigs) {\n    var plugin = plugins[name]\n    if (!plugin) throw new Error(\"Plugin '\" + name + \"' not found\")\n    plugin(this$1, pluginConfigs[name])\n  }\n};\n\nParser.prototype.parse = function parse () {\n  var node = this.options.program || this.startNode()\n  this.nextToken()\n  return this.parseTopLevel(node)\n};\n\nvar pp = Parser.prototype\n\n// ## Parser utilities\n\nvar literal = /^(?:'((?:[^\\']|\\.)*)'|\"((?:[^\\\"]|\\.)*)\"|;)/\npp.strictDirective = function(start) {\n  var this$1 = this;\n\n  for (;;) {\n    skipWhiteSpace.lastIndex = start\n    start += skipWhiteSpace.exec(this$1.input)[0].length\n    var match = literal.exec(this$1.input.slice(start))\n    if (!match) return false\n    if ((match[1] || match[2]) == \"use strict\") return true\n    start += match[0].length\n  }\n}\n\n// Predicate that tests whether the next token is of the given\n// type, and if yes, consumes it as a side effect.\n\npp.eat = function(type) {\n  if (this.type === type) {\n    this.next()\n    return true\n  } else {\n    return false\n  }\n}\n\n// Tests whether parsed token is a contextual keyword.\n\npp.isContextual = function(name) {\n  return this.type === tt.name && this.value === name\n}\n\n// Consumes contextual keyword if possible.\n\npp.eatContextual = function(name) {\n  return this.value === name && this.eat(tt.name)\n}\n\n// Asserts that following token is given contextual keyword.\n\npp.expectContextual = function(name) {\n  if (!this.eatContextual(name)) this.unexpected()\n}\n\n// Test whether a semicolon can be inserted at the current position.\n\npp.canInsertSemicolon = function() {\n  return this.type === tt.eof ||\n    this.type === tt.braceR ||\n    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n}\n\npp.insertSemicolon = function() {\n  if (this.canInsertSemicolon()) {\n    if (this.options.onInsertedSemicolon)\n      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc)\n    return true\n  }\n}\n\n// Consume a semicolon, or, failing that, see if we are allowed to\n// pretend that there is a semicolon at this position.\n\npp.semicolon = function() {\n  if (!this.eat(tt.semi) && !this.insertSemicolon()) this.unexpected()\n}\n\npp.afterTrailingComma = function(tokType, notNext) {\n  if (this.type == tokType) {\n    if (this.options.onTrailingComma)\n      this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc)\n    if (!notNext)\n      this.next()\n    return true\n  }\n}\n\n// Expect a token of a given type. If found, consume it, otherwise,\n// raise an unexpected token error.\n\npp.expect = function(type) {\n  this.eat(type) || this.unexpected()\n}\n\n// Raise an unexpected token error.\n\npp.unexpected = function(pos) {\n  this.raise(pos != null ? pos : this.start, \"Unexpected token\")\n}\n\nvar DestructuringErrors = function DestructuringErrors() {\n  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = -1\n};\n\npp.checkPatternErrors = function(refDestructuringErrors, isAssign) {\n  if (!refDestructuringErrors) return\n  if (refDestructuringErrors.trailingComma > -1)\n    this.raiseRecoverable(refDestructuringErrors.trailingComma, \"Comma is not permitted after the rest element\")\n  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind\n  if (parens > -1) this.raiseRecoverable(parens, \"Parenthesized pattern\")\n}\n\npp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {\n  var pos = refDestructuringErrors ? refDestructuringErrors.shorthandAssign : -1\n  if (!andThrow) return pos >= 0\n  if (pos > -1) this.raise(pos, \"Shorthand property assignments are valid only in destructuring patterns\")\n}\n\npp.checkYieldAwaitInDefaultParams = function() {\n  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))\n    this.raise(this.yieldPos, \"Yield expression cannot be a default value\")\n  if (this.awaitPos)\n    this.raise(this.awaitPos, \"Await expression cannot be a default value\")\n}\n\npp.isSimpleAssignTarget = function(expr) {\n  if (expr.type === \"ParenthesizedExpression\")\n    return this.isSimpleAssignTarget(expr.expression)\n  return expr.type === \"Identifier\" || expr.type === \"MemberExpression\"\n}\n\nvar pp$1 = Parser.prototype\n\n// ### Statement parsing\n\n// Parse a program. Initializes the parser, reads any number of\n// statements, and wraps them in a Program node.  Optionally takes a\n// `program` argument.  If present, the statements will be appended\n// to its body instead of creating a new node.\n\npp$1.parseTopLevel = function(node) {\n  var this$1 = this;\n\n  var exports = {}\n  if (!node.body) node.body = []\n  while (this.type !== tt.eof) {\n    var stmt = this$1.parseStatement(true, true, exports)\n    node.body.push(stmt)\n  }\n  this.next()\n  if (this.options.ecmaVersion >= 6) {\n    node.sourceType = this.options.sourceType\n  }\n  return this.finishNode(node, \"Program\")\n}\n\nvar loopLabel = {kind: \"loop\"};\nvar switchLabel = {kind: \"switch\"};\npp$1.isLet = function() {\n  if (this.type !== tt.name || this.options.ecmaVersion < 6 || this.value != \"let\") return false\n  skipWhiteSpace.lastIndex = this.pos\n  var skip = skipWhiteSpace.exec(this.input)\n  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next)\n  if (nextCh === 91 || nextCh == 123) return true // '{' and '['\n  if (isIdentifierStart(nextCh, true)) {\n    for (var pos = next + 1; isIdentifierChar(this.input.charCodeAt(pos), true); ++pos) {}\n    var ident = this.input.slice(next, pos)\n    if (!this.isKeyword(ident)) return true\n  }\n  return false\n}\n\n// check 'async [no LineTerminator here] function'\n// - 'async /*foo*/ function' is OK.\n// - 'async /*\\n*/ function' is invalid.\npp$1.isAsyncFunction = function() {\n  if (this.type !== tt.name || this.options.ecmaVersion < 8 || this.value != \"async\")\n    return false\n\n  skipWhiteSpace.lastIndex = this.pos\n  var skip = skipWhiteSpace.exec(this.input)\n  var next = this.pos + skip[0].length\n  return !lineBreak.test(this.input.slice(this.pos, next)) &&\n    this.input.slice(next, next + 8) === \"function\" &&\n    (next + 8 == this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))\n}\n\n// Parse a single statement.\n//\n// If expecting a statement and finding a slash operator, parse a\n// regular expression literal. This is to handle cases like\n// `if (foo) /blah/.exec(foo)`, where looking at the previous token\n// does not help.\n\npp$1.parseStatement = function(declaration, topLevel, exports) {\n  var starttype = this.type, node = this.startNode(), kind\n\n  if (this.isLet()) {\n    starttype = tt._var\n    kind = \"let\"\n  }\n\n  // Most types of statements are recognized by the keyword they\n  // start with. Many are trivial to parse, some require a bit of\n  // complexity.\n\n  switch (starttype) {\n  case tt._break: case tt._continue: return this.parseBreakContinueStatement(node, starttype.keyword)\n  case tt._debugger: return this.parseDebuggerStatement(node)\n  case tt._do: return this.parseDoStatement(node)\n  case tt._for: return this.parseForStatement(node)\n  case tt._function:\n    if (!declaration && this.options.ecmaVersion >= 6) this.unexpected()\n    return this.parseFunctionStatement(node, false)\n  case tt._class:\n    if (!declaration) this.unexpected()\n    return this.parseClass(node, true)\n  case tt._if: return this.parseIfStatement(node)\n  case tt._return: return this.parseReturnStatement(node)\n  case tt._switch: return this.parseSwitchStatement(node)\n  case tt._throw: return this.parseThrowStatement(node)\n  case tt._try: return this.parseTryStatement(node)\n  case tt._const: case tt._var:\n    kind = kind || this.value\n    if (!declaration && kind != \"var\") this.unexpected()\n    return this.parseVarStatement(node, kind)\n  case tt._while: return this.parseWhileStatement(node)\n  case tt._with: return this.parseWithStatement(node)\n  case tt.braceL: return this.parseBlock()\n  case tt.semi: return this.parseEmptyStatement(node)\n  case tt._export:\n  case tt._import:\n    if (!this.options.allowImportExportEverywhere) {\n      if (!topLevel)\n        this.raise(this.start, \"'import' and 'export' may only appear at the top level\")\n      if (!this.inModule)\n        this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\")\n    }\n    return starttype === tt._import ? this.parseImport(node) : this.parseExport(node, exports)\n\n    // If the statement does not start with a statement keyword or a\n    // brace, it's an ExpressionStatement or LabeledStatement. We\n    // simply start parsing an expression, and afterwards, if the\n    // next token is a colon and the expression was a simple\n    // Identifier node, we switch to interpreting it as a label.\n  default:\n    if (this.isAsyncFunction() && declaration) {\n      this.next()\n      return this.parseFunctionStatement(node, true)\n    }\n\n    var maybeName = this.value, expr = this.parseExpression()\n    if (starttype === tt.name && expr.type === \"Identifier\" && this.eat(tt.colon))\n      return this.parseLabeledStatement(node, maybeName, expr)\n    else return this.parseExpressionStatement(node, expr)\n  }\n}\n\npp$1.parseBreakContinueStatement = function(node, keyword) {\n  var this$1 = this;\n\n  var isBreak = keyword == \"break\"\n  this.next()\n  if (this.eat(tt.semi) || this.insertSemicolon()) node.label = null\n  else if (this.type !== tt.name) this.unexpected()\n  else {\n    node.label = this.parseIdent()\n    this.semicolon()\n  }\n\n  // Verify that there is an actual destination to break or\n  // continue to.\n  for (var i = 0; i < this.labels.length; ++i) {\n    var lab = this$1.labels[i]\n    if (node.label == null || lab.name === node.label.name) {\n      if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break\n      if (node.label && isBreak) break\n    }\n  }\n  if (i === this.labels.length) this.raise(node.start, \"Unsyntactic \" + keyword)\n  return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\n}\n\npp$1.parseDebuggerStatement = function(node) {\n  this.next()\n  this.semicolon()\n  return this.finishNode(node, \"DebuggerStatement\")\n}\n\npp$1.parseDoStatement = function(node) {\n  this.next()\n  this.labels.push(loopLabel)\n  node.body = this.parseStatement(false)\n  this.labels.pop()\n  this.expect(tt._while)\n  node.test = this.parseParenExpression()\n  if (this.options.ecmaVersion >= 6)\n    this.eat(tt.semi)\n  else\n    this.semicolon()\n  return this.finishNode(node, \"DoWhileStatement\")\n}\n\n// Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n// loop is non-trivial. Basically, we have to parse the init `var`\n// statement or expression, disallowing the `in` operator (see\n// the second parameter to `parseExpression`), and then check\n// whether the next token is `in` or `of`. When there is no init\n// part (semicolon immediately after the opening parenthesis), it\n// is a regular `for` loop.\n\npp$1.parseForStatement = function(node) {\n  this.next()\n  this.labels.push(loopLabel)\n  this.expect(tt.parenL)\n  if (this.type === tt.semi) return this.parseFor(node, null)\n  var isLet = this.isLet()\n  if (this.type === tt._var || this.type === tt._const || isLet) {\n    var init$1 = this.startNode(), kind = isLet ? \"let\" : this.value\n    this.next()\n    this.parseVar(init$1, true, kind)\n    this.finishNode(init$1, \"VariableDeclaration\")\n    if ((this.type === tt._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) && init$1.declarations.length === 1 &&\n        !(kind !== \"var\" && init$1.declarations[0].init))\n      return this.parseForIn(node, init$1)\n    return this.parseFor(node, init$1)\n  }\n  var refDestructuringErrors = new DestructuringErrors\n  var init = this.parseExpression(true, refDestructuringErrors)\n  if (this.type === tt._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n    this.toAssignable(init)\n    this.checkLVal(init)\n    this.checkPatternErrors(refDestructuringErrors, true)\n    return this.parseForIn(node, init)\n  } else {\n    this.checkExpressionErrors(refDestructuringErrors, true)\n  }\n  return this.parseFor(node, init)\n}\n\npp$1.parseFunctionStatement = function(node, isAsync) {\n  this.next()\n  return this.parseFunction(node, true, false, isAsync)\n}\n\npp$1.isFunction = function() {\n  return this.type === tt._function || this.isAsyncFunction()\n}\n\npp$1.parseIfStatement = function(node) {\n  this.next()\n  node.test = this.parseParenExpression()\n  // allow function declarations in branches, but only in non-strict mode\n  node.consequent = this.parseStatement(!this.strict && this.isFunction())\n  node.alternate = this.eat(tt._else) ? this.parseStatement(!this.strict && this.isFunction()) : null\n  return this.finishNode(node, \"IfStatement\")\n}\n\npp$1.parseReturnStatement = function(node) {\n  if (!this.inFunction && !this.options.allowReturnOutsideFunction)\n    this.raise(this.start, \"'return' outside of function\")\n  this.next()\n\n  // In `return` (and `break`/`continue`), the keywords with\n  // optional arguments, we eagerly look for a semicolon or the\n  // possibility to insert one.\n\n  if (this.eat(tt.semi) || this.insertSemicolon()) node.argument = null\n  else { node.argument = this.parseExpression(); this.semicolon() }\n  return this.finishNode(node, \"ReturnStatement\")\n}\n\npp$1.parseSwitchStatement = function(node) {\n  var this$1 = this;\n\n  this.next()\n  node.discriminant = this.parseParenExpression()\n  node.cases = []\n  this.expect(tt.braceL)\n  this.labels.push(switchLabel)\n\n  // Statements under must be grouped (by label) in SwitchCase\n  // nodes. `cur` is used to keep the node that we are currently\n  // adding statements to.\n\n  for (var cur, sawDefault = false; this.type != tt.braceR;) {\n    if (this$1.type === tt._case || this$1.type === tt._default) {\n      var isCase = this$1.type === tt._case\n      if (cur) this$1.finishNode(cur, \"SwitchCase\")\n      node.cases.push(cur = this$1.startNode())\n      cur.consequent = []\n      this$1.next()\n      if (isCase) {\n        cur.test = this$1.parseExpression()\n      } else {\n        if (sawDefault) this$1.raiseRecoverable(this$1.lastTokStart, \"Multiple default clauses\")\n        sawDefault = true\n        cur.test = null\n      }\n      this$1.expect(tt.colon)\n    } else {\n      if (!cur) this$1.unexpected()\n      cur.consequent.push(this$1.parseStatement(true))\n    }\n  }\n  if (cur) this.finishNode(cur, \"SwitchCase\")\n  this.next() // Closing brace\n  this.labels.pop()\n  return this.finishNode(node, \"SwitchStatement\")\n}\n\npp$1.parseThrowStatement = function(node) {\n  this.next()\n  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))\n    this.raise(this.lastTokEnd, \"Illegal newline after throw\")\n  node.argument = this.parseExpression()\n  this.semicolon()\n  return this.finishNode(node, \"ThrowStatement\")\n}\n\n// Reused empty array added for node fields that are always empty.\n\nvar empty = []\n\npp$1.parseTryStatement = function(node) {\n  this.next()\n  node.block = this.parseBlock()\n  node.handler = null\n  if (this.type === tt._catch) {\n    var clause = this.startNode()\n    this.next()\n    this.expect(tt.parenL)\n    clause.param = this.parseBindingAtom()\n    this.checkLVal(clause.param, true)\n    this.expect(tt.parenR)\n    clause.body = this.parseBlock()\n    node.handler = this.finishNode(clause, \"CatchClause\")\n  }\n  node.finalizer = this.eat(tt._finally) ? this.parseBlock() : null\n  if (!node.handler && !node.finalizer)\n    this.raise(node.start, \"Missing catch or finally clause\")\n  return this.finishNode(node, \"TryStatement\")\n}\n\npp$1.parseVarStatement = function(node, kind) {\n  this.next()\n  this.parseVar(node, false, kind)\n  this.semicolon()\n  return this.finishNode(node, \"VariableDeclaration\")\n}\n\npp$1.parseWhileStatement = function(node) {\n  this.next()\n  node.test = this.parseParenExpression()\n  this.labels.push(loopLabel)\n  node.body = this.parseStatement(false)\n  this.labels.pop()\n  return this.finishNode(node, \"WhileStatement\")\n}\n\npp$1.parseWithStatement = function(node) {\n  if (this.strict) this.raise(this.start, \"'with' in strict mode\")\n  this.next()\n  node.object = this.parseParenExpression()\n  node.body = this.parseStatement(false)\n  return this.finishNode(node, \"WithStatement\")\n}\n\npp$1.parseEmptyStatement = function(node) {\n  this.next()\n  return this.finishNode(node, \"EmptyStatement\")\n}\n\npp$1.parseLabeledStatement = function(node, maybeName, expr) {\n  var this$1 = this;\n\n  for (var i = 0; i < this.labels.length; ++i)\n    if (this$1.labels[i].name === maybeName) this$1.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\")\n  var kind = this.type.isLoop ? \"loop\" : this.type === tt._switch ? \"switch\" : null\n  for (var i$1 = this.labels.length - 1; i$1 >= 0; i$1--) {\n    var label = this$1.labels[i$1]\n    if (label.statementStart == node.start) {\n      label.statementStart = this$1.start\n      label.kind = kind\n    } else break\n  }\n  this.labels.push({name: maybeName, kind: kind, statementStart: this.start})\n  node.body = this.parseStatement(true)\n  if (node.body.type == \"ClassDeclaration\" ||\n      node.body.type == \"VariableDeclaration\" && (this.strict || node.body.kind != \"var\") ||\n      node.body.type == \"FunctionDeclaration\" && (this.strict || node.body.generator))\n    this.raiseRecoverable(node.body.start, \"Invalid labeled declaration\")\n  this.labels.pop()\n  node.label = expr\n  return this.finishNode(node, \"LabeledStatement\")\n}\n\npp$1.parseExpressionStatement = function(node, expr) {\n  node.expression = expr\n  this.semicolon()\n  return this.finishNode(node, \"ExpressionStatement\")\n}\n\n// Parse a semicolon-enclosed block of statements, handling `\"use\n// strict\"` declarations when `allowStrict` is true (used for\n// function bodies).\n\npp$1.parseBlock = function() {\n  var this$1 = this;\n\n  var node = this.startNode()\n  node.body = []\n  this.expect(tt.braceL)\n  while (!this.eat(tt.braceR)) {\n    var stmt = this$1.parseStatement(true)\n    node.body.push(stmt)\n  }\n  return this.finishNode(node, \"BlockStatement\")\n}\n\n// Parse a regular `for` loop. The disambiguation code in\n// `parseStatement` will already have parsed the init statement or\n// expression.\n\npp$1.parseFor = function(node, init) {\n  node.init = init\n  this.expect(tt.semi)\n  node.test = this.type === tt.semi ? null : this.parseExpression()\n  this.expect(tt.semi)\n  node.update = this.type === tt.parenR ? null : this.parseExpression()\n  this.expect(tt.parenR)\n  node.body = this.parseStatement(false)\n  this.labels.pop()\n  return this.finishNode(node, \"ForStatement\")\n}\n\n// Parse a `for`/`in` and `for`/`of` loop, which are almost\n// same from parser's perspective.\n\npp$1.parseForIn = function(node, init) {\n  var type = this.type === tt._in ? \"ForInStatement\" : \"ForOfStatement\"\n  this.next()\n  node.left = init\n  node.right = this.parseExpression()\n  this.expect(tt.parenR)\n  node.body = this.parseStatement(false)\n  this.labels.pop()\n  return this.finishNode(node, type)\n}\n\n// Parse a list of variable declarations.\n\npp$1.parseVar = function(node, isFor, kind) {\n  var this$1 = this;\n\n  node.declarations = []\n  node.kind = kind\n  for (;;) {\n    var decl = this$1.startNode()\n    this$1.parseVarId(decl)\n    if (this$1.eat(tt.eq)) {\n      decl.init = this$1.parseMaybeAssign(isFor)\n    } else if (kind === \"const\" && !(this$1.type === tt._in || (this$1.options.ecmaVersion >= 6 && this$1.isContextual(\"of\")))) {\n      this$1.unexpected()\n    } else if (decl.id.type != \"Identifier\" && !(isFor && (this$1.type === tt._in || this$1.isContextual(\"of\")))) {\n      this$1.raise(this$1.lastTokEnd, \"Complex binding patterns require an initialization value\")\n    } else {\n      decl.init = null\n    }\n    node.declarations.push(this$1.finishNode(decl, \"VariableDeclarator\"))\n    if (!this$1.eat(tt.comma)) break\n  }\n  return node\n}\n\npp$1.parseVarId = function(decl) {\n  decl.id = this.parseBindingAtom()\n  this.checkLVal(decl.id, true)\n}\n\n// Parse a function declaration or literal (depending on the\n// `isStatement` parameter).\n\npp$1.parseFunction = function(node, isStatement, allowExpressionBody, isAsync) {\n  this.initFunction(node)\n  if (this.options.ecmaVersion >= 6 && !isAsync)\n    node.generator = this.eat(tt.star)\n  if (this.options.ecmaVersion >= 8)\n    node.async = !!isAsync\n\n  if (isStatement == null)\n    isStatement = this.type == tt.name\n  if (isStatement)\n    node.id = this.parseIdent()\n\n  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction\n  this.inGenerator = node.generator\n  this.inAsync = node.async\n  this.yieldPos = 0\n  this.awaitPos = 0\n  this.inFunction = true\n\n  if (!isStatement && this.type === tt.name)\n    node.id = this.parseIdent()\n  this.parseFunctionParams(node)\n  this.parseFunctionBody(node, allowExpressionBody)\n\n  this.inGenerator = oldInGen\n  this.inAsync = oldInAsync\n  this.yieldPos = oldYieldPos\n  this.awaitPos = oldAwaitPos\n  this.inFunction = oldInFunc\n  return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\")\n}\n\npp$1.parseFunctionParams = function(node) {\n  this.expect(tt.parenL)\n  node.params = this.parseBindingList(tt.parenR, false, this.options.ecmaVersion >= 8, true)\n  this.checkYieldAwaitInDefaultParams()\n}\n\n// Parse a class declaration or literal (depending on the\n// `isStatement` parameter).\n\npp$1.parseClass = function(node, isStatement) {\n  var this$1 = this;\n\n  this.next()\n  if (isStatement == null) isStatement = this.type === tt.name\n  this.parseClassId(node, isStatement)\n  this.parseClassSuper(node)\n  var classBody = this.startNode()\n  var hadConstructor = false\n  classBody.body = []\n  this.expect(tt.braceL)\n  while (!this.eat(tt.braceR)) {\n    if (this$1.eat(tt.semi)) continue\n    var method = this$1.startNode()\n    var isGenerator = this$1.eat(tt.star)\n    var isAsync = false\n    var isMaybeStatic = this$1.type === tt.name && this$1.value === \"static\"\n    this$1.parsePropertyName(method)\n    method.static = isMaybeStatic && this$1.type !== tt.parenL\n    if (method.static) {\n      if (isGenerator) this$1.unexpected()\n      isGenerator = this$1.eat(tt.star)\n      this$1.parsePropertyName(method)\n    }\n    if (this$1.options.ecmaVersion >= 8 && !isGenerator && !method.computed &&\n        method.key.type === \"Identifier\" && method.key.name === \"async\" && this$1.type !== tt.parenL &&\n        !this$1.canInsertSemicolon()) {\n      isAsync = true\n      this$1.parsePropertyName(method)\n    }\n    method.kind = \"method\"\n    var isGetSet = false\n    if (!method.computed) {\n      var key = method.key;\n      if (!isGenerator && !isAsync && key.type === \"Identifier\" && this$1.type !== tt.parenL && (key.name === \"get\" || key.name === \"set\")) {\n        isGetSet = true\n        method.kind = key.name\n        key = this$1.parsePropertyName(method)\n      }\n      if (!method.static && (key.type === \"Identifier\" && key.name === \"constructor\" ||\n          key.type === \"Literal\" && key.value === \"constructor\")) {\n        if (hadConstructor) this$1.raise(key.start, \"Duplicate constructor in the same class\")\n        if (isGetSet) this$1.raise(key.start, \"Constructor can't have get/set modifier\")\n        if (isGenerator) this$1.raise(key.start, \"Constructor can't be a generator\")\n        if (isAsync) this$1.raise(key.start, \"Constructor can't be an async method\")\n        method.kind = \"constructor\"\n        hadConstructor = true\n      }\n    }\n    this$1.parseClassMethod(classBody, method, isGenerator, isAsync)\n    if (isGetSet) {\n      var paramCount = method.kind === \"get\" ? 0 : 1\n      if (method.value.params.length !== paramCount) {\n        var start = method.value.start\n        if (method.kind === \"get\")\n          this$1.raiseRecoverable(start, \"getter should have no params\")\n        else\n          this$1.raiseRecoverable(start, \"setter should have exactly one param\")\n      } else {\n        if (method.kind === \"set\" && method.value.params[0].type === \"RestElement\")\n          this$1.raiseRecoverable(method.value.params[0].start, \"Setter cannot use rest params\")\n      }\n    }\n  }\n  node.body = this.finishNode(classBody, \"ClassBody\")\n  return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n}\n\npp$1.parseClassMethod = function(classBody, method, isGenerator, isAsync) {\n  method.value = this.parseMethod(isGenerator, isAsync)\n  classBody.body.push(this.finishNode(method, \"MethodDefinition\"))\n}\n\npp$1.parseClassId = function(node, isStatement) {\n  node.id = this.type === tt.name ? this.parseIdent() : isStatement ? this.unexpected() : null\n}\n\npp$1.parseClassSuper = function(node) {\n  node.superClass = this.eat(tt._extends) ? this.parseExprSubscripts() : null\n}\n\n// Parses module export declaration.\n\npp$1.parseExport = function(node, exports) {\n  var this$1 = this;\n\n  this.next()\n  // export * from '...'\n  if (this.eat(tt.star)) {\n    this.expectContextual(\"from\")\n    node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()\n    this.semicolon()\n    return this.finishNode(node, \"ExportAllDeclaration\")\n  }\n  if (this.eat(tt._default)) { // export default ...\n    this.checkExport(exports, \"default\", this.lastTokStart)\n    var isAsync\n    if (this.type === tt._function || (isAsync = this.isAsyncFunction())) {\n      var fNode = this.startNode()\n      this.next()\n      if (isAsync) this.next()\n      node.declaration = this.parseFunction(fNode, null, false, isAsync)\n    } else if (this.type === tt._class) {\n      var cNode = this.startNode()\n      node.declaration = this.parseClass(cNode, null)\n    } else {\n      node.declaration = this.parseMaybeAssign()\n      this.semicolon()\n    }\n    return this.finishNode(node, \"ExportDefaultDeclaration\")\n  }\n  // export var|const|let|function|class ...\n  if (this.shouldParseExportStatement()) {\n    node.declaration = this.parseStatement(true)\n    if (node.declaration.type === \"VariableDeclaration\")\n      this.checkVariableExport(exports, node.declaration.declarations)\n    else\n      this.checkExport(exports, node.declaration.id.name, node.declaration.id.start)\n    node.specifiers = []\n    node.source = null\n  } else { // export { x, y as z } [from '...']\n    node.declaration = null\n    node.specifiers = this.parseExportSpecifiers(exports)\n    if (this.eatContextual(\"from\")) {\n      node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()\n    } else {\n      // check for keywords used as local names\n      for (var i = 0; i < node.specifiers.length; i++) {\n        if (this$1.keywords.test(node.specifiers[i].local.name) || this$1.reservedWords.test(node.specifiers[i].local.name)) {\n          this$1.unexpected(node.specifiers[i].local.start)\n        }\n      }\n\n      node.source = null\n    }\n    this.semicolon()\n  }\n  return this.finishNode(node, \"ExportNamedDeclaration\")\n}\n\npp$1.checkExport = function(exports, name, pos) {\n  if (!exports) return\n  if (Object.prototype.hasOwnProperty.call(exports, name))\n    this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\")\n  exports[name] = true\n}\n\npp$1.checkPatternExport = function(exports, pat) {\n  var this$1 = this;\n\n  var type = pat.type\n  if (type == \"Identifier\")\n    this.checkExport(exports, pat.name, pat.start)\n  else if (type == \"ObjectPattern\")\n    for (var i = 0; i < pat.properties.length; ++i)\n      this$1.checkPatternExport(exports, pat.properties[i].value)\n  else if (type == \"ArrayPattern\")\n    for (var i$1 = 0; i$1 < pat.elements.length; ++i$1) {\n      var elt = pat.elements[i$1]\n      if (elt) this$1.checkPatternExport(exports, elt)\n    }\n  else if (type == \"AssignmentPattern\")\n    this.checkPatternExport(exports, pat.left)\n  else if (type == \"ParenthesizedExpression\")\n    this.checkPatternExport(exports, pat.expression)\n}\n\npp$1.checkVariableExport = function(exports, decls) {\n  var this$1 = this;\n\n  if (!exports) return\n  for (var i = 0; i < decls.length; i++)\n    this$1.checkPatternExport(exports, decls[i].id)\n}\n\npp$1.shouldParseExportStatement = function() {\n  return this.type.keyword === \"var\"\n    || this.type.keyword === \"const\"\n    || this.type.keyword === \"class\"\n    || this.type.keyword === \"function\"\n    || this.isLet()\n    || this.isAsyncFunction()\n}\n\n// Parses a comma-separated list of module exports.\n\npp$1.parseExportSpecifiers = function(exports) {\n  var this$1 = this;\n\n  var nodes = [], first = true\n  // export { x, y as z } [from '...']\n  this.expect(tt.braceL)\n  while (!this.eat(tt.braceR)) {\n    if (!first) {\n      this$1.expect(tt.comma)\n      if (this$1.afterTrailingComma(tt.braceR)) break\n    } else first = false\n\n    var node = this$1.startNode()\n    node.local = this$1.parseIdent(true)\n    node.exported = this$1.eatContextual(\"as\") ? this$1.parseIdent(true) : node.local\n    this$1.checkExport(exports, node.exported.name, node.exported.start)\n    nodes.push(this$1.finishNode(node, \"ExportSpecifier\"))\n  }\n  return nodes\n}\n\n// Parses import declaration.\n\npp$1.parseImport = function(node) {\n  this.next()\n  // import '...'\n  if (this.type === tt.string) {\n    node.specifiers = empty\n    node.source = this.parseExprAtom()\n  } else {\n    node.specifiers = this.parseImportSpecifiers()\n    this.expectContextual(\"from\")\n    node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()\n  }\n  this.semicolon()\n  return this.finishNode(node, \"ImportDeclaration\")\n}\n\n// Parses a comma-separated list of module imports.\n\npp$1.parseImportSpecifiers = function() {\n  var this$1 = this;\n\n  var nodes = [], first = true\n  if (this.type === tt.name) {\n    // import defaultObj, { x, y as z } from '...'\n    var node = this.startNode()\n    node.local = this.parseIdent()\n    this.checkLVal(node.local, true)\n    nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"))\n    if (!this.eat(tt.comma)) return nodes\n  }\n  if (this.type === tt.star) {\n    var node$1 = this.startNode()\n    this.next()\n    this.expectContextual(\"as\")\n    node$1.local = this.parseIdent()\n    this.checkLVal(node$1.local, true)\n    nodes.push(this.finishNode(node$1, \"ImportNamespaceSpecifier\"))\n    return nodes\n  }\n  this.expect(tt.braceL)\n  while (!this.eat(tt.braceR)) {\n    if (!first) {\n      this$1.expect(tt.comma)\n      if (this$1.afterTrailingComma(tt.braceR)) break\n    } else first = false\n\n    var node$2 = this$1.startNode()\n    node$2.imported = this$1.parseIdent(true)\n    if (this$1.eatContextual(\"as\")) {\n      node$2.local = this$1.parseIdent()\n    } else {\n      node$2.local = node$2.imported\n      if (this$1.isKeyword(node$2.local.name)) this$1.unexpected(node$2.local.start)\n      if (this$1.reservedWordsStrict.test(node$2.local.name)) this$1.raiseRecoverable(node$2.local.start, \"The keyword '\" + node$2.local.name + \"' is reserved\")\n    }\n    this$1.checkLVal(node$2.local, true)\n    nodes.push(this$1.finishNode(node$2, \"ImportSpecifier\"))\n  }\n  return nodes\n}\n\nvar pp$2 = Parser.prototype\n\n// Convert existing expression atom to assignable pattern\n// if possible.\n\npp$2.toAssignable = function(node, isBinding) {\n  var this$1 = this;\n\n  if (this.options.ecmaVersion >= 6 && node) {\n    switch (node.type) {\n      case \"Identifier\":\n      if (this.inAsync && node.name === \"await\")\n        this.raise(node.start, \"Can not use 'await' as identifier inside an async function\")\n      break\n\n    case \"ObjectPattern\":\n    case \"ArrayPattern\":\n      break\n\n    case \"ObjectExpression\":\n      node.type = \"ObjectPattern\"\n      for (var i = 0; i < node.properties.length; i++) {\n        var prop = node.properties[i]\n        if (prop.kind !== \"init\") this$1.raise(prop.key.start, \"Object pattern can't contain getter or setter\")\n        this$1.toAssignable(prop.value, isBinding)\n      }\n      break\n\n    case \"ArrayExpression\":\n      node.type = \"ArrayPattern\"\n      this.toAssignableList(node.elements, isBinding)\n      break\n\n    case \"AssignmentExpression\":\n      if (node.operator === \"=\") {\n        node.type = \"AssignmentPattern\"\n        delete node.operator\n        this.toAssignable(node.left, isBinding)\n        // falls through to AssignmentPattern\n      } else {\n        this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\")\n        break\n      }\n\n    case \"AssignmentPattern\":\n      break\n\n    case \"ParenthesizedExpression\":\n      node.expression = this.toAssignable(node.expression, isBinding)\n      break\n\n    case \"MemberExpression\":\n      if (!isBinding) break\n\n    default:\n      this.raise(node.start, \"Assigning to rvalue\")\n    }\n  }\n  return node\n}\n\n// Convert list of expression atoms to binding list.\n\npp$2.toAssignableList = function(exprList, isBinding) {\n  var this$1 = this;\n\n  var end = exprList.length\n  if (end) {\n    var last = exprList[end - 1]\n    if (last && last.type == \"RestElement\") {\n      --end\n    } else if (last && last.type == \"SpreadElement\") {\n      last.type = \"RestElement\"\n      var arg = last.argument\n      this.toAssignable(arg, isBinding)\n      if (arg.type !== \"Identifier\" && arg.type !== \"MemberExpression\" && arg.type !== \"ArrayPattern\")\n        this.unexpected(arg.start)\n      --end\n    }\n\n    if (isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\")\n      this.unexpected(last.argument.start)\n  }\n  for (var i = 0; i < end; i++) {\n    var elt = exprList[i]\n    if (elt) this$1.toAssignable(elt, isBinding)\n  }\n  return exprList\n}\n\n// Parses spread element.\n\npp$2.parseSpread = function(refDestructuringErrors) {\n  var node = this.startNode()\n  this.next()\n  node.argument = this.parseMaybeAssign(false, refDestructuringErrors)\n  return this.finishNode(node, \"SpreadElement\")\n}\n\npp$2.parseRest = function(allowNonIdent) {\n  var node = this.startNode()\n  this.next()\n\n  // RestElement inside of a function parameter must be an identifier\n  if (allowNonIdent) node.argument = this.type === tt.name ? this.parseIdent() : this.unexpected()\n  else node.argument = this.type === tt.name || this.type === tt.bracketL ? this.parseBindingAtom() : this.unexpected()\n\n  return this.finishNode(node, \"RestElement\")\n}\n\n// Parses lvalue (assignable) atom.\n\npp$2.parseBindingAtom = function() {\n  if (this.options.ecmaVersion < 6) return this.parseIdent()\n  switch (this.type) {\n  case tt.name:\n    return this.parseIdent()\n\n  case tt.bracketL:\n    var node = this.startNode()\n    this.next()\n    node.elements = this.parseBindingList(tt.bracketR, true, true)\n    return this.finishNode(node, \"ArrayPattern\")\n\n  case tt.braceL:\n    return this.parseObj(true)\n\n  default:\n    this.unexpected()\n  }\n}\n\npp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowNonIdent) {\n  var this$1 = this;\n\n  var elts = [], first = true\n  while (!this.eat(close)) {\n    if (first) first = false\n    else this$1.expect(tt.comma)\n    if (allowEmpty && this$1.type === tt.comma) {\n      elts.push(null)\n    } else if (allowTrailingComma && this$1.afterTrailingComma(close)) {\n      break\n    } else if (this$1.type === tt.ellipsis) {\n      var rest = this$1.parseRest(allowNonIdent)\n      this$1.parseBindingListItem(rest)\n      elts.push(rest)\n      if (this$1.type === tt.comma) this$1.raise(this$1.start, \"Comma is not permitted after the rest element\")\n      this$1.expect(close)\n      break\n    } else {\n      var elem = this$1.parseMaybeDefault(this$1.start, this$1.startLoc)\n      this$1.parseBindingListItem(elem)\n      elts.push(elem)\n    }\n  }\n  return elts\n}\n\npp$2.parseBindingListItem = function(param) {\n  return param\n}\n\n// Parses assignment pattern around given atom if possible.\n\npp$2.parseMaybeDefault = function(startPos, startLoc, left) {\n  left = left || this.parseBindingAtom()\n  if (this.options.ecmaVersion < 6 || !this.eat(tt.eq)) return left\n  var node = this.startNodeAt(startPos, startLoc)\n  node.left = left\n  node.right = this.parseMaybeAssign()\n  return this.finishNode(node, \"AssignmentPattern\")\n}\n\n// Verify that a node is an lval  something that can be assigned\n// to.\n\npp$2.checkLVal = function(expr, isBinding, checkClashes) {\n  var this$1 = this;\n\n  switch (expr.type) {\n  case \"Identifier\":\n    if (this.strict && this.reservedWordsStrictBind.test(expr.name))\n      this.raiseRecoverable(expr.start, (isBinding ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\")\n    if (checkClashes) {\n      if (has(checkClashes, expr.name))\n        this.raiseRecoverable(expr.start, \"Argument name clash\")\n      checkClashes[expr.name] = true\n    }\n    break\n\n  case \"MemberExpression\":\n    if (isBinding) this.raiseRecoverable(expr.start, (isBinding ? \"Binding\" : \"Assigning to\") + \" member expression\")\n    break\n\n  case \"ObjectPattern\":\n    for (var i = 0; i < expr.properties.length; i++)\n      this$1.checkLVal(expr.properties[i].value, isBinding, checkClashes)\n    break\n\n  case \"ArrayPattern\":\n    for (var i$1 = 0; i$1 < expr.elements.length; i$1++) {\n      var elem = expr.elements[i$1]\n      if (elem) this$1.checkLVal(elem, isBinding, checkClashes)\n    }\n    break\n\n  case \"AssignmentPattern\":\n    this.checkLVal(expr.left, isBinding, checkClashes)\n    break\n\n  case \"RestElement\":\n    this.checkLVal(expr.argument, isBinding, checkClashes)\n    break\n\n  case \"ParenthesizedExpression\":\n    this.checkLVal(expr.expression, isBinding, checkClashes)\n    break\n\n  default:\n    this.raise(expr.start, (isBinding ? \"Binding\" : \"Assigning to\") + \" rvalue\")\n  }\n}\n\n// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts  that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\nvar pp$3 = Parser.prototype\n\n// Check if property name clashes with already added.\n// Object/class getters and setters are not allowed to clash \n// either with each other or with an init property  and in\n// strict mode, init properties are also not allowed to be repeated.\n\npp$3.checkPropClash = function(prop, propHash) {\n  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))\n    return\n  var key = prop.key;\n  var name\n  switch (key.type) {\n  case \"Identifier\": name = key.name; break\n  case \"Literal\": name = String(key.value); break\n  default: return\n  }\n  var kind = prop.kind;\n  if (this.options.ecmaVersion >= 6) {\n    if (name === \"__proto__\" && kind === \"init\") {\n      if (propHash.proto) this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\")\n      propHash.proto = true\n    }\n    return\n  }\n  name = \"$\" + name\n  var other = propHash[name]\n  if (other) {\n    var isGetSet = kind !== \"init\"\n    if ((this.strict || isGetSet) && other[kind] || !(isGetSet ^ other.init))\n      this.raiseRecoverable(key.start, \"Redefinition of property\")\n  } else {\n    other = propHash[name] = {\n      init: false,\n      get: false,\n      set: false\n    }\n  }\n  other[kind] = true\n}\n\n// ### Expression parsing\n\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function(s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\n\n// Parse a full expression. The optional arguments are used to\n// forbid the `in` operator (in for loops initalization expressions)\n// and provide reference for storing '=' operator inside shorthand\n// property assignment in contexts where both object expression\n// and object pattern might appear (so it's possible to raise\n// delayed syntax error at correct position).\n\npp$3.parseExpression = function(noIn, refDestructuringErrors) {\n  var this$1 = this;\n\n  var startPos = this.start, startLoc = this.startLoc\n  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors)\n  if (this.type === tt.comma) {\n    var node = this.startNodeAt(startPos, startLoc)\n    node.expressions = [expr]\n    while (this.eat(tt.comma)) node.expressions.push(this$1.parseMaybeAssign(noIn, refDestructuringErrors))\n    return this.finishNode(node, \"SequenceExpression\")\n  }\n  return expr\n}\n\n// Parse an assignment expression. This includes applications of\n// operators like `+=`.\n\npp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {\n  if (this.inGenerator && this.isContextual(\"yield\")) return this.parseYield()\n\n  var ownDestructuringErrors = false, oldParenAssign = -1\n  if (refDestructuringErrors) {\n    oldParenAssign = refDestructuringErrors.parenthesizedAssign\n    refDestructuringErrors.parenthesizedAssign = -1\n  } else {\n    refDestructuringErrors = new DestructuringErrors\n    ownDestructuringErrors = true\n  }\n\n  var startPos = this.start, startLoc = this.startLoc\n  if (this.type == tt.parenL || this.type == tt.name)\n    this.potentialArrowAt = this.start\n  var left = this.parseMaybeConditional(noIn, refDestructuringErrors)\n  if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc)\n  if (this.type.isAssign) {\n    this.checkPatternErrors(refDestructuringErrors, true)\n    if (!ownDestructuringErrors) DestructuringErrors.call(refDestructuringErrors)\n    var node = this.startNodeAt(startPos, startLoc)\n    node.operator = this.value\n    node.left = this.type === tt.eq ? this.toAssignable(left) : left\n    refDestructuringErrors.shorthandAssign = -1 // reset because shorthand default was used correctly\n    this.checkLVal(left)\n    this.next()\n    node.right = this.parseMaybeAssign(noIn)\n    return this.finishNode(node, \"AssignmentExpression\")\n  } else {\n    if (ownDestructuringErrors) this.checkExpressionErrors(refDestructuringErrors, true)\n  }\n  if (oldParenAssign > -1) refDestructuringErrors.parenthesizedAssign = oldParenAssign\n  return left\n}\n\n// Parse a ternary conditional (`?:`) operator.\n\npp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc\n  var expr = this.parseExprOps(noIn, refDestructuringErrors)\n  if (this.checkExpressionErrors(refDestructuringErrors)) return expr\n  if (this.eat(tt.question)) {\n    var node = this.startNodeAt(startPos, startLoc)\n    node.test = expr\n    node.consequent = this.parseMaybeAssign()\n    this.expect(tt.colon)\n    node.alternate = this.parseMaybeAssign(noIn)\n    return this.finishNode(node, \"ConditionalExpression\")\n  }\n  return expr\n}\n\n// Start the precedence parser.\n\npp$3.parseExprOps = function(noIn, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc\n  var expr = this.parseMaybeUnary(refDestructuringErrors, false)\n  if (this.checkExpressionErrors(refDestructuringErrors)) return expr\n  return this.parseExprOp(expr, startPos, startLoc, -1, noIn)\n}\n\n// Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\n\npp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {\n  var prec = this.type.binop\n  if (prec != null && (!noIn || this.type !== tt._in)) {\n    if (prec > minPrec) {\n      var logical = this.type === tt.logicalOR || this.type === tt.logicalAND\n      var op = this.value\n      this.next()\n      var startPos = this.start, startLoc = this.startLoc\n      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn)\n      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical)\n      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)\n    }\n  }\n  return left\n}\n\npp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {\n  var node = this.startNodeAt(startPos, startLoc)\n  node.left = left\n  node.operator = op\n  node.right = right\n  return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\")\n}\n\n// Parse unary operators, both prefix and postfix.\n\npp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {\n  var this$1 = this;\n\n  var startPos = this.start, startLoc = this.startLoc, expr\n  if (this.inAsync && this.isContextual(\"await\")) {\n    expr = this.parseAwait(refDestructuringErrors)\n    sawUnary = true\n  } else if (this.type.prefix) {\n    var node = this.startNode(), update = this.type === tt.incDec\n    node.operator = this.value\n    node.prefix = true\n    this.next()\n    node.argument = this.parseMaybeUnary(null, true)\n    this.checkExpressionErrors(refDestructuringErrors, true)\n    if (update) this.checkLVal(node.argument)\n    else if (this.strict && node.operator === \"delete\" &&\n             node.argument.type === \"Identifier\")\n      this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\")\n    else sawUnary = true\n    expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\")\n  } else {\n    expr = this.parseExprSubscripts(refDestructuringErrors)\n    if (this.checkExpressionErrors(refDestructuringErrors)) return expr\n    while (this.type.postfix && !this.canInsertSemicolon()) {\n      var node$1 = this$1.startNodeAt(startPos, startLoc)\n      node$1.operator = this$1.value\n      node$1.prefix = false\n      node$1.argument = expr\n      this$1.checkLVal(expr)\n      this$1.next()\n      expr = this$1.finishNode(node$1, \"UpdateExpression\")\n    }\n  }\n\n  if (!sawUnary && this.eat(tt.starstar))\n    return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), \"**\", false)\n  else\n    return expr\n}\n\n// Parse call, dot, and `[]`-subscript expressions.\n\npp$3.parseExprSubscripts = function(refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc\n  var expr = this.parseExprAtom(refDestructuringErrors)\n  var skipArrowSubscripts = expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\"\n  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) return expr\n  var result = this.parseSubscripts(expr, startPos, startLoc)\n  if (refDestructuringErrors && result.type === \"MemberExpression\") {\n    if (refDestructuringErrors.parenthesizedAssign >= result.start) refDestructuringErrors.parenthesizedAssign = -1\n    if (refDestructuringErrors.parenthesizedBind >= result.start) refDestructuringErrors.parenthesizedBind = -1\n  }\n  return result\n}\n\npp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {\n  var this$1 = this;\n\n  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" &&\n      this.lastTokEnd == base.end && !this.canInsertSemicolon()\n  for (var computed;;) {\n    if ((computed = this$1.eat(tt.bracketL)) || this$1.eat(tt.dot)) {\n      var node = this$1.startNodeAt(startPos, startLoc)\n      node.object = base\n      node.property = computed ? this$1.parseExpression() : this$1.parseIdent(true)\n      node.computed = !!computed\n      if (computed) this$1.expect(tt.bracketR)\n      base = this$1.finishNode(node, \"MemberExpression\")\n    } else if (!noCalls && this$1.eat(tt.parenL)) {\n      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this$1.yieldPos, oldAwaitPos = this$1.awaitPos\n      this$1.yieldPos = 0\n      this$1.awaitPos = 0\n      var exprList = this$1.parseExprList(tt.parenR, this$1.options.ecmaVersion >= 8, false, refDestructuringErrors)\n      if (maybeAsyncArrow && !this$1.canInsertSemicolon() && this$1.eat(tt.arrow)) {\n        this$1.checkPatternErrors(refDestructuringErrors, false)\n        this$1.checkYieldAwaitInDefaultParams()\n        this$1.yieldPos = oldYieldPos\n        this$1.awaitPos = oldAwaitPos\n        return this$1.parseArrowExpression(this$1.startNodeAt(startPos, startLoc), exprList, true)\n      }\n      this$1.checkExpressionErrors(refDestructuringErrors, true)\n      this$1.yieldPos = oldYieldPos || this$1.yieldPos\n      this$1.awaitPos = oldAwaitPos || this$1.awaitPos\n      var node$1 = this$1.startNodeAt(startPos, startLoc)\n      node$1.callee = base\n      node$1.arguments = exprList\n      base = this$1.finishNode(node$1, \"CallExpression\")\n    } else if (this$1.type === tt.backQuote) {\n      var node$2 = this$1.startNodeAt(startPos, startLoc)\n      node$2.tag = base\n      node$2.quasi = this$1.parseTemplate()\n      base = this$1.finishNode(node$2, \"TaggedTemplateExpression\")\n    } else {\n      return base\n    }\n  }\n}\n\n// Parse an atomic expression  either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\n\npp$3.parseExprAtom = function(refDestructuringErrors) {\n  var node, canBeArrow = this.potentialArrowAt == this.start\n  switch (this.type) {\n  case tt._super:\n    if (!this.inFunction)\n      this.raise(this.start, \"'super' outside of function or class\")\n\n  case tt._this:\n    var type = this.type === tt._this ? \"ThisExpression\" : \"Super\"\n    node = this.startNode()\n    this.next()\n    return this.finishNode(node, type)\n\n  case tt.name:\n    var startPos = this.start, startLoc = this.startLoc\n    var id = this.parseIdent(this.type !== tt.name)\n    if (this.options.ecmaVersion >= 8 && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(tt._function))\n      return this.parseFunction(this.startNodeAt(startPos, startLoc), false, false, true)\n    if (canBeArrow && !this.canInsertSemicolon()) {\n      if (this.eat(tt.arrow))\n        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false)\n      if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === tt.name) {\n        id = this.parseIdent()\n        if (this.canInsertSemicolon() || !this.eat(tt.arrow))\n          this.unexpected()\n        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)\n      }\n    }\n    return id\n\n  case tt.regexp:\n    var value = this.value\n    node = this.parseLiteral(value.value)\n    node.regex = {pattern: value.pattern, flags: value.flags}\n    return node\n\n  case tt.num: case tt.string:\n    return this.parseLiteral(this.value)\n\n  case tt._null: case tt._true: case tt._false:\n    node = this.startNode()\n    node.value = this.type === tt._null ? null : this.type === tt._true\n    node.raw = this.type.keyword\n    this.next()\n    return this.finishNode(node, \"Literal\")\n\n  case tt.parenL:\n    var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow)\n    if (refDestructuringErrors) {\n      if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))\n        refDestructuringErrors.parenthesizedAssign = start\n      if (refDestructuringErrors.parenthesizedBind < 0)\n        refDestructuringErrors.parenthesizedBind = start\n    }\n    return expr\n\n  case tt.bracketL:\n    node = this.startNode()\n    this.next()\n    node.elements = this.parseExprList(tt.bracketR, true, true, refDestructuringErrors)\n    return this.finishNode(node, \"ArrayExpression\")\n\n  case tt.braceL:\n    return this.parseObj(false, refDestructuringErrors)\n\n  case tt._function:\n    node = this.startNode()\n    this.next()\n    return this.parseFunction(node, false)\n\n  case tt._class:\n    return this.parseClass(this.startNode(), false)\n\n  case tt._new:\n    return this.parseNew()\n\n  case tt.backQuote:\n    return this.parseTemplate()\n\n  default:\n    this.unexpected()\n  }\n}\n\npp$3.parseLiteral = function(value) {\n  var node = this.startNode()\n  node.value = value\n  node.raw = this.input.slice(this.start, this.end)\n  this.next()\n  return this.finishNode(node, \"Literal\")\n}\n\npp$3.parseParenExpression = function() {\n  this.expect(tt.parenL)\n  var val = this.parseExpression()\n  this.expect(tt.parenR)\n  return val\n}\n\npp$3.parseParenAndDistinguishExpression = function(canBeArrow) {\n  var this$1 = this;\n\n  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8\n  if (this.options.ecmaVersion >= 6) {\n    this.next()\n\n    var innerStartPos = this.start, innerStartLoc = this.startLoc\n    var exprList = [], first = true, lastIsComma = false\n    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart, innerParenStart\n    this.yieldPos = 0\n    this.awaitPos = 0\n    while (this.type !== tt.parenR) {\n      first ? first = false : this$1.expect(tt.comma)\n      if (allowTrailingComma && this$1.afterTrailingComma(tt.parenR, true)) {\n        lastIsComma = true\n        break\n      } else if (this$1.type === tt.ellipsis) {\n        spreadStart = this$1.start\n        exprList.push(this$1.parseParenItem(this$1.parseRest()))\n        if (this$1.type === tt.comma) this$1.raise(this$1.start, \"Comma is not permitted after the rest element\")\n        break\n      } else {\n        if (this$1.type === tt.parenL && !innerParenStart) {\n          innerParenStart = this$1.start\n        }\n        exprList.push(this$1.parseMaybeAssign(false, refDestructuringErrors, this$1.parseParenItem))\n      }\n    }\n    var innerEndPos = this.start, innerEndLoc = this.startLoc\n    this.expect(tt.parenR)\n\n    if (canBeArrow && !this.canInsertSemicolon() && this.eat(tt.arrow)) {\n      this.checkPatternErrors(refDestructuringErrors, false)\n      this.checkYieldAwaitInDefaultParams()\n      if (innerParenStart) this.unexpected(innerParenStart)\n      this.yieldPos = oldYieldPos\n      this.awaitPos = oldAwaitPos\n      return this.parseParenArrowList(startPos, startLoc, exprList)\n    }\n\n    if (!exprList.length || lastIsComma) this.unexpected(this.lastTokStart)\n    if (spreadStart) this.unexpected(spreadStart)\n    this.checkExpressionErrors(refDestructuringErrors, true)\n    this.yieldPos = oldYieldPos || this.yieldPos\n    this.awaitPos = oldAwaitPos || this.awaitPos\n\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartPos, innerStartLoc)\n      val.expressions = exprList\n      this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc)\n    } else {\n      val = exprList[0]\n    }\n  } else {\n    val = this.parseParenExpression()\n  }\n\n  if (this.options.preserveParens) {\n    var par = this.startNodeAt(startPos, startLoc)\n    par.expression = val\n    return this.finishNode(par, \"ParenthesizedExpression\")\n  } else {\n    return val\n  }\n}\n\npp$3.parseParenItem = function(item) {\n  return item\n}\n\npp$3.parseParenArrowList = function(startPos, startLoc, exprList) {\n  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)\n}\n\n// New's precedence is slightly tricky. It must allow its argument to\n// be a `[]` or dot subscript expression, but not a call  at least,\n// not without wrapping it in parentheses. Thus, it uses the noCalls\n// argument to parseSubscripts to prevent it from consuming the\n// argument list.\n\nvar empty$1 = []\n\npp$3.parseNew = function() {\n  var node = this.startNode()\n  var meta = this.parseIdent(true)\n  if (this.options.ecmaVersion >= 6 && this.eat(tt.dot)) {\n    node.meta = meta\n    node.property = this.parseIdent(true)\n    if (node.property.name !== \"target\")\n      this.raiseRecoverable(node.property.start, \"The only valid meta property for new is new.target\")\n    if (!this.inFunction)\n      this.raiseRecoverable(node.start, \"new.target can only be used in functions\")\n    return this.finishNode(node, \"MetaProperty\")\n  }\n  var startPos = this.start, startLoc = this.startLoc\n  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true)\n  if (this.eat(tt.parenL)) node.arguments = this.parseExprList(tt.parenR, this.options.ecmaVersion >= 8, false)\n  else node.arguments = empty$1\n  return this.finishNode(node, \"NewExpression\")\n}\n\n// Parse template expression.\n\npp$3.parseTemplateElement = function() {\n  var elem = this.startNode()\n  elem.value = {\n    raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, '\\n'),\n    cooked: this.value\n  }\n  this.next()\n  elem.tail = this.type === tt.backQuote\n  return this.finishNode(elem, \"TemplateElement\")\n}\n\npp$3.parseTemplate = function() {\n  var this$1 = this;\n\n  var node = this.startNode()\n  this.next()\n  node.expressions = []\n  var curElt = this.parseTemplateElement()\n  node.quasis = [curElt]\n  while (!curElt.tail) {\n    this$1.expect(tt.dollarBraceL)\n    node.expressions.push(this$1.parseExpression())\n    this$1.expect(tt.braceR)\n    node.quasis.push(curElt = this$1.parseTemplateElement())\n  }\n  this.next()\n  return this.finishNode(node, \"TemplateLiteral\")\n}\n\n// Parse an object literal or binding pattern.\n\npp$3.parseObj = function(isPattern, refDestructuringErrors) {\n  var this$1 = this;\n\n  var node = this.startNode(), first = true, propHash = {}\n  node.properties = []\n  this.next()\n  while (!this.eat(tt.braceR)) {\n    if (!first) {\n      this$1.expect(tt.comma)\n      if (this$1.afterTrailingComma(tt.braceR)) break\n    } else first = false\n\n    var prop = this$1.startNode(), isGenerator, isAsync, startPos, startLoc\n    if (this$1.options.ecmaVersion >= 6) {\n      prop.method = false\n      prop.shorthand = false\n      if (isPattern || refDestructuringErrors) {\n        startPos = this$1.start\n        startLoc = this$1.startLoc\n      }\n      if (!isPattern)\n        isGenerator = this$1.eat(tt.star)\n    }\n    this$1.parsePropertyName(prop)\n    if (!isPattern && this$1.options.ecmaVersion >= 8 && !isGenerator && !prop.computed &&\n        prop.key.type === \"Identifier\" && prop.key.name === \"async\" && this$1.type !== tt.parenL &&\n        this$1.type !== tt.colon && !this$1.canInsertSemicolon()) {\n      isAsync = true\n      this$1.parsePropertyName(prop, refDestructuringErrors)\n    } else {\n      isAsync = false\n    }\n    this$1.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors)\n    this$1.checkPropClash(prop, propHash)\n    node.properties.push(this$1.finishNode(prop, \"Property\"))\n  }\n  return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\")\n}\n\npp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors) {\n  if ((isGenerator || isAsync) && this.type === tt.colon)\n    this.unexpected()\n\n  if (this.eat(tt.colon)) {\n    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors)\n    prop.kind = \"init\"\n  } else if (this.options.ecmaVersion >= 6 && this.type === tt.parenL) {\n    if (isPattern) this.unexpected()\n    prop.kind = \"init\"\n    prop.method = true\n    prop.value = this.parseMethod(isGenerator, isAsync)\n  } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" &&\n             (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n             (this.type != tt.comma && this.type != tt.braceR)) {\n    if (isGenerator || isAsync || isPattern) this.unexpected()\n    prop.kind = prop.key.name\n    this.parsePropertyName(prop)\n    prop.value = this.parseMethod(false)\n    var paramCount = prop.kind === \"get\" ? 0 : 1\n    if (prop.value.params.length !== paramCount) {\n      var start = prop.value.start\n      if (prop.kind === \"get\")\n        this.raiseRecoverable(start, \"getter should have no params\")\n      else\n        this.raiseRecoverable(start, \"setter should have exactly one param\")\n    } else {\n      if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\")\n        this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\")\n    }\n  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n    if (this.keywords.test(prop.key.name) ||\n        (this.strict ? this.reservedWordsStrict : this.reservedWords).test(prop.key.name) ||\n        (this.inGenerator && prop.key.name == \"yield\") ||\n        (this.inAsync && prop.key.name == \"await\"))\n      this.raiseRecoverable(prop.key.start, \"'\" + prop.key.name + \"' can not be used as shorthand property\")\n    prop.kind = \"init\"\n    if (isPattern) {\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key)\n    } else if (this.type === tt.eq && refDestructuringErrors) {\n      if (refDestructuringErrors.shorthandAssign < 0)\n        refDestructuringErrors.shorthandAssign = this.start\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key)\n    } else {\n      prop.value = prop.key\n    }\n    prop.shorthand = true\n  } else this.unexpected()\n}\n\npp$3.parsePropertyName = function(prop) {\n  if (this.options.ecmaVersion >= 6) {\n    if (this.eat(tt.bracketL)) {\n      prop.computed = true\n      prop.key = this.parseMaybeAssign()\n      this.expect(tt.bracketR)\n      return prop.key\n    } else {\n      prop.computed = false\n    }\n  }\n  return prop.key = this.type === tt.num || this.type === tt.string ? this.parseExprAtom() : this.parseIdent(true)\n}\n\n// Initialize empty function node.\n\npp$3.initFunction = function(node) {\n  node.id = null\n  if (this.options.ecmaVersion >= 6) {\n    node.generator = false\n    node.expression = false\n  }\n  if (this.options.ecmaVersion >= 8)\n    node.async = false\n}\n\n// Parse object or class method.\n\npp$3.parseMethod = function(isGenerator, isAsync) {\n  var node = this.startNode(), oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction\n\n  this.initFunction(node)\n  if (this.options.ecmaVersion >= 6)\n    node.generator = isGenerator\n  if (this.options.ecmaVersion >= 8)\n    node.async = !!isAsync\n\n  this.inGenerator = node.generator\n  this.inAsync = node.async\n  this.yieldPos = 0\n  this.awaitPos = 0\n  this.inFunction = true\n\n  this.expect(tt.parenL)\n  node.params = this.parseBindingList(tt.parenR, false, this.options.ecmaVersion >= 8)\n  this.checkYieldAwaitInDefaultParams()\n  this.parseFunctionBody(node, false)\n\n  this.inGenerator = oldInGen\n  this.inAsync = oldInAsync\n  this.yieldPos = oldYieldPos\n  this.awaitPos = oldAwaitPos\n  this.inFunction = oldInFunc\n  return this.finishNode(node, \"FunctionExpression\")\n}\n\n// Parse arrow function expression with given parameters.\n\npp$3.parseArrowExpression = function(node, params, isAsync) {\n  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction\n\n  this.initFunction(node)\n  if (this.options.ecmaVersion >= 8)\n    node.async = !!isAsync\n\n  this.inGenerator = false\n  this.inAsync = node.async\n  this.yieldPos = 0\n  this.awaitPos = 0\n  this.inFunction = true\n\n  node.params = this.toAssignableList(params, true)\n  this.parseFunctionBody(node, true)\n\n  this.inGenerator = oldInGen\n  this.inAsync = oldInAsync\n  this.yieldPos = oldYieldPos\n  this.awaitPos = oldAwaitPos\n  this.inFunction = oldInFunc\n  return this.finishNode(node, \"ArrowFunctionExpression\")\n}\n\n// Parse function body and check parameters.\n\npp$3.parseFunctionBody = function(node, isArrowFunction) {\n  var isExpression = isArrowFunction && this.type !== tt.braceL\n  var oldStrict = this.strict, useStrict = false\n\n  if (isExpression) {\n    node.body = this.parseMaybeAssign()\n    node.expression = true\n  } else {\n    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params)\n    if (!oldStrict || nonSimple) {\n      useStrict = this.strictDirective(this.end)\n      // If this is a strict mode function, verify that argument names\n      // are not repeated, and it does not try to bind the words `eval`\n      // or `arguments`.\n      if (useStrict && nonSimple)\n        this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\")\n    }\n    // Start a new scope with regard to labels and the `inFunction`\n    // flag (restore them to their old value afterwards).\n    var oldLabels = this.labels\n    this.labels = []\n    if (useStrict) this.strict = true\n    node.body = this.parseBlock(true)\n    node.expression = false\n    this.labels = oldLabels\n  }\n\n  if (oldStrict || useStrict) {\n    this.strict = true\n    if (node.id)\n      this.checkLVal(node.id, true)\n    this.checkParams(node)\n    this.strict = oldStrict\n  } else if (isArrowFunction || !this.isSimpleParamList(node.params)) {\n    this.checkParams(node)\n  }\n}\n\npp$3.isSimpleParamList = function(params) {\n  for (var i = 0; i < params.length; i++)\n    if (params[i].type !== \"Identifier\") return false\n  return true\n}\n\n// Checks function params for various disallowed patterns such as using \"eval\"\n// or \"arguments\" and duplicate parameters.\n\npp$3.checkParams = function(node) {\n  var this$1 = this;\n\n  var nameHash = {}\n  for (var i = 0; i < node.params.length; i++) this$1.checkLVal(node.params[i], true, nameHash)\n}\n\n// Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\n\npp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n  var this$1 = this;\n\n  var elts = [], first = true\n  while (!this.eat(close)) {\n    if (!first) {\n      this$1.expect(tt.comma)\n      if (allowTrailingComma && this$1.afterTrailingComma(close)) break\n    } else first = false\n\n    var elt\n    if (allowEmpty && this$1.type === tt.comma)\n      elt = null\n    else if (this$1.type === tt.ellipsis) {\n      elt = this$1.parseSpread(refDestructuringErrors)\n      if (refDestructuringErrors && this$1.type === tt.comma && refDestructuringErrors.trailingComma < 0)\n        refDestructuringErrors.trailingComma = this$1.start\n    } else {\n      elt = this$1.parseMaybeAssign(false, refDestructuringErrors)\n    }\n    elts.push(elt)\n  }\n  return elts\n}\n\n// Parse the next token as an identifier. If `liberal` is true (used\n// when parsing properties), it will also convert keywords into\n// identifiers.\n\npp$3.parseIdent = function(liberal) {\n  var node = this.startNode()\n  if (liberal && this.options.allowReserved == \"never\") liberal = false\n  if (this.type === tt.name) {\n    if (!liberal && (this.strict ? this.reservedWordsStrict : this.reservedWords).test(this.value) &&\n        (this.options.ecmaVersion >= 6 ||\n         this.input.slice(this.start, this.end).indexOf(\"\\\\\") == -1))\n      this.raiseRecoverable(this.start, \"The keyword '\" + this.value + \"' is reserved\")\n    if (this.inGenerator && this.value === \"yield\")\n      this.raiseRecoverable(this.start, \"Can not use 'yield' as identifier inside a generator\")\n    if (this.inAsync && this.value === \"await\")\n      this.raiseRecoverable(this.start, \"Can not use 'await' as identifier inside an async function\")\n    node.name = this.value\n  } else if (liberal && this.type.keyword) {\n    node.name = this.type.keyword\n  } else {\n    this.unexpected()\n  }\n  this.next()\n  return this.finishNode(node, \"Identifier\")\n}\n\n// Parses yield expression inside generator.\n\npp$3.parseYield = function() {\n  if (!this.yieldPos) this.yieldPos = this.start\n\n  var node = this.startNode()\n  this.next()\n  if (this.type == tt.semi || this.canInsertSemicolon() || (this.type != tt.star && !this.type.startsExpr)) {\n    node.delegate = false\n    node.argument = null\n  } else {\n    node.delegate = this.eat(tt.star)\n    node.argument = this.parseMaybeAssign()\n  }\n  return this.finishNode(node, \"YieldExpression\")\n}\n\npp$3.parseAwait = function() {\n  if (!this.awaitPos) this.awaitPos = this.start\n\n  var node = this.startNode()\n  this.next()\n  node.argument = this.parseMaybeUnary(null, true)\n  return this.finishNode(node, \"AwaitExpression\")\n}\n\nvar pp$4 = Parser.prototype\n\n// This function is used to raise exceptions on parse errors. It\n// takes an offset integer (into the current `input`) to indicate\n// the location of the error, attaches the position to the end\n// of the error message, and then raises a `SyntaxError` with that\n// message.\n\npp$4.raise = function(pos, message) {\n  var loc = getLineInfo(this.input, pos)\n  message += \" (\" + loc.line + \":\" + loc.column + \")\"\n  var err = new SyntaxError(message)\n  err.pos = pos; err.loc = loc; err.raisedAt = this.pos\n  throw err\n}\n\npp$4.raiseRecoverable = pp$4.raise\n\npp$4.curPosition = function() {\n  if (this.options.locations) {\n    return new Position(this.curLine, this.pos - this.lineStart)\n  }\n}\n\nvar Node = function Node(parser, pos, loc) {\n  this.type = \"\"\n  this.start = pos\n  this.end = 0\n  if (parser.options.locations)\n    this.loc = new SourceLocation(parser, loc)\n  if (parser.options.directSourceFile)\n    this.sourceFile = parser.options.directSourceFile\n  if (parser.options.ranges)\n    this.range = [pos, 0]\n};\n\n// Start an AST node, attaching a start offset.\n\nvar pp$5 = Parser.prototype\n\npp$5.startNode = function() {\n  return new Node(this, this.start, this.startLoc)\n}\n\npp$5.startNodeAt = function(pos, loc) {\n  return new Node(this, pos, loc)\n}\n\n// Finish an AST node, adding `type` and `end` properties.\n\nfunction finishNodeAt(node, type, pos, loc) {\n  node.type = type\n  node.end = pos\n  if (this.options.locations)\n    node.loc.end = loc\n  if (this.options.ranges)\n    node.range[1] = pos\n  return node\n}\n\npp$5.finishNode = function(node, type) {\n  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)\n}\n\n// Finish node at given position\n\npp$5.finishNodeAt = function(node, type, pos, loc) {\n  return finishNodeAt.call(this, node, type, pos, loc)\n}\n\n// The algorithm used to determine whether a regexp can appear at a\n// given point in the program is loosely based on sweet.js' approach.\n// See https://github.com/mozilla/sweet.js/wiki/design\n\nvar TokContext = function TokContext(token, isExpr, preserveSpace, override) {\n  this.token = token\n  this.isExpr = !!isExpr\n  this.preserveSpace = !!preserveSpace\n  this.override = override\n};\n\nvar types = {\n  b_stat: new TokContext(\"{\", false),\n  b_expr: new TokContext(\"{\", true),\n  b_tmpl: new TokContext(\"${\", true),\n  p_stat: new TokContext(\"(\", false),\n  p_expr: new TokContext(\"(\", true),\n  q_tmpl: new TokContext(\"`\", true, true, function (p) { return p.readTmplToken(); }),\n  f_expr: new TokContext(\"function\", true)\n}\n\nvar pp$6 = Parser.prototype\n\npp$6.initialContext = function() {\n  return [types.b_stat]\n}\n\npp$6.braceIsBlock = function(prevType) {\n  if (prevType === tt.colon) {\n    var parent = this.curContext()\n    if (parent === types.b_stat || parent === types.b_expr)\n      return !parent.isExpr\n  }\n  if (prevType === tt._return)\n    return lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n  if (prevType === tt._else || prevType === tt.semi || prevType === tt.eof || prevType === tt.parenR)\n    return true\n  if (prevType == tt.braceL)\n    return this.curContext() === types.b_stat\n  return !this.exprAllowed\n}\n\npp$6.updateContext = function(prevType) {\n  var update, type = this.type\n  if (type.keyword && prevType == tt.dot)\n    this.exprAllowed = false\n  else if (update = type.updateContext)\n    update.call(this, prevType)\n  else\n    this.exprAllowed = type.beforeExpr\n}\n\n// Token-specific context update code\n\ntt.parenR.updateContext = tt.braceR.updateContext = function() {\n  if (this.context.length == 1) {\n    this.exprAllowed = true\n    return\n  }\n  var out = this.context.pop()\n  if (out === types.b_stat && this.curContext() === types.f_expr) {\n    this.context.pop()\n    this.exprAllowed = false\n  } else if (out === types.b_tmpl) {\n    this.exprAllowed = true\n  } else {\n    this.exprAllowed = !out.isExpr\n  }\n}\n\ntt.braceL.updateContext = function(prevType) {\n  this.context.push(this.braceIsBlock(prevType) ? types.b_stat : types.b_expr)\n  this.exprAllowed = true\n}\n\ntt.dollarBraceL.updateContext = function() {\n  this.context.push(types.b_tmpl)\n  this.exprAllowed = true\n}\n\ntt.parenL.updateContext = function(prevType) {\n  var statementParens = prevType === tt._if || prevType === tt._for || prevType === tt._with || prevType === tt._while\n  this.context.push(statementParens ? types.p_stat : types.p_expr)\n  this.exprAllowed = true\n}\n\ntt.incDec.updateContext = function() {\n  // tokExprAllowed stays unchanged\n}\n\ntt._function.updateContext = function(prevType) {\n  if (prevType.beforeExpr && prevType !== tt.semi && prevType !== tt._else &&\n      !((prevType === tt.colon || prevType === tt.braceL) && this.curContext() === types.b_stat))\n    this.context.push(types.f_expr)\n  this.exprAllowed = false\n}\n\ntt.backQuote.updateContext = function() {\n  if (this.curContext() === types.q_tmpl)\n    this.context.pop()\n  else\n    this.context.push(types.q_tmpl)\n  this.exprAllowed = false\n}\n\n// Object type used to represent tokens. Note that normally, tokens\n// simply exist as properties on the parser object. This is only\n// used for the onToken callback and the external tokenizer.\n\nvar Token = function Token(p) {\n  this.type = p.type\n  this.value = p.value\n  this.start = p.start\n  this.end = p.end\n  if (p.options.locations)\n    this.loc = new SourceLocation(p, p.startLoc, p.endLoc)\n  if (p.options.ranges)\n    this.range = [p.start, p.end]\n};\n\n// ## Tokenizer\n\nvar pp$7 = Parser.prototype\n\n// Are we running under Rhino?\nvar isRhino = typeof Packages == \"object\" && Object.prototype.toString.call(Packages) == \"[object JavaPackage]\"\n\n// Move to the next token\n\npp$7.next = function() {\n  if (this.options.onToken)\n    this.options.onToken(new Token(this))\n\n  this.lastTokEnd = this.end\n  this.lastTokStart = this.start\n  this.lastTokEndLoc = this.endLoc\n  this.lastTokStartLoc = this.startLoc\n  this.nextToken()\n}\n\npp$7.getToken = function() {\n  this.next()\n  return new Token(this)\n}\n\n// If we're in an ES6 environment, make parsers iterable\nif (typeof Symbol !== \"undefined\")\n  pp$7[Symbol.iterator] = function () {\n    var self = this\n    return {next: function () {\n      var token = self.getToken()\n      return {\n        done: token.type === tt.eof,\n        value: token\n      }\n    }}\n  }\n\n// Toggle strict mode. Re-reads the next number or string to please\n// pedantic tests (`\"use strict\"; 010;` should fail).\n\npp$7.curContext = function() {\n  return this.context[this.context.length - 1]\n}\n\n// Read a single token, updating the parser object's token-related\n// properties.\n\npp$7.nextToken = function() {\n  var curContext = this.curContext()\n  if (!curContext || !curContext.preserveSpace) this.skipSpace()\n\n  this.start = this.pos\n  if (this.options.locations) this.startLoc = this.curPosition()\n  if (this.pos >= this.input.length) return this.finishToken(tt.eof)\n\n  if (curContext.override) return curContext.override(this)\n  else this.readToken(this.fullCharCodeAtPos())\n}\n\npp$7.readToken = function(code) {\n  // Identifier or keyword. '\\uXXXX' sequences are allowed in\n  // identifiers, so '\\' also dispatches to that.\n  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\\' */)\n    return this.readWord()\n\n  return this.getTokenFromCode(code)\n}\n\npp$7.fullCharCodeAtPos = function() {\n  var code = this.input.charCodeAt(this.pos)\n  if (code <= 0xd7ff || code >= 0xe000) return code\n  var next = this.input.charCodeAt(this.pos + 1)\n  return (code << 10) + next - 0x35fdc00\n}\n\npp$7.skipBlockComment = function() {\n  var this$1 = this;\n\n  var startLoc = this.options.onComment && this.curPosition()\n  var start = this.pos, end = this.input.indexOf(\"*/\", this.pos += 2)\n  if (end === -1) this.raise(this.pos - 2, \"Unterminated comment\")\n  this.pos = end + 2\n  if (this.options.locations) {\n    lineBreakG.lastIndex = start\n    var match\n    while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {\n      ++this$1.curLine\n      this$1.lineStart = match.index + match[0].length\n    }\n  }\n  if (this.options.onComment)\n    this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,\n                           startLoc, this.curPosition())\n}\n\npp$7.skipLineComment = function(startSkip) {\n  var this$1 = this;\n\n  var start = this.pos\n  var startLoc = this.options.onComment && this.curPosition()\n  var ch = this.input.charCodeAt(this.pos+=startSkip)\n  while (this.pos < this.input.length && ch !== 10 && ch !== 13 && ch !== 8232 && ch !== 8233) {\n    ++this$1.pos\n    ch = this$1.input.charCodeAt(this$1.pos)\n  }\n  if (this.options.onComment)\n    this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,\n                           startLoc, this.curPosition())\n}\n\n// Called at the start of the parse and after every token. Skips\n// whitespace and comments, and.\n\npp$7.skipSpace = function() {\n  var this$1 = this;\n\n  loop: while (this.pos < this.input.length) {\n    var ch = this$1.input.charCodeAt(this$1.pos)\n    switch (ch) {\n      case 32: case 160: // ' '\n        ++this$1.pos\n        break\n      case 13:\n        if (this$1.input.charCodeAt(this$1.pos + 1) === 10) {\n          ++this$1.pos\n        }\n      case 10: case 8232: case 8233:\n        ++this$1.pos\n        if (this$1.options.locations) {\n          ++this$1.curLine\n          this$1.lineStart = this$1.pos\n        }\n        break\n      case 47: // '/'\n        switch (this$1.input.charCodeAt(this$1.pos + 1)) {\n          case 42: // '*'\n            this$1.skipBlockComment()\n            break\n          case 47:\n            this$1.skipLineComment(2)\n            break\n          default:\n            break loop\n        }\n        break\n      default:\n        if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n          ++this$1.pos\n        } else {\n          break loop\n        }\n    }\n  }\n}\n\n// Called at the end of every token. Sets `end`, `val`, and\n// maintains `context` and `exprAllowed`, and skips the space after\n// the token, so that the next one's `start` will point at the\n// right position.\n\npp$7.finishToken = function(type, val) {\n  this.end = this.pos\n  if (this.options.locations) this.endLoc = this.curPosition()\n  var prevType = this.type\n  this.type = type\n  this.value = val\n\n  this.updateContext(prevType)\n}\n\n// ### Token reading\n\n// This is the function that is called to fetch the next token. It\n// is somewhat obscure, because it works in character codes rather\n// than characters, and because operator parsing has been inlined\n// into it.\n//\n// All in the name of speed.\n//\npp$7.readToken_dot = function() {\n  var next = this.input.charCodeAt(this.pos + 1)\n  if (next >= 48 && next <= 57) return this.readNumber(true)\n  var next2 = this.input.charCodeAt(this.pos + 2)\n  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'\n    this.pos += 3\n    return this.finishToken(tt.ellipsis)\n  } else {\n    ++this.pos\n    return this.finishToken(tt.dot)\n  }\n}\n\npp$7.readToken_slash = function() { // '/'\n  var next = this.input.charCodeAt(this.pos + 1)\n  if (this.exprAllowed) {++this.pos; return this.readRegexp()}\n  if (next === 61) return this.finishOp(tt.assign, 2)\n  return this.finishOp(tt.slash, 1)\n}\n\npp$7.readToken_mult_modulo_exp = function(code) { // '%*'\n  var next = this.input.charCodeAt(this.pos + 1)\n  var size = 1\n  var tokentype = code === 42 ? tt.star : tt.modulo\n\n  // exponentiation operator ** and **=\n  if (this.options.ecmaVersion >= 7 && next === 42) {\n    ++size\n    tokentype = tt.starstar\n    next = this.input.charCodeAt(this.pos + 2)\n  }\n\n  if (next === 61) return this.finishOp(tt.assign, size + 1)\n  return this.finishOp(tokentype, size)\n}\n\npp$7.readToken_pipe_amp = function(code) { // '|&'\n  var next = this.input.charCodeAt(this.pos + 1)\n  if (next === code) return this.finishOp(code === 124 ? tt.logicalOR : tt.logicalAND, 2)\n  if (next === 61) return this.finishOp(tt.assign, 2)\n  return this.finishOp(code === 124 ? tt.bitwiseOR : tt.bitwiseAND, 1)\n}\n\npp$7.readToken_caret = function() { // '^'\n  var next = this.input.charCodeAt(this.pos + 1)\n  if (next === 61) return this.finishOp(tt.assign, 2)\n  return this.finishOp(tt.bitwiseXOR, 1)\n}\n\npp$7.readToken_plus_min = function(code) { // '+-'\n  var next = this.input.charCodeAt(this.pos + 1)\n  if (next === code) {\n    if (next == 45 && this.input.charCodeAt(this.pos + 2) == 62 &&\n        lineBreak.test(this.input.slice(this.lastTokEnd, this.pos))) {\n      // A `-->` line comment\n      this.skipLineComment(3)\n      this.skipSpace()\n      return this.nextToken()\n    }\n    return this.finishOp(tt.incDec, 2)\n  }\n  if (next === 61) return this.finishOp(tt.assign, 2)\n  return this.finishOp(tt.plusMin, 1)\n}\n\npp$7.readToken_lt_gt = function(code) { // '<>'\n  var next = this.input.charCodeAt(this.pos + 1)\n  var size = 1\n  if (next === code) {\n    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2\n    if (this.input.charCodeAt(this.pos + size) === 61) return this.finishOp(tt.assign, size + 1)\n    return this.finishOp(tt.bitShift, size)\n  }\n  if (next == 33 && code == 60 && this.input.charCodeAt(this.pos + 2) == 45 &&\n      this.input.charCodeAt(this.pos + 3) == 45) {\n    if (this.inModule) this.unexpected()\n    // `<!--`, an XML-style comment that should be interpreted as a line comment\n    this.skipLineComment(4)\n    this.skipSpace()\n    return this.nextToken()\n  }\n  if (next === 61) size = 2\n  return this.finishOp(tt.relational, size)\n}\n\npp$7.readToken_eq_excl = function(code) { // '=!'\n  var next = this.input.charCodeAt(this.pos + 1)\n  if (next === 61) return this.finishOp(tt.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2)\n  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'\n    this.pos += 2\n    return this.finishToken(tt.arrow)\n  }\n  return this.finishOp(code === 61 ? tt.eq : tt.prefix, 1)\n}\n\npp$7.getTokenFromCode = function(code) {\n  switch (code) {\n    // The interpretation of a dot depends on whether it is followed\n    // by a digit or another two dots.\n  case 46: // '.'\n    return this.readToken_dot()\n\n    // Punctuation tokens.\n  case 40: ++this.pos; return this.finishToken(tt.parenL)\n  case 41: ++this.pos; return this.finishToken(tt.parenR)\n  case 59: ++this.pos; return this.finishToken(tt.semi)\n  case 44: ++this.pos; return this.finishToken(tt.comma)\n  case 91: ++this.pos; return this.finishToken(tt.bracketL)\n  case 93: ++this.pos; return this.finishToken(tt.bracketR)\n  case 123: ++this.pos; return this.finishToken(tt.braceL)\n  case 125: ++this.pos; return this.finishToken(tt.braceR)\n  case 58: ++this.pos; return this.finishToken(tt.colon)\n  case 63: ++this.pos; return this.finishToken(tt.question)\n\n  case 96: // '`'\n    if (this.options.ecmaVersion < 6) break\n    ++this.pos\n    return this.finishToken(tt.backQuote)\n\n  case 48: // '0'\n    var next = this.input.charCodeAt(this.pos + 1)\n    if (next === 120 || next === 88) return this.readRadixNumber(16) // '0x', '0X' - hex number\n    if (this.options.ecmaVersion >= 6) {\n      if (next === 111 || next === 79) return this.readRadixNumber(8) // '0o', '0O' - octal number\n      if (next === 98 || next === 66) return this.readRadixNumber(2) // '0b', '0B' - binary number\n    }\n    // Anything else beginning with a digit is an integer, octal\n    // number, or float.\n  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9\n    return this.readNumber(false)\n\n    // Quotes produce strings.\n  case 34: case 39: // '\"', \"'\"\n    return this.readString(code)\n\n    // Operators are parsed inline in tiny state machines. '=' (61) is\n    // often referred to. `finishOp` simply skips the amount of\n    // characters it is given as second argument, and returns a token\n    // of the type given by its first argument.\n\n  case 47: // '/'\n    return this.readToken_slash()\n\n  case 37: case 42: // '%*'\n    return this.readToken_mult_modulo_exp(code)\n\n  case 124: case 38: // '|&'\n    return this.readToken_pipe_amp(code)\n\n  case 94: // '^'\n    return this.readToken_caret()\n\n  case 43: case 45: // '+-'\n    return this.readToken_plus_min(code)\n\n  case 60: case 62: // '<>'\n    return this.readToken_lt_gt(code)\n\n  case 61: case 33: // '=!'\n    return this.readToken_eq_excl(code)\n\n  case 126: // '~'\n    return this.finishOp(tt.prefix, 1)\n  }\n\n  this.raise(this.pos, \"Unexpected character '\" + codePointToString(code) + \"'\")\n}\n\npp$7.finishOp = function(type, size) {\n  var str = this.input.slice(this.pos, this.pos + size)\n  this.pos += size\n  return this.finishToken(type, str)\n}\n\n// Parse a regular expression. Some context-awareness is necessary,\n// since a '/' inside a '[]' set does not end the expression.\n\nfunction tryCreateRegexp(src, flags, throwErrorAt, parser) {\n  try {\n    return new RegExp(src, flags)\n  } catch (e) {\n    if (throwErrorAt !== undefined) {\n      if (e instanceof SyntaxError) parser.raise(throwErrorAt, \"Error parsing regular expression: \" + e.message)\n      throw e\n    }\n  }\n}\n\nvar regexpUnicodeSupport = !!tryCreateRegexp(\"\\uffff\", \"u\")\n\npp$7.readRegexp = function() {\n  var this$1 = this;\n\n  var escaped, inClass, start = this.pos\n  for (;;) {\n    if (this$1.pos >= this$1.input.length) this$1.raise(start, \"Unterminated regular expression\")\n    var ch = this$1.input.charAt(this$1.pos)\n    if (lineBreak.test(ch)) this$1.raise(start, \"Unterminated regular expression\")\n    if (!escaped) {\n      if (ch === \"[\") inClass = true\n      else if (ch === \"]\" && inClass) inClass = false\n      else if (ch === \"/\" && !inClass) break\n      escaped = ch === \"\\\\\"\n    } else escaped = false\n    ++this$1.pos\n  }\n  var content = this.input.slice(start, this.pos)\n  ++this.pos\n  // Need to use `readWord1` because '\\uXXXX' sequences are allowed\n  // here (don't ask).\n  var mods = this.readWord1()\n  var tmp = content, tmpFlags = \"\"\n  if (mods) {\n    var validFlags = /^[gim]*$/\n    if (this.options.ecmaVersion >= 6) validFlags = /^[gimuy]*$/\n    if (!validFlags.test(mods)) this.raise(start, \"Invalid regular expression flag\")\n    if (mods.indexOf(\"u\") >= 0) {\n      if (regexpUnicodeSupport) {\n        tmpFlags = \"u\"\n      } else {\n        // Replace each astral symbol and every Unicode escape sequence that\n        // possibly represents an astral symbol or a paired surrogate with a\n        // single ASCII symbol to avoid throwing on regular expressions that\n        // are only valid in combination with the `/u` flag.\n        // Note: replacing with the ASCII symbol `x` might cause false\n        // negatives in unlikely scenarios. For example, `[\\u{61}-b]` is a\n        // perfectly valid pattern that is equivalent to `[a-b]`, but it would\n        // be replaced by `[x-b]` which throws an error.\n        tmp = tmp.replace(/\\\\u\\{([0-9a-fA-F]+)\\}/g, function (_match, code, offset) {\n          code = Number(\"0x\" + code)\n          if (code > 0x10FFFF) this$1.raise(start + offset + 3, \"Code point out of bounds\")\n          return \"x\"\n        })\n        tmp = tmp.replace(/\\\\u([a-fA-F0-9]{4})|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, \"x\")\n        tmpFlags = tmpFlags.replace(\"u\", \"\")\n      }\n    }\n  }\n  // Detect invalid regular expressions.\n  var value = null\n  // Rhino's regular expression parser is flaky and throws uncatchable exceptions,\n  // so don't do detection if we are running under Rhino\n  if (!isRhino) {\n    tryCreateRegexp(tmp, tmpFlags, start, this)\n    // Get a regular expression object for this pattern-flag pair, or `null` in\n    // case the current environment doesn't support the flags it uses.\n    value = tryCreateRegexp(content, mods)\n  }\n  return this.finishToken(tt.regexp, {pattern: content, flags: mods, value: value})\n}\n\n// Read an integer in the given radix. Return null if zero digits\n// were read, the integer value otherwise. When `len` is given, this\n// will return `null` unless the integer has exactly `len` digits.\n\npp$7.readInt = function(radix, len) {\n  var this$1 = this;\n\n  var start = this.pos, total = 0\n  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n    var code = this$1.input.charCodeAt(this$1.pos), val\n    if (code >= 97) val = code - 97 + 10 // a\n    else if (code >= 65) val = code - 65 + 10 // A\n    else if (code >= 48 && code <= 57) val = code - 48 // 0-9\n    else val = Infinity\n    if (val >= radix) break\n    ++this$1.pos\n    total = total * radix + val\n  }\n  if (this.pos === start || len != null && this.pos - start !== len) return null\n\n  return total\n}\n\npp$7.readRadixNumber = function(radix) {\n  this.pos += 2 // 0x\n  var val = this.readInt(radix)\n  if (val == null) this.raise(this.start + 2, \"Expected number in radix \" + radix)\n  if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, \"Identifier directly after number\")\n  return this.finishToken(tt.num, val)\n}\n\n// Read an integer, octal integer, or floating-point number.\n\npp$7.readNumber = function(startsWithDot) {\n  var start = this.pos, isFloat = false, octal = this.input.charCodeAt(this.pos) === 48\n  if (!startsWithDot && this.readInt(10) === null) this.raise(start, \"Invalid number\")\n  if (octal && this.pos == start + 1) octal = false\n  var next = this.input.charCodeAt(this.pos)\n  if (next === 46 && !octal) { // '.'\n    ++this.pos\n    this.readInt(10)\n    isFloat = true\n    next = this.input.charCodeAt(this.pos)\n  }\n  if ((next === 69 || next === 101) && !octal) { // 'eE'\n    next = this.input.charCodeAt(++this.pos)\n    if (next === 43 || next === 45) ++this.pos // '+-'\n    if (this.readInt(10) === null) this.raise(start, \"Invalid number\")\n    isFloat = true\n  }\n  if (isIdentifierStart(this.fullCharCodeAtPos())) this.raise(this.pos, \"Identifier directly after number\")\n\n  var str = this.input.slice(start, this.pos), val\n  if (isFloat) val = parseFloat(str)\n  else if (!octal || str.length === 1) val = parseInt(str, 10)\n  else if (/[89]/.test(str) || this.strict) this.raise(start, \"Invalid number\")\n  else val = parseInt(str, 8)\n  return this.finishToken(tt.num, val)\n}\n\n// Read a string value, interpreting backslash-escapes.\n\npp$7.readCodePoint = function() {\n  var ch = this.input.charCodeAt(this.pos), code\n\n  if (ch === 123) {\n    if (this.options.ecmaVersion < 6) this.unexpected()\n    var codePos = ++this.pos\n    code = this.readHexChar(this.input.indexOf('}', this.pos) - this.pos)\n    ++this.pos\n    if (code > 0x10FFFF) this.raise(codePos, \"Code point out of bounds\")\n  } else {\n    code = this.readHexChar(4)\n  }\n  return code\n}\n\nfunction codePointToString(code) {\n  // UTF-16 Decoding\n  if (code <= 0xFFFF) return String.fromCharCode(code)\n  code -= 0x10000\n  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)\n}\n\npp$7.readString = function(quote) {\n  var this$1 = this;\n\n  var out = \"\", chunkStart = ++this.pos\n  for (;;) {\n    if (this$1.pos >= this$1.input.length) this$1.raise(this$1.start, \"Unterminated string constant\")\n    var ch = this$1.input.charCodeAt(this$1.pos)\n    if (ch === quote) break\n    if (ch === 92) { // '\\'\n      out += this$1.input.slice(chunkStart, this$1.pos)\n      out += this$1.readEscapedChar(false)\n      chunkStart = this$1.pos\n    } else {\n      if (isNewLine(ch)) this$1.raise(this$1.start, \"Unterminated string constant\")\n      ++this$1.pos\n    }\n  }\n  out += this.input.slice(chunkStart, this.pos++)\n  return this.finishToken(tt.string, out)\n}\n\n// Reads template string tokens.\n\npp$7.readTmplToken = function() {\n  var this$1 = this;\n\n  var out = \"\", chunkStart = this.pos\n  for (;;) {\n    if (this$1.pos >= this$1.input.length) this$1.raise(this$1.start, \"Unterminated template\")\n    var ch = this$1.input.charCodeAt(this$1.pos)\n    if (ch === 96 || ch === 36 && this$1.input.charCodeAt(this$1.pos + 1) === 123) { // '`', '${'\n      if (this$1.pos === this$1.start && this$1.type === tt.template) {\n        if (ch === 36) {\n          this$1.pos += 2\n          return this$1.finishToken(tt.dollarBraceL)\n        } else {\n          ++this$1.pos\n          return this$1.finishToken(tt.backQuote)\n        }\n      }\n      out += this$1.input.slice(chunkStart, this$1.pos)\n      return this$1.finishToken(tt.template, out)\n    }\n    if (ch === 92) { // '\\'\n      out += this$1.input.slice(chunkStart, this$1.pos)\n      out += this$1.readEscapedChar(true)\n      chunkStart = this$1.pos\n    } else if (isNewLine(ch)) {\n      out += this$1.input.slice(chunkStart, this$1.pos)\n      ++this$1.pos\n      switch (ch) {\n        case 13:\n          if (this$1.input.charCodeAt(this$1.pos) === 10) ++this$1.pos\n        case 10:\n          out += \"\\n\"\n          break\n        default:\n          out += String.fromCharCode(ch)\n          break\n      }\n      if (this$1.options.locations) {\n        ++this$1.curLine\n        this$1.lineStart = this$1.pos\n      }\n      chunkStart = this$1.pos\n    } else {\n      ++this$1.pos\n    }\n  }\n}\n\n// Used to read escaped characters\n\npp$7.readEscapedChar = function(inTemplate) {\n  var ch = this.input.charCodeAt(++this.pos)\n  ++this.pos\n  switch (ch) {\n  case 110: return \"\\n\" // 'n' -> '\\n'\n  case 114: return \"\\r\" // 'r' -> '\\r'\n  case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'\n  case 117: return codePointToString(this.readCodePoint()) // 'u'\n  case 116: return \"\\t\" // 't' -> '\\t'\n  case 98: return \"\\b\" // 'b' -> '\\b'\n  case 118: return \"\\u000b\" // 'v' -> '\\u000b'\n  case 102: return \"\\f\" // 'f' -> '\\f'\n  case 13: if (this.input.charCodeAt(this.pos) === 10) ++this.pos // '\\r\\n'\n  case 10: // ' \\n'\n    if (this.options.locations) { this.lineStart = this.pos; ++this.curLine }\n    return \"\"\n  default:\n    if (ch >= 48 && ch <= 55) {\n      var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0]\n      var octal = parseInt(octalStr, 8)\n      if (octal > 255) {\n        octalStr = octalStr.slice(0, -1)\n        octal = parseInt(octalStr, 8)\n      }\n      if (octalStr !== \"0\" && (this.strict || inTemplate)) {\n        this.raise(this.pos - 2, \"Octal literal in strict mode\")\n      }\n      this.pos += octalStr.length - 1\n      return String.fromCharCode(octal)\n    }\n    return String.fromCharCode(ch)\n  }\n}\n\n// Used to read character escape sequences ('\\x', '\\u', '\\U').\n\npp$7.readHexChar = function(len) {\n  var codePos = this.pos\n  var n = this.readInt(16, len)\n  if (n === null) this.raise(codePos, \"Bad character escape sequence\")\n  return n\n}\n\n// Read an identifier, and return it as a string. Sets `this.containsEsc`\n// to whether the word contained a '\\u' escape.\n//\n// Incrementally adds only escaped chars, adding other chunks as-is\n// as a micro-optimization.\n\npp$7.readWord1 = function() {\n  var this$1 = this;\n\n  this.containsEsc = false\n  var word = \"\", first = true, chunkStart = this.pos\n  var astral = this.options.ecmaVersion >= 6\n  while (this.pos < this.input.length) {\n    var ch = this$1.fullCharCodeAtPos()\n    if (isIdentifierChar(ch, astral)) {\n      this$1.pos += ch <= 0xffff ? 1 : 2\n    } else if (ch === 92) { // \"\\\"\n      this$1.containsEsc = true\n      word += this$1.input.slice(chunkStart, this$1.pos)\n      var escStart = this$1.pos\n      if (this$1.input.charCodeAt(++this$1.pos) != 117) // \"u\"\n        this$1.raise(this$1.pos, \"Expecting Unicode escape sequence \\\\uXXXX\")\n      ++this$1.pos\n      var esc = this$1.readCodePoint()\n      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))\n        this$1.raise(escStart, \"Invalid Unicode escape\")\n      word += codePointToString(esc)\n      chunkStart = this$1.pos\n    } else {\n      break\n    }\n    first = false\n  }\n  return word + this.input.slice(chunkStart, this.pos)\n}\n\n// Read an identifier or keyword token. Will check for reserved\n// words when necessary.\n\npp$7.readWord = function() {\n  var word = this.readWord1()\n  var type = tt.name\n  if (this.keywords.test(word)) {\n    if (this.containsEsc) this.raiseRecoverable(this.start, \"Escape sequence in keyword \" + word)\n    type = keywordTypes[word]\n  }\n  return this.finishToken(type, word)\n}\n\n// Acorn is a tiny, fast JavaScript parser written in JavaScript.\n//\n// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and\n// various contributors and released under an MIT license.\n//\n// Git repositories for Acorn are available at\n//\n//     http://marijnhaverbeke.nl/git/acorn\n//     https://github.com/ternjs/acorn.git\n//\n// Please use the [github bug tracker][ghbt] to report issues.\n//\n// [ghbt]: https://github.com/ternjs/acorn/issues\n//\n// This file defines the main parser interface. The library also comes\n// with a [error-tolerant parser][dammit] and an\n// [abstract syntax tree walker][walk], defined in other files.\n//\n// [dammit]: acorn_loose.js\n// [walk]: util/walk.js\n\nvar version = \"4.0.11\"\n\n// The main exported interface (under `self.acorn` when in the\n// browser) is a `parse` function that takes a code string and\n// returns an abstract syntax tree as specified by [Mozilla parser\n// API][api].\n//\n// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n\nfunction parse(input, options) {\n  return new Parser(options, input).parse()\n}\n\n// This function tries to parse a single expression at a given\n// offset in a string. Useful for parsing mixed-language formats\n// that embed JavaScript expressions.\n\nfunction parseExpressionAt(input, pos, options) {\n  var p = new Parser(options, input, pos)\n  p.nextToken()\n  return p.parseExpression()\n}\n\n// Acorn is organized as a tokenizer and a recursive-descent parser.\n// The `tokenizer` export provides an interface to the tokenizer.\n\nfunction tokenizer(input, options) {\n  return new Parser(options, input)\n}\n\n// This is a terrible kludge to support the existing, pre-ES6\n// interface where the loose parser module retroactively adds exports\n// to this module.\nfunction addLooseExports(parse, Parser, plugins) {\n  exports.parse_dammit = parse\n  exports.LooseParser = Parser\n  exports.pluginsLoose = plugins\n}\n\nexports.version = version;\nexports.parse = parse;\nexports.parseExpressionAt = parseExpressionAt;\nexports.tokenizer = tokenizer;\nexports.addLooseExports = addLooseExports;\nexports.Parser = Parser;\nexports.plugins = plugins;\nexports.defaultOptions = defaultOptions;\nexports.Position = Position;\nexports.SourceLocation = SourceLocation;\nexports.getLineInfo = getLineInfo;\nexports.Node = Node;\nexports.TokenType = TokenType;\nexports.tokTypes = tt;\nexports.keywordTypes = keywordTypes;\nexports.TokContext = TokContext;\nexports.tokContexts = types;\nexports.isIdentifierChar = isIdentifierChar;\nexports.isIdentifierStart = isIdentifierStart;\nexports.Token = Token;\nexports.isNewLine = isNewLine;\nexports.lineBreak = lineBreak;\nexports.lineBreakG = lineBreakG;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction placeHoldersCount (b64) {\n  var len = b64.length\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n}\n\nfunction byteLength (b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return b64.length * 3 / 4 - placeHoldersCount(b64)\n}\n\nfunction toByteArray (b64) {\n  var i, j, l, tmp, placeHolders, arr\n  var len = b64.length\n  placeHolders = placeHoldersCount(b64)\n\n  arr = new Arr(len * 3 / 4 - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0, j = 0; i < l; i += 4, j += 3) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(2)\nvar ieee754 = __webpack_require__(5)\nvar isArray = __webpack_require__(6)\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* WEBPACK VAR INJECTION */(function(Buffer) {var clone = (function() {\n'use strict';\n\nfunction _instanceof(obj, type) {\n  return type != null && obj instanceof type;\n}\n\nvar nativeMap;\ntry {\n  nativeMap = Map;\n} catch(_) {\n  // maybe a reference error because no `Map`. Give it a dummy value that no\n  // value will ever be an instanceof.\n  nativeMap = function() {};\n}\n\nvar nativeSet;\ntry {\n  nativeSet = Set;\n} catch(_) {\n  nativeSet = function() {};\n}\n\nvar nativePromise;\ntry {\n  nativePromise = Promise;\n} catch(_) {\n  nativePromise = function() {};\n}\n\n/**\n * Clones (copies) an Object using deep copying.\n *\n * This function supports circular references by default, but if you are certain\n * there are no circular references in your object, you can save some CPU time\n * by calling clone(obj, false).\n *\n * Caution: if `circular` is false and `parent` contains circular references,\n * your program may enter an infinite loop and crash.\n *\n * @param `parent` - the object to be cloned\n * @param `circular` - set to true if the object to be cloned may contain\n *    circular references. (optional - true by default)\n * @param `depth` - set to a number if the object is only to be cloned to\n *    a particular depth. (optional - defaults to Infinity)\n * @param `prototype` - sets the prototype to be used when cloning an object.\n *    (optional - defaults to parent prototype).\n * @param `includeNonEnumerable` - set to true if the non-enumerable properties\n *    should be cloned as well. Non-enumerable properties on the prototype\n *    chain will be ignored. (optional - false by default)\n*/\nfunction clone(parent, circular, depth, prototype, includeNonEnumerable) {\n  if (typeof circular === 'object') {\n    depth = circular.depth;\n    prototype = circular.prototype;\n    includeNonEnumerable = circular.includeNonEnumerable;\n    circular = circular.circular;\n  }\n  // maintain two arrays for circular references, where corresponding parents\n  // and children have the same index\n  var allParents = [];\n  var allChildren = [];\n\n  var useBuffer = typeof Buffer != 'undefined';\n\n  if (typeof circular == 'undefined')\n    circular = true;\n\n  if (typeof depth == 'undefined')\n    depth = Infinity;\n\n  // recurse this function so we don't reset allParents and allChildren\n  function _clone(parent, depth) {\n    // cloning null always returns null\n    if (parent === null)\n      return null;\n\n    if (depth === 0)\n      return parent;\n\n    var child;\n    var proto;\n    if (typeof parent != 'object') {\n      return parent;\n    }\n\n    if (_instanceof(parent, nativeMap)) {\n      child = new nativeMap();\n    } else if (_instanceof(parent, nativeSet)) {\n      child = new nativeSet();\n    } else if (_instanceof(parent, nativePromise)) {\n      child = new nativePromise(function (resolve, reject) {\n        parent.then(function(value) {\n          resolve(_clone(value, depth - 1));\n        }, function(err) {\n          reject(_clone(err, depth - 1));\n        });\n      });\n    } else if (clone.__isArray(parent)) {\n      child = [];\n    } else if (clone.__isRegExp(parent)) {\n      child = new RegExp(parent.source, __getRegExpFlags(parent));\n      if (parent.lastIndex) child.lastIndex = parent.lastIndex;\n    } else if (clone.__isDate(parent)) {\n      child = new Date(parent.getTime());\n    } else if (useBuffer && Buffer.isBuffer(parent)) {\n      child = new Buffer(parent.length);\n      parent.copy(child);\n      return child;\n    } else if (_instanceof(parent, Error)) {\n      child = Object.create(parent);\n    } else {\n      if (typeof prototype == 'undefined') {\n        proto = Object.getPrototypeOf(parent);\n        child = Object.create(proto);\n      }\n      else {\n        child = Object.create(prototype);\n        proto = prototype;\n      }\n    }\n\n    if (circular) {\n      var index = allParents.indexOf(parent);\n\n      if (index != -1) {\n        return allChildren[index];\n      }\n      allParents.push(parent);\n      allChildren.push(child);\n    }\n\n    if (_instanceof(parent, nativeMap)) {\n      parent.forEach(function(value, key) {\n        var keyChild = _clone(key, depth - 1);\n        var valueChild = _clone(value, depth - 1);\n        child.set(keyChild, valueChild);\n      });\n    }\n    if (_instanceof(parent, nativeSet)) {\n      parent.forEach(function(value) {\n        var entryChild = _clone(value, depth - 1);\n        child.add(entryChild);\n      });\n    }\n\n    for (var i in parent) {\n      var attrs;\n      if (proto) {\n        attrs = Object.getOwnPropertyDescriptor(proto, i);\n      }\n\n      if (Object.keys(parent).indexOf(i) < 0 && attrs && attrs.set == null) {\n        continue;\n      }\n      child[i] = _clone(parent[i], depth - 1);\n    }\n\n    if (Object.getOwnPropertySymbols) {\n      var symbols = Object.getOwnPropertySymbols(parent);\n      for (var i = 0; i < symbols.length; i++) {\n        // Don't need to worry about cloning a symbol because it is a primitive,\n        // like a number or string.\n        var symbol = symbols[i];\n        var descriptor = Object.getOwnPropertyDescriptor(parent, symbol);\n        if (descriptor && !descriptor.enumerable && !includeNonEnumerable) {\n          continue;\n        }\n        child[symbol] = _clone(parent[symbol], depth - 1);\n        if (!descriptor.enumerable) {\n          Object.defineProperty(child, symbol, {\n            enumerable: false\n          });\n        }\n      }\n    }\n\n    if (includeNonEnumerable) {\n      var allPropertyNames = Object.getOwnPropertyNames(parent);\n      for (var i = 0; i < allPropertyNames.length; i++) {\n        var propertyName = allPropertyNames[i];\n        var descriptor = Object.getOwnPropertyDescriptor(parent, propertyName);\n        if (descriptor && descriptor.enumerable) {\n          continue;\n        }\n        child[propertyName] = _clone(parent[propertyName], depth - 1);\n        Object.defineProperty(child, propertyName, {\n          enumerable: false\n        });\n      }\n    }\n\n    return child;\n  }\n\n  return _clone(parent, depth);\n}\n\n/**\n * Simple flat clone using prototype, accepts only objects, usefull for property\n * override on FLAT configuration object (no nested props).\n *\n * USE WITH CAUTION! This may not behave as you wish if you do not know how this\n * works.\n */\nclone.clonePrototype = function clonePrototype(parent) {\n  if (parent === null)\n    return null;\n\n  var c = function () {};\n  c.prototype = parent;\n  return new c();\n};\n\n// private utility functions\n\nfunction __objToStr(o) {\n  return Object.prototype.toString.call(o);\n}\nclone.__objToStr = __objToStr;\n\nfunction __isDate(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object Date]';\n}\nclone.__isDate = __isDate;\n\nfunction __isArray(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object Array]';\n}\nclone.__isArray = __isArray;\n\nfunction __isRegExp(o) {\n  return typeof o === 'object' && __objToStr(o) === '[object RegExp]';\n}\nclone.__isRegExp = __isRegExp;\n\nfunction __getRegExpFlags(re) {\n  var flags = '';\n  if (re.global) flags += 'g';\n  if (re.ignoreCase) flags += 'i';\n  if (re.multiline) flags += 'm';\n  return flags;\n}\nclone.__getRegExpFlags = __getRegExpFlags;\n\nreturn clone;\n})();\n\nif (typeof module === 'object' && module.exports) {\n  module.exports = clone;\n}\n\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3).Buffer))\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports) {\n\nvar toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports) {\n\nvar g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function(\"return this\")() || (1,eval)(\"this\");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === \"object\")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it's\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(0);\n\n\n/***/ })\n/******/ ]);\n});","import { Segment, Vector2d, Degrees, Radians, deg2rad } from \"./geometry\";\n\nexport type Ratio = number;\n\ntype SceneInfo = {\n    readonly painter?: PainterInfo;\n    readonly drawing?: Stroke[];\n};\nexport class SceneState implements SceneInfo {\n    constructor(\n        readonly painter: PainterState,\n        readonly drawing: Stroke[] = []) { }\n\n    update(scene: SceneInfo): SceneState {\n        return new SceneState(\n            scene.painter ? this.painter.update(scene.painter) : this.painter,\n            scene.drawing ? this.drawing.concat(scene.drawing) : this.drawing);\n    }\n}\n\nexport class Stroke {\n    readonly segment: Segment;\n    constructor(\n        private from: Vector2d,\n        private to: Vector2d,\n        readonly color = \"\") {\n\n        this.segment = new Segment(from, to);\n    }\n\n    defaultColor(color: string): Stroke {\n        if (this.color) {\n            return this;\n        } else {\n            return new Stroke(this.from, this.to, color);\n        }\n    }\n\n    draw(ctx: CanvasRenderingContext2D, scale = 1) {\n        ctx.save();\n        if (this.color) {\n            ctx.strokeStyle = this.color;\n        }\n        this.segment.scaled(scale).draw(ctx);\n        ctx.restore();\n    }\n}\n\ntype PainterInfo = {\n    readonly position?: Vector2d;\n    readonly facing?: Degrees;\n    readonly height?: Ratio;\n    readonly opacity?: Ratio;\n};\nexport class PainterState implements PainterInfo {\n    readonly position: Vector2d;\n    readonly facing: Degrees;\n    readonly height: Ratio;\n    readonly opacity: Ratio;\n\n    constructor(\n        base: PainterInfo,\n        {\n            position = base.position,\n            facing = base.facing,\n            height = base.height,\n            opacity = base.opacity\n        } = {} as PainterInfo) {\n\n        this.position = position;\n        this.facing = facing;\n        this.height = height;\n        this.opacity = opacity;\n    }\n\n    get facingRadians(): Radians {\n        return deg2rad(this.facing);\n    }\n\n    update(info: PainterInfo): PainterState {\n        return new PainterState(this, info);\n    }\n}\n","import { Radians, Vector2d, Degrees, deg2rad } from \"./geometry\";\nimport { Frame } from \"./frames\";\n\nexport const ZOOM_DOWN = 1;\nexport const ZOOM_UP = 1.5;\n\nexport class Painter {\n    position: Vector2d = Vector2d.ORIGIN;\n    facing: Degrees = 0;\n    z = ZOOM_DOWN;\n    zoom = 0.5;\n    scale = 3.2;\n    opacity = 1;\n    brushColor = \"black\";\n\n    update(frame: Frame) {\n        this.position = frame.position.scale(this.scale);\n        this.facing = frame.facing;\n        this.z = ZOOM_DOWN + frame.height * (ZOOM_UP - ZOOM_DOWN);\n        this.opacity = frame.opacity;\n        this.brushColor = frame.foreground;\n    }\n    \n    draw(ctx: CanvasRenderingContext2D) {\n        let cx = this.position.x;\n        let cy = this.position.y;\n        \n        let _5 = 5 * this.scale * this.zoom * this.z;\n        let _3 = 3 * this.scale * this.zoom * this.z;\n        \n        ctx.save();\n        \n        ctx.translate(cx, cy);\n        ctx.rotate(deg2rad(this.facing));\n        \n        let zRatio = (this.z - ZOOM_DOWN) / (ZOOM_UP - ZOOM_DOWN);\n        \n        // dot\n        ctx.save();\n\n        ctx.strokeStyle = this.brushColor;\n        ctx.globalAlpha = 1 - zRatio;\n\n        ctx.beginPath();\n        ctx.moveTo(0, 0);\n        ctx.lineTo(0, 0);\n        ctx.stroke();\n\n        ctx.restore();\n\n        // triangle\n        let red = 160 + 95 * (1 - zRatio) | 0;\n        let green = 160 * zRatio | 0;\n        let blue = 160 + 95 * (1 - zRatio) | 0;\n        ctx.strokeStyle = `rgba(${red},${green},${blue},${this.opacity})`;\n\n        ctx.beginPath();\n        ctx.moveTo(_5, -_3);\n        ctx.lineTo(-_5, -_3);\n        ctx.lineTo(0, _3);\n        ctx.lineTo(_5, -_3);\n        ctx.stroke();\n\n        ctx.restore();\n    }\n}"],"sourceRoot":""}